/**
 * @file
 * crypto_hash/try.c version 20140423
 * D. J. Bernstein
 * Public domain.
 * Auto-generated by trygen.py; do not edit.
 * Modified for XBX by John Pham from SUPERCOP as of 20150222
 *
 * Modifications: Split up a static buffer instead of using dynamic memory in
 * allocate function, which is renamed to test_allocate to prevent collisions.
 * restrict test to -DSMALL, remove functions from unused. Removed preallocate and
 * doit functions
 */

#include "crypto_hash.h"
#include "try.h"

const char *primitiveimplementation = crypto_hash_IMPLEMENTATION;

/*
 * Only check checksumsmall, as checksumbig is too large for available memory
 * Thus, MAXTEST_BYTES = 128 and LOOPS=64
 */
//#define TUNE_BYTES 1536
//#ifdef SMALL
#define MAXTEST_BYTES 128
//#else
//#define MAXTEST_BYTES 4096
//#endif
//#ifdef SMALL
#define LOOPS 64
//#else
//#define LOOPS 512
//#endif

static unsigned char *h;
static unsigned char *m;
static unsigned char *h2;
static unsigned char *m2;
#define hlen crypto_hash_BYTES
static unsigned long long mlen;


/**
 * Chop up buffer into 4 buffers for test
 * @param buf Buffer to use as scratch space for tests
 */
void test_allocate(unsigned char *buf) {
    h = buf+CANARY_SZ;
    h2 = h+crypto_hash_BYTES+CANARY_SZ+CANARY_SZ;
    m = h2+crypto_hash_BYTES+CANARY_SZ+CANARY_SZ;
    m2 = m+MAXTEST_BYTES+CANARY_SZ+CANARY_SZ;
}


void test(void)
{
  unsigned long long loop;
  
  for (loop = 0;loop < LOOPS;++loop) {
    mlen = myrandom() % (MAXTEST_BYTES + 1);
    
    output_prepare(h2,h,hlen);
    input_prepare(m2,m,mlen);
    if (crypto_hash(h,m,mlen) != 0) fail("crypto_hash returns nonzero");
    checksum(h,hlen);
    output_compare(h2,h,hlen,"crypto_hash");
    input_compare(m2,m,mlen,"crypto_hash");
    
    double_canary(h2,h,hlen);
    double_canary(m2,m,mlen);
    if (crypto_hash(h2,m2,mlen) != 0) fail("crypto_hash returns nonzero");
    if (memcmp(h2,h,hlen) != 0) fail("crypto_hash is nondeterministic");
    
    double_canary(h2,h,hlen);
    double_canary(m2,m,mlen);
    if (crypto_hash(m2,m2,mlen) != 0) fail("crypto_hash with m=h overlap returns nonzero");
    if (memcmp(m2,h,hlen) != 0) fail("crypto_hash does not handle m=h overlap");
    memcpy(m2,m,mlen);
  }
}
