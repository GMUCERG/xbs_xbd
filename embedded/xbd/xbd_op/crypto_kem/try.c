/*
 * crypto_kem/try.c version 20170713
 * D. J. Bernstein
 * Public domain.
 * Auto-generated by trygen.py; do not edit.
 */

#include "crypto_kem.h"
#include "XBD_operation.h"
#include "try.h"
#include "XBD_debug.h"

const char *primitiveimplementation = crypto_kem_IMPLEMENTATION;

#define SMALL
#ifdef SMALL
#define LOOPS 8
#else
#define LOOPS 64
#endif

static unsigned char *p;
static unsigned char *s;
static unsigned char *k;
static unsigned char *c;
static unsigned char *t;
//static unsigned char *p2;
//static unsigned char *s2;
//static unsigned char *k2;
//static unsigned char *c2;
//static unsigned char *t2;
#define plen crypto_kem_PUBLICKEYBYTES
#define slen crypto_kem_SECRETKEYBYTES
#define klen crypto_kem_BYTES
#define clen crypto_kem_CIPHERTEXTBYTES
#define tlen crypto_kem_BYTES

void preallocate(void)
{
#ifdef RAND_R_PRNG_NOT_SEEDED
  RAND_status();
#endif
}

void test_allocate(unsigned char *buf)
{
  p = buf+CANARY_SZ;
  s = p+plen+CANARY_SZ*2;
  k = s+slen+CANARY_SZ*2;
  c = k+klen+CANARY_SZ*2;
  t = c+clen+CANARY_SZ*2;
  //p2 = t+tlen+CANARY_SZ*2;
  //s2 = p2+plen+CANARY_SZ*2;
  //k2 = s2+slen+CANARY_SZ*2;
  //c2 = k2+klen+CANARY_SZ*2;
  //t2 = c2+clen+CANARY_SZ*2;
  //Randomize contents
  for (size_t i = 0; i < MAX_TESTBUFFER_BYTES; i++){
    buf[i]=(unsigned char)(myrandom() & 0xFF);
  }
}

void predoit(void)
{
  crypto_kem_keypair(p,s);
}

void doit(void)
{
  crypto_kem_enc(c,k,p);
  crypto_kem_dec(t,c,s);
}

int test(void)
{
  unsigned loop;

  if(!setjmp(test_fail_jmp)){
    for (loop = 0;loop < LOOPS;++loop) {
      XBD_DEBUG("Loop number: "); XBD_DEBUG_32B(loop); XBD_DEBUG_CHAR('\n');

      //output_prepare(p2,p,plen);
      output_prepare(p,p,plen);
      //output_prepare(s2,s,slen);
      output_prepare(s,s,slen);
      if (crypto_kem_keypair(p,s) != 0) fail("crypto_kem_keypair returns nonzero");
      checksum(p,plen);
      checksum(s,slen);
      //output_compare(p2,p,plen,"crypto_kem_keypair");
      output_compare(p,p,plen,"crypto_kem_keypair");
      //output_compare(s2,s,slen,"crypto_kem_keypair");
      output_compare(s,s,slen,"crypto_kem_keypair");
      XBD_DEBUG("Keypair successful\n");
 
      //output_prepare(c2,c,clen);
      output_prepare(c,c,clen);
      //output_prepare(k2,k,klen);
      output_prepare(k,k,klen);
      //memcpy(p2,p,plen);
      memcpy(p,p,plen);
      //double_canary(p2,p,plen);
      double_canary(p,p,plen);
      if (crypto_kem_enc(c,k,p) != 0) fail("crypto_kem_enc returns nonzero");
      checksum(c,clen);
      checksum(k,klen);
      //output_compare(c2,c,clen,"crypto_kem_enc");
      output_compare(c,c,clen,"crypto_kem_enc");
      //output_compare(k2,k,klen,"crypto_kem_enc");
      output_compare(k,k,klen,"crypto_kem_enc");
      //input_compare(p2,p,plen,"crypto_kem_enc");
      input_compare(p,p,plen,"crypto_kem_enc");
      XBD_DEBUG("Encapsulation successful\n");

      //output_prepare(t2,t,tlen);
      output_prepare(t,t,tlen);
      //memcpy(c2,c,clen);
      //double_canary(c2,c,clen);
      double_canary(c,c,clen);
      //memcpy(s2,s,slen);
      //double_canary(s2,s,slen);
      double_canary(s,s,slen);
      if (crypto_kem_dec(t,c,s) != 0) fail("crypto_kem_dec returns nonzero");
      if (memcmp(t,k,klen) != 0) fail("crypto_kem_dec does not match k");
/*
      int i=0;
      for(; i < klen && i < tlen; ++i) {
        XBD_DEBUG("Session key compare: "); XBD_DEBUG_32B(i); XBD_DEBUG_CHAR('\n');
        if (t[i] != k[i])
          fail("crypto_kem_dec does not match k");
      }
*/
      checksum(t,tlen);
      //output_compare(t2,t,tlen,"crypto_kem_dec");
      output_compare(t,t,tlen,"crypto_kem_dec");
      //input_compare(c2,c,clen,"crypto_kem_dec");
      input_compare(c,c,clen,"crypto_kem_dec");
      //input_compare(s2,s,slen,"crypto_kem_dec");
      input_compare(s,s,slen,"crypto_kem_dec");
#if 0      
      double_canary(t2,t,tlen);
      double_canary(c2,c,clen);
      double_canary(s2,s,slen);
      if (crypto_kem_dec(t2,c2,s2) != 0) fail("crypto_kem_dec returns nonzero");
      if (memcmp(t2,t,tlen) != 0) fail("crypto_kem_dec is nondeterministic");
      
      double_canary(t2,t,tlen);
      double_canary(c2,c,clen);
      double_canary(s2,s,slen);
      if (crypto_kem_dec(c2,c2,s) != 0) fail("crypto_kem_dec with c=t overlap returns nonzero");
      if (memcmp(c2,t,tlen) != 0) fail("crypto_kem_dec does not handle c=t overlap");
      memcpy(c2,c,clen);
      if (crypto_kem_dec(s2,c,s2) != 0) fail("crypto_kem_dec with s=t overlap returns nonzero");
      if (memcmp(s2,t,tlen) != 0) fail("crypto_kem_dec does not handle s=t overlap");
      memcpy(s2,s,slen);
#endif
    }
    return 0;
  }else{
    return FAIL_CHECKSUM;
  }
}
