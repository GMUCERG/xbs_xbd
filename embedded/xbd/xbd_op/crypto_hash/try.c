/*
 * crypto_hash/try.c version 20140429
 * D. J. Bernstein
 * Public domain.
 * Auto-generated by trygen.py; do not edit.
 */

#include "crypto_hash.h"
#include "XBD_operation.h"
#include "try.h"

const char *primitiveimplementation = crypto_hash_IMPLEMENTATION;

#define SMALL
#define TUNE_BYTES 1536
#ifdef SMALL
#define MAXTEST_BYTES 128
#else
#define MAXTEST_BYTES 4096
#endif
#ifdef SMALL
#define LOOPS 64
#else
#define LOOPS 512
#endif

static unsigned char *h;
static unsigned char *m;
static unsigned char *h2;
static unsigned char *m2;
#define hlen crypto_hash_BYTES
static unsigned long long mlen;

void preallocate(void)
{
}

void test_allocate(unsigned char *buf)
{
  h = buf+CANARY_SZ;
  m = h+crypto_hash_BYTES+CANARY_SZ*2;
  h2 = m+MAXTEST_BYTES+CANARY_SZ*2;
  m2 = h+crypto_hash_BYTES+CANARY_SZ*2;
  //Randomize contents
  for (size_t i = 0; i < MAX_TESTBUFFER_BYTES; i++){
      buf[i]=(unsigned char)(myrandom() & 0xFF);
  }
}

void predoit(void)
{
}

void doit(void)
{
  crypto_hash(h,m,TUNE_BYTES);
}

int test(void)
{
  unsigned loop;
  
  if(!setjmp(test_fail_jmp)){
    for (loop = 0;loop < LOOPS;++loop) {
      mlen = myrandom() % (MAXTEST_BYTES + 1);
      
      output_prepare(h2,h,hlen);
      input_prepare(m2,m,mlen);
      if (crypto_hash(h,m,mlen) != 0) fail("crypto_hash returns nonzero");
      checksum(h,hlen);
      output_compare(h2,h,hlen,"crypto_hash");
      input_compare(m2,m,mlen,"crypto_hash");
      
      double_canary(h2,h,hlen);
      double_canary(m2,m,mlen);
      if (crypto_hash(h2,m2,mlen) != 0) fail("crypto_hash returns nonzero");
      if (memcmp(h2,h,hlen) != 0) fail("crypto_hash is nondeterministic");
      
      double_canary(h2,h,hlen);
      double_canary(m2,m,mlen);
      if (crypto_hash(m2,m2,mlen) != 0) fail("crypto_hash with m=h overlap returns nonzero");
      if (memcmp(m2,h,hlen) != 0) fail("crypto_hash does not handle m=h overlap");
      memcpy(m2,m,mlen);
    }
    return 0;
  }else{
    return FAIL_CHECKSUM;
  }
}
