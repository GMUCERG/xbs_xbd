
XBD_STM32F1.elf:     file format elf32-littlearm

SYMBOL TABLE:
08000000 l    d  .isr_vector	00000000 .isr_vector
0800010c l    d  .text	00000000 .text
08001d5c l    d  .rodata	00000000 .rodata
08001ef0 l    d  .init_array	00000000 .init_array
08001ef8 l    d  .fini_array	00000000 .fini_array
20000000 l    d  .data	00000000 .data
20000438 l    d  data.i2c	00000000 data.i2c
20000478 l    d  .bss	00000000 .bss
20000ad0 l    d  ._user_heap_stack	00000000 ._user_heap_stack
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    df *ABS*	00000000 /tmp/ccCLkGky.o
f108f85f l       *ABS*	00000000 BootRAM
080003b0 l       .text	00000000 LoopCopyDataInit
080003a8 l       .text	00000000 CopyDataInit
080003c4 l       .text	00000000 LoopFillZerobss
080003be l       .text	00000000 FillZerobss
080003ec l       .text	00000000 Infinite_Loop
00000000 l    df *ABS*	00000000 crtstuff.c
08001d44 l     O .text	00000000 __EH_FRAME_BEGIN__
0800010c l     F .text	00000000 deregister_tm_clones
0800012c l     F .text	00000000 register_tm_clones
08000150 l     F .text	00000000 __do_global_dtors_aux
20000478 l       .bss	00000000 completed.6266
08001ef8 l     O .fini_array	00000000 __do_global_dtors_aux_fini_array_entry
08000178 l     F .text	00000000 frame_dummy
2000047c l       .bss	00000000 object.6271
08001ef4 l     O .init_array	00000000 __frame_dummy_init_array_entry
00000000 l    df *ABS*	00000000 _lshrdi3.o
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 fini.c
00000000 l    df *ABS*	00000000 init.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
08000390 l     F .text	00000014 register_fini
00000000 l    df *ABS*	00000000 XBD_BL.c
00000000 l    df *ABS*	00000000 system_stm32f1xx.c
00000000 l    df *ABS*	00000000 stm32f1xx_it.c
00000000 l    df *ABS*	00000000 i2c_comms.c
2000054c l     O .bss	00000004 i2cSlaveTransmit
20000550 l     O .bss	00000004 i2cSlaveReceive
00000000 l    df *ABS*	00000000 stm32f1xx_hal_msp.c
00000000 l    df *ABS*	00000000 XBD_crc.c
00000000 l    df *ABS*	00000000 XBD_HAL.c
20000554 l     O .bss	00000010 GPIO_InitStruct.6186
20000564 l     O .bss	00000010 EraseInitStruct.6205
00000000 l    df *ABS*	00000000 stm32f1xx_hal_rcc.c
00000000 l    df *ABS*	00000000 stm32f1xx_hal.c
20000574 l     O .bss	00000004 uwTick
00000000 l    df *ABS*	00000000 stm32f1xx_hal_cortex.c
00000000 l    df *ABS*	00000000 stm32f1xx_hal_gpio.c
00000000 l    df *ABS*	00000000 stm32f1xx_hal_i2c.c
00000000 l    df *ABS*	00000000 stm32f1xx_nucleo.c
00000000 l    df *ABS*	00000000 stm32f1xx_hal_flash.c
08001a08 l     F .text	0000004c FLASH_SetErrorCode
00000000 l    df *ABS*	00000000 stm32f1xx_hal_flash_ex.c
08001b70 l     F .text	00000024 FLASH_MassErase.isra.0
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 strncmp.c
00000000 l    df *ABS*	00000000 /usr/lib/gcc/arm-none-eabi/4.9.3/armv7-m/crti.o
00000000 l    df *ABS*	00000000 /usr/lib/gcc/arm-none-eabi/4.9.3/armv7-m/crtn.o
00000000 l    df *ABS*	00000000 impure.c
20000000 l     O .data	00000428 impure_data
00000000 l    df *ABS*	00000000 XBD_commands.c
00000000 l    df *ABS*	00000000 
00000000 l       *UND*	00000000 HAL_DMA_Start_IT
08001efc l       .fini_array	00000000 __fini_array_end
20000478 l       .bss	00000000 __bss_start__
20000ad0 l       ._user_heap_stack	00000000 end
20000ad0 l       .bss	00000000 __bss_end__
08001ef8 l       .fini_array	00000000 __fini_array_start
00000000 l       *UND*	00000000 XBD_debugOut
08001ef8 l       .init_array	00000000 __init_array_end
00000000 l       *UND*	00000000 __end__
08001ef0 l       .init_array	00000000 __preinit_array_end
20000ad0 l       ._user_heap_stack	00000000 _end
08001ef0 l       .init_array	00000000 __init_array_start
08001ef0 l       .init_array	00000000 __preinit_array_start
00000000 l       *UND*	00000000 free
080003ec  w    F .text	00000002 RTC_Alarm_IRQHandler
080003ec  w    F .text	00000002 EXTI2_IRQHandler
08001db1 g     O .rodata	00000008 APBPrescTable
080005e4 g     F .text	00000020 XBD_BL_HandleVersionInformationRequest
08000c12 g     F .text	0000000e strcpy
080017dc g     F .text	000000d0 HAL_GPIO_DeInit
0800089c g     F .text	00000002 DebugMon_Handler
08001de9 g     O .rodata	00000009 XBDtro
20000578 g     O .bss	00000002 sw_flash_fbidx
080014cc g     F .text	00000030 HAL_RCC_GetPCLK1Freq
080015c4 g     F .text	00000060 HAL_NVIC_SetPriority
080003ec  w    F .text	00000002 TIM1_CC_IRQHandler
08001a78 g     F .text	00000014 HAL_FLASH_Lock
08000892 g     F .text	00000002 HardFault_Handler
00000400 g       *ABS*	00000000 _Min_Stack_Size
2000057c g     O .bss	00000400 sw_alignedFlashbuffer
080008a0 g     F .text	00000004 SysTick_Handler
08001e67 g     O .rodata	00000009 XBDvir
080018ac g     F .text	00000008 HAL_GPIO_WritePin
080003ec  w    F .text	00000002 PVD_IRQHandler
080001b0 g     F .text	00000018 .hidden __aeabi_llsr
08001efc g       *ABS*	00000000 _sidata
080014c0 g     F .text	0000000c HAL_RCC_GetHCLKFreq
0800089e g     F .text	00000002 PendSV_Handler
08000890 g     F .text	00000002 NMI_Handler
08001ef0 g       .init_array	00000000 __exidx_end
080003ec  w    F .text	00000002 EXTI3_IRQHandler
080012cc g     F .text	00000090 HAL_RCC_GetSysClockFreq
20000498 g     O .bss	000000b4 i2c_buf
08000514 g     F .text	000000d0 XBD_BL_HandleFlashDownloadRequest
080018b4 g     F .text	000000d4 HAL_I2C_Init
08000b08 g     F .text	00000038 HAL_I2C_MspDeInit
08001d78 g     O .rodata	00000029 XBD_Rev
080014fc  w    F .text	00000002 HAL_MspInit
0800090c g     F .text	00000188 i2c_handle
08001d5c g       .text	00000000 _etext
20000478 g       .bss	00000000 _sbss
08000d04 g     F .text	0000000e XBD_readPage
08001650 g     F .text	0000018c HAL_GPIO_Init
08000c00 g     F .text	00000012 memcpy
2000097c g     O .bss	00000002 ctr
08001e0d g     O .rodata	00000009 XBDloo
08000b7c g     F .text	00000020 printf_gdb
20000438 g     O data.i2c	00000000 .hidden __TMC_END__
08001e28 g     O .rodata	00000009 XBDpff
080003ec  w    F .text	00000002 EXTI0_IRQHandler
080003ec  w    F .text	00000002 I2C2_EV_IRQHandler
08001564  w    F .text	0000001a HAL_Delay
2000042c g     O .data	00000004 SystemCoreClock
00000000  w      *UND*	00000000 malloc
20000980 g     O .bss	00000004 sw_flashleng
08000898 g     F .text	00000002 UsageFault_Handler
08000cfc g     F .text	00000004 XBD_serveCommunication
080003ec  w    F .text	00000002 ADC1_2_IRQHandler
08000bdc g     F .text	00000024 print_int_xbd
20000000 g       .data	00000000 _sdata
080003ec  w    F .text	00000002 SPI1_IRQHandler
08001bb8 g     F .text	0000009c HAL_FLASHEx_Erase
0800069c g     F .text	00000154 FRW_msgRecHand
080003ec  w    F .text	00000002 TAMPER_IRQHandler
20000984 g     O .bss	00000004 sw_flashseqn
08000b5e g     F .text	0000001c crc16buffer
08000c20 g     F .text	00000050 SystemClock_Config
20000988 g     O .bss	00000004 sw_flashaddr
08001624 g     F .text	0000002c HAL_SYSTICK_Config
20000ab0 g     O .bss	00000020 pFlash
08001ef0 g       .init_array	00000000 __exidx_start
080007f0 g     F .text	00000048 FRW_msgTraHand
08001d74 g     O .rodata	00000004 _global_impure_ptr
08001e4c g     O .rodata	00000009 XBDtrr
08000200 g     F .text	00000050 __libc_init_array
080003ec  w    F .text	00000002 DMA1_Channel4_IRQHandler
08001988 g     F .text	00000030 HAL_I2C_DeInit
08001d44 g     F .text	00000000 _init
08001590  w    F .text	00000010 HAL_ResumeTick
080003ec  w    F .text	00000002 USART3_IRQHandler
080001d4 g     F .text	0000002c __libc_fini_array
080003ec  w    F .text	00000002 RTC_IRQHandler
20000ad0 g       .bss	00000000 _ebss
080003ec  w    F .text	00000002 DMA1_Channel7_IRQHandler
080003a4  w    F .text	00000034 Reset_Handler
080003ec  w    F .text	00000002 CAN1_RX1_IRQHandler
2000098c g     O .bss	00000002 crc
08001524 g     F .text	00000024 HAL_Init
20000990 g     O .bss	00000004 sw_flashprocessed
08000dac g     F .text	0000000c XBD_switchToApplication
080001b0 g     F .text	00000018 .hidden __lshrdi3
080003ec  w    F .text	00000002 TIM4_IRQHandler
08000900 g     F .text	0000000c i2c_set_tx
00000000  w      *UND*	00000000 __deregister_frame_info
08001ae0 g     F .text	00000090 HAL_FLASH_Program
080003ec  w    F .text	00000002 I2C1_EV_IRQHandler
00000000  w      *UND*	00000000 _ITM_registerTMCloneTable
080003ec  w    F .text	00000002 DMA1_Channel6_IRQHandler
080003ec  w    F .text	00000002 TIM3_IRQHandler
080003ec  w    F .text	00000002 RCC_IRQHandler
080003ec  w    F .text	00000002 TIM1_TRG_COM_IRQHandler
00000200 g       *ABS*	00000000 _Min_Heap_Size
080003ec  w    F .text	00000002 DMA1_Channel1_IRQHandler
080003ec g       .text	00000002 Default_Handler
08001b94 g     F .text	00000024 FLASH_PageErase
08001da1 g     O .rodata	00000010 AHBPrescTable
08001580  w    F .text	00000010 HAL_SuspendTick
08001a8c g     F .text	00000054 FLASH_WaitForLastOperation
08001e5e g     O .rodata	00000009 XBDcrc
080003ec  w    F .text	00000002 EXTI15_10_IRQHandler
080002ec g     F .text	000000a4 __register_exitproc
08001cb0 g     F .text	00000092 strncmp
20000494 g     O .bss	00000001 xbd_state
0800135c g     F .text	00000164 HAL_RCC_ClockConfig
08001e55 g     O .rodata	00000009 XBDblo
080015a0 g     F .text	00000024 HAL_NVIC_SetPriorityGrouping
08000644 g     F .text	00000058 XBD_BL_HandleTargetRevisionRequest
08000d00 g     F .text	00000004 XBD_loadStringFromConstDataArea
08001e16 g     O .rodata	00000009 XBDsar
08000604 g     F .text	00000040 XBD_BL_HandleTimingCalibrationRequest
080003ec  w    F .text	00000002 EXTI9_5_IRQHandler
080003f0 g     F .text	00000038 XBD_BL_DisregardBlock
20000994 g     O .bss	00000002 rx_crc
08001558  w    F .text	0000000c HAL_GetTick
00000000  w      *UND*	00000000 _ITM_deregisterTMCloneTable
08000b9c g     F .text	00000020 print_int_gdb
080003ec  w    F .text	00000002 SPI2_IRQHandler
20000428 g     O .data	00000004 sw_flashbuffer
08000250 g     F .text	0000009a memset
08000894 g     F .text	00000002 MemManage_Handler
08000838 g     F .text	0000000c main
0800089a g     F .text	00000002 SVC_Handler
08000db8 g     F .text	00000054 XBD_busyLoopWithTiming
20000998 g     O .bss	00000100 XBD_response
00000000  w      *UND*	00000000 __libc_fini
080003ec  w    F .text	00000002 DMA1_Channel5_IRQHandler
080003ec  w    F .text	00000002 EXTI4_IRQHandler
20000434 g     O .data	00000004 LED_PORT
20000aa4 g     O .bss	00000004 print_ptr
080003ec  w    F .text	00000002 USB_LP_CAN1_RX0_IRQHandler
08000468 g     F .text	000000ac XBD_BL_HandleProgramFlashRequest
08000844 g     F .text	0000004c SystemInit
08001df2 g     O .rodata	00000009 XBDlor
08001dfb g     O .rodata	00000009 XBDpfo
08001d50 g     F .text	00000000 _fini
080003ec  w    F .text	00000002 USB_HP_CAN1_TX_IRQHandler
080001c8 g     F .text	0000000c atexit
20000496 g     O .bss	00000002 i2c_size_read
080003ec  w    F .text	00000002 DMA1_Channel3_IRQHandler
080014fe  w    F .text	00000024 HAL_InitTick
080003ec  w    F .text	00000002 TIM1_UP_IRQHandler
08001548  w    F .text	00000010 HAL_IncTick
20000aa8 g     O .bss	00000004 integer_print
080008a4 g     F .text	00000050 i2c_init
20000a98 g     O .bss	00000009 buf
080003ec  w    F .text	00000002 WWDG_IRQHandler
08000a94 g     F .text	00000074 HAL_I2C_MspInit
20000430 g     O .data	00000004 i2c_ptr
080003ec  w    F .text	00000002 TIM2_IRQHandler
080008f4 g     F .text	0000000c i2c_set_rx
080003ec  w    F .text	00000002 TIM1_BRK_IRQHandler
20004fff g       *ABS*	00000000 _estack
080003ec  w    F .text	00000002 EXTI1_IRQHandler
20000438 g       .data	00000000 _edata
08001e31 g     O .rodata	00000009 XBDpfr
08001a54 g     F .text	00000024 HAL_FLASH_Unlock
080003ec  w    F .text	00000002 USART2_IRQHandler
08000e0c g     F .text	000004c0 HAL_RCC_OscConfig
08000c70 g     F .text	0000008c XBD_init
08000bbc g     F .text	00000020 printf_xbd
08000000 g     O .isr_vector	00000000 g_pfnVectors
080003ec  w    F .text	00000002 I2C2_ER_IRQHandler
080003ec  w    F .text	00000002 DMA1_Channel2_IRQHandler
080019b8 g     F .text	00000050 BSP_LED_Init
08001e43 g     O .rodata	00000009 XBDtcr
08000d8c g     F .text	00000010 XBD_sendExecutionStartSignal
08000d9c g     F .text	00000010 XBD_sendExecutionCompleteSignal
080003ec  w    F .text	00000002 CAN1_SCE_IRQHandler
08000b40 g     F .text	0000001e crc16_update
080003ec  w    F .text	00000002 FLASH_IRQHandler
08001e04 g     O .rodata	00000009 XBDunk
08000896 g     F .text	00000002 BusFault_Handler
080003ec  w    F .text	00000002 USART1_IRQHandler
20000aa1 g     O .bss	00000001 realTXlen
08001c54 g     F .text	0000005c strlen
08001e3a g     O .rodata	00000009 XBDtco
080003ec  w    F .text	00000002 I2C1_ER_IRQHandler
08000428 g     F .text	00000040 XBD_BL_HandleLOopbackRequest
20000438 g     O data.i2c	0000003c I2cHandle
00000000  w      *UND*	00000000 _Jv_RegisterClasses
08001e1f g     O .rodata	00000009 XBDfdr
00000000  w      *UND*	00000000 __register_frame_info
080003ec  w    F .text	00000002 USBWakeUp_IRQHandler
08000d14 g     F .text	00000078 XBD_programPage



Disassembly of section .text:

0800010c <deregister_tm_clones>:
 800010c:	4b04      	ldr	r3, [pc, #16]	; (8000120 <deregister_tm_clones+0x14>)
 800010e:	4805      	ldr	r0, [pc, #20]	; (8000124 <deregister_tm_clones+0x18>)
 8000110:	1a1b      	subs	r3, r3, r0
 8000112:	2b06      	cmp	r3, #6
 8000114:	d902      	bls.n	800011c <deregister_tm_clones+0x10>
 8000116:	4b04      	ldr	r3, [pc, #16]	; (8000128 <deregister_tm_clones+0x1c>)
 8000118:	b103      	cbz	r3, 800011c <deregister_tm_clones+0x10>
 800011a:	4718      	bx	r3
 800011c:	4770      	bx	lr
 800011e:	bf00      	nop
 8000120:	2000043b 	.word	0x2000043b
 8000124:	20000438 	.word	0x20000438
 8000128:	00000000 	.word	0x00000000

0800012c <register_tm_clones>:
 800012c:	4905      	ldr	r1, [pc, #20]	; (8000144 <register_tm_clones+0x18>)
 800012e:	4806      	ldr	r0, [pc, #24]	; (8000148 <register_tm_clones+0x1c>)
 8000130:	1a09      	subs	r1, r1, r0
 8000132:	1089      	asrs	r1, r1, #2
 8000134:	eb01 71d1 	add.w	r1, r1, r1, lsr #31
 8000138:	1049      	asrs	r1, r1, #1
 800013a:	d002      	beq.n	8000142 <register_tm_clones+0x16>
 800013c:	4b03      	ldr	r3, [pc, #12]	; (800014c <register_tm_clones+0x20>)
 800013e:	b103      	cbz	r3, 8000142 <register_tm_clones+0x16>
 8000140:	4718      	bx	r3
 8000142:	4770      	bx	lr
 8000144:	20000438 	.word	0x20000438
 8000148:	20000438 	.word	0x20000438
 800014c:	00000000 	.word	0x00000000

08000150 <__do_global_dtors_aux>:
 8000150:	b510      	push	{r4, lr}
 8000152:	4c06      	ldr	r4, [pc, #24]	; (800016c <__do_global_dtors_aux+0x1c>)
 8000154:	7823      	ldrb	r3, [r4, #0]
 8000156:	b943      	cbnz	r3, 800016a <__do_global_dtors_aux+0x1a>
 8000158:	f7ff ffd8 	bl	800010c <deregister_tm_clones>
 800015c:	4b04      	ldr	r3, [pc, #16]	; (8000170 <__do_global_dtors_aux+0x20>)
 800015e:	b113      	cbz	r3, 8000166 <__do_global_dtors_aux+0x16>
 8000160:	4804      	ldr	r0, [pc, #16]	; (8000174 <__do_global_dtors_aux+0x24>)
 8000162:	f3af 8000 	nop.w
 8000166:	2301      	movs	r3, #1
 8000168:	7023      	strb	r3, [r4, #0]
 800016a:	bd10      	pop	{r4, pc}
 800016c:	20000478 	.word	0x20000478
 8000170:	00000000 	.word	0x00000000
 8000174:	08001d44 	.word	0x08001d44

08000178 <frame_dummy>:
 8000178:	b508      	push	{r3, lr}
 800017a:	4b08      	ldr	r3, [pc, #32]	; (800019c <frame_dummy+0x24>)
 800017c:	b11b      	cbz	r3, 8000186 <frame_dummy+0xe>
 800017e:	4808      	ldr	r0, [pc, #32]	; (80001a0 <frame_dummy+0x28>)
 8000180:	4908      	ldr	r1, [pc, #32]	; (80001a4 <frame_dummy+0x2c>)
 8000182:	f3af 8000 	nop.w
 8000186:	4808      	ldr	r0, [pc, #32]	; (80001a8 <frame_dummy+0x30>)
 8000188:	6803      	ldr	r3, [r0, #0]
 800018a:	b913      	cbnz	r3, 8000192 <frame_dummy+0x1a>
 800018c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 8000190:	e7cc      	b.n	800012c <register_tm_clones>
 8000192:	4b06      	ldr	r3, [pc, #24]	; (80001ac <frame_dummy+0x34>)
 8000194:	2b00      	cmp	r3, #0
 8000196:	d0f9      	beq.n	800018c <frame_dummy+0x14>
 8000198:	4798      	blx	r3
 800019a:	e7f7      	b.n	800018c <frame_dummy+0x14>
 800019c:	00000000 	.word	0x00000000
 80001a0:	08001d44 	.word	0x08001d44
 80001a4:	2000047c 	.word	0x2000047c
 80001a8:	20000438 	.word	0x20000438
 80001ac:	00000000 	.word	0x00000000

080001b0 <__aeabi_llsr>:
 80001b0:	40d0      	lsrs	r0, r2
 80001b2:	1c0b      	adds	r3, r1, #0
 80001b4:	40d1      	lsrs	r1, r2
 80001b6:	469c      	mov	ip, r3
 80001b8:	3a20      	subs	r2, #32
 80001ba:	40d3      	lsrs	r3, r2
 80001bc:	4318      	orrs	r0, r3
 80001be:	4252      	negs	r2, r2
 80001c0:	4663      	mov	r3, ip
 80001c2:	4093      	lsls	r3, r2
 80001c4:	4318      	orrs	r0, r3
 80001c6:	4770      	bx	lr

080001c8 <atexit>:
 80001c8:	4601      	mov	r1, r0
 80001ca:	2000      	movs	r0, #0
 80001cc:	4602      	mov	r2, r0
 80001ce:	4603      	mov	r3, r0
 80001d0:	f000 b88c 	b.w	80002ec <__register_exitproc>

080001d4 <__libc_fini_array>:
 80001d4:	b538      	push	{r3, r4, r5, lr}
 80001d6:	4b08      	ldr	r3, [pc, #32]	; (80001f8 <__libc_fini_array+0x24>)
 80001d8:	4d08      	ldr	r5, [pc, #32]	; (80001fc <__libc_fini_array+0x28>)
 80001da:	1aed      	subs	r5, r5, r3
 80001dc:	10ac      	asrs	r4, r5, #2
 80001de:	bf18      	it	ne
 80001e0:	18ed      	addne	r5, r5, r3
 80001e2:	d005      	beq.n	80001f0 <__libc_fini_array+0x1c>
 80001e4:	3c01      	subs	r4, #1
 80001e6:	f855 3d04 	ldr.w	r3, [r5, #-4]!
 80001ea:	4798      	blx	r3
 80001ec:	2c00      	cmp	r4, #0
 80001ee:	d1f9      	bne.n	80001e4 <__libc_fini_array+0x10>
 80001f0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 80001f4:	f001 bdac 	b.w	8001d50 <_fini>
 80001f8:	08001ef8 	.word	0x08001ef8
 80001fc:	08001efc 	.word	0x08001efc

08000200 <__libc_init_array>:
 8000200:	b570      	push	{r4, r5, r6, lr}
 8000202:	4e0f      	ldr	r6, [pc, #60]	; (8000240 <__libc_init_array+0x40>)
 8000204:	4d0f      	ldr	r5, [pc, #60]	; (8000244 <__libc_init_array+0x44>)
 8000206:	1b76      	subs	r6, r6, r5
 8000208:	10b6      	asrs	r6, r6, #2
 800020a:	bf18      	it	ne
 800020c:	2400      	movne	r4, #0
 800020e:	d005      	beq.n	800021c <__libc_init_array+0x1c>
 8000210:	3401      	adds	r4, #1
 8000212:	f855 3b04 	ldr.w	r3, [r5], #4
 8000216:	4798      	blx	r3
 8000218:	42a6      	cmp	r6, r4
 800021a:	d1f9      	bne.n	8000210 <__libc_init_array+0x10>
 800021c:	4e0a      	ldr	r6, [pc, #40]	; (8000248 <__libc_init_array+0x48>)
 800021e:	4d0b      	ldr	r5, [pc, #44]	; (800024c <__libc_init_array+0x4c>)
 8000220:	f001 fd90 	bl	8001d44 <_init>
 8000224:	1b76      	subs	r6, r6, r5
 8000226:	10b6      	asrs	r6, r6, #2
 8000228:	bf18      	it	ne
 800022a:	2400      	movne	r4, #0
 800022c:	d006      	beq.n	800023c <__libc_init_array+0x3c>
 800022e:	3401      	adds	r4, #1
 8000230:	f855 3b04 	ldr.w	r3, [r5], #4
 8000234:	4798      	blx	r3
 8000236:	42a6      	cmp	r6, r4
 8000238:	d1f9      	bne.n	800022e <__libc_init_array+0x2e>
 800023a:	bd70      	pop	{r4, r5, r6, pc}
 800023c:	bd70      	pop	{r4, r5, r6, pc}
 800023e:	bf00      	nop
 8000240:	08001ef0 	.word	0x08001ef0
 8000244:	08001ef0 	.word	0x08001ef0
 8000248:	08001ef8 	.word	0x08001ef8
 800024c:	08001ef0 	.word	0x08001ef0

08000250 <memset>:
 8000250:	b470      	push	{r4, r5, r6}
 8000252:	0784      	lsls	r4, r0, #30
 8000254:	d046      	beq.n	80002e4 <memset+0x94>
 8000256:	1e54      	subs	r4, r2, #1
 8000258:	2a00      	cmp	r2, #0
 800025a:	d041      	beq.n	80002e0 <memset+0x90>
 800025c:	b2cd      	uxtb	r5, r1
 800025e:	4603      	mov	r3, r0
 8000260:	e002      	b.n	8000268 <memset+0x18>
 8000262:	1e62      	subs	r2, r4, #1
 8000264:	b3e4      	cbz	r4, 80002e0 <memset+0x90>
 8000266:	4614      	mov	r4, r2
 8000268:	f803 5b01 	strb.w	r5, [r3], #1
 800026c:	079a      	lsls	r2, r3, #30
 800026e:	d1f8      	bne.n	8000262 <memset+0x12>
 8000270:	2c03      	cmp	r4, #3
 8000272:	d92e      	bls.n	80002d2 <memset+0x82>
 8000274:	b2cd      	uxtb	r5, r1
 8000276:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
 800027a:	2c0f      	cmp	r4, #15
 800027c:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
 8000280:	d919      	bls.n	80002b6 <memset+0x66>
 8000282:	4626      	mov	r6, r4
 8000284:	f103 0210 	add.w	r2, r3, #16
 8000288:	3e10      	subs	r6, #16
 800028a:	2e0f      	cmp	r6, #15
 800028c:	f842 5c10 	str.w	r5, [r2, #-16]
 8000290:	f842 5c0c 	str.w	r5, [r2, #-12]
 8000294:	f842 5c08 	str.w	r5, [r2, #-8]
 8000298:	f842 5c04 	str.w	r5, [r2, #-4]
 800029c:	f102 0210 	add.w	r2, r2, #16
 80002a0:	d8f2      	bhi.n	8000288 <memset+0x38>
 80002a2:	f1a4 0210 	sub.w	r2, r4, #16
 80002a6:	f022 020f 	bic.w	r2, r2, #15
 80002aa:	f004 040f 	and.w	r4, r4, #15
 80002ae:	3210      	adds	r2, #16
 80002b0:	2c03      	cmp	r4, #3
 80002b2:	4413      	add	r3, r2
 80002b4:	d90d      	bls.n	80002d2 <memset+0x82>
 80002b6:	461e      	mov	r6, r3
 80002b8:	4622      	mov	r2, r4
 80002ba:	3a04      	subs	r2, #4
 80002bc:	2a03      	cmp	r2, #3
 80002be:	f846 5b04 	str.w	r5, [r6], #4
 80002c2:	d8fa      	bhi.n	80002ba <memset+0x6a>
 80002c4:	1f22      	subs	r2, r4, #4
 80002c6:	f022 0203 	bic.w	r2, r2, #3
 80002ca:	3204      	adds	r2, #4
 80002cc:	4413      	add	r3, r2
 80002ce:	f004 0403 	and.w	r4, r4, #3
 80002d2:	b12c      	cbz	r4, 80002e0 <memset+0x90>
 80002d4:	b2c9      	uxtb	r1, r1
 80002d6:	441c      	add	r4, r3
 80002d8:	f803 1b01 	strb.w	r1, [r3], #1
 80002dc:	42a3      	cmp	r3, r4
 80002de:	d1fb      	bne.n	80002d8 <memset+0x88>
 80002e0:	bc70      	pop	{r4, r5, r6}
 80002e2:	4770      	bx	lr
 80002e4:	4614      	mov	r4, r2
 80002e6:	4603      	mov	r3, r0
 80002e8:	e7c2      	b.n	8000270 <memset+0x20>
 80002ea:	bf00      	nop

080002ec <__register_exitproc>:
 80002ec:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80002f0:	4c25      	ldr	r4, [pc, #148]	; (8000388 <__register_exitproc+0x9c>)
 80002f2:	4606      	mov	r6, r0
 80002f4:	6825      	ldr	r5, [r4, #0]
 80002f6:	4688      	mov	r8, r1
 80002f8:	f8d5 4148 	ldr.w	r4, [r5, #328]	; 0x148
 80002fc:	4692      	mov	sl, r2
 80002fe:	4699      	mov	r9, r3
 8000300:	b3c4      	cbz	r4, 8000374 <__register_exitproc+0x88>
 8000302:	6860      	ldr	r0, [r4, #4]
 8000304:	281f      	cmp	r0, #31
 8000306:	dc17      	bgt.n	8000338 <__register_exitproc+0x4c>
 8000308:	1c41      	adds	r1, r0, #1
 800030a:	b176      	cbz	r6, 800032a <__register_exitproc+0x3e>
 800030c:	eb04 0380 	add.w	r3, r4, r0, lsl #2
 8000310:	f8c3 a088 	str.w	sl, [r3, #136]	; 0x88
 8000314:	f8d4 5188 	ldr.w	r5, [r4, #392]	; 0x188
 8000318:	2201      	movs	r2, #1
 800031a:	4082      	lsls	r2, r0
 800031c:	4315      	orrs	r5, r2
 800031e:	2e02      	cmp	r6, #2
 8000320:	f8c4 5188 	str.w	r5, [r4, #392]	; 0x188
 8000324:	f8c3 9108 	str.w	r9, [r3, #264]	; 0x108
 8000328:	d01e      	beq.n	8000368 <__register_exitproc+0x7c>
 800032a:	1c83      	adds	r3, r0, #2
 800032c:	6061      	str	r1, [r4, #4]
 800032e:	2000      	movs	r0, #0
 8000330:	f844 8023 	str.w	r8, [r4, r3, lsl #2]
 8000334:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000338:	4b14      	ldr	r3, [pc, #80]	; (800038c <__register_exitproc+0xa0>)
 800033a:	b303      	cbz	r3, 800037e <__register_exitproc+0x92>
 800033c:	f44f 70c8 	mov.w	r0, #400	; 0x190
 8000340:	f3af 8000 	nop.w
 8000344:	4604      	mov	r4, r0
 8000346:	b1d0      	cbz	r0, 800037e <__register_exitproc+0x92>
 8000348:	f8d5 3148 	ldr.w	r3, [r5, #328]	; 0x148
 800034c:	2700      	movs	r7, #0
 800034e:	e884 0088 	stmia.w	r4, {r3, r7}
 8000352:	4638      	mov	r0, r7
 8000354:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
 8000358:	2101      	movs	r1, #1
 800035a:	f8c4 7188 	str.w	r7, [r4, #392]	; 0x188
 800035e:	f8c4 718c 	str.w	r7, [r4, #396]	; 0x18c
 8000362:	2e00      	cmp	r6, #0
 8000364:	d0e1      	beq.n	800032a <__register_exitproc+0x3e>
 8000366:	e7d1      	b.n	800030c <__register_exitproc+0x20>
 8000368:	f8d4 318c 	ldr.w	r3, [r4, #396]	; 0x18c
 800036c:	431a      	orrs	r2, r3
 800036e:	f8c4 218c 	str.w	r2, [r4, #396]	; 0x18c
 8000372:	e7da      	b.n	800032a <__register_exitproc+0x3e>
 8000374:	f505 74a6 	add.w	r4, r5, #332	; 0x14c
 8000378:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
 800037c:	e7c1      	b.n	8000302 <__register_exitproc+0x16>
 800037e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8000382:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000386:	bf00      	nop
 8000388:	08001d74 	.word	0x08001d74
 800038c:	00000000 	.word	0x00000000

08000390 <register_fini>:
 8000390:	4b02      	ldr	r3, [pc, #8]	; (800039c <register_fini+0xc>)
 8000392:	b113      	cbz	r3, 800039a <register_fini+0xa>
 8000394:	4802      	ldr	r0, [pc, #8]	; (80003a0 <register_fini+0x10>)
 8000396:	f7ff bf17 	b.w	80001c8 <atexit>
 800039a:	4770      	bx	lr
 800039c:	00000000 	.word	0x00000000
 80003a0:	080001d5 	.word	0x080001d5

080003a4 <Reset_Handler>:
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:

/* Copy the data segment initializers from flash to SRAM */
  movs r1, #0
 80003a4:	2100      	movs	r1, #0
  b LoopCopyDataInit
 80003a6:	e003      	b.n	80003b0 <LoopCopyDataInit>

080003a8 <CopyDataInit>:

CopyDataInit:
  ldr r3, =_sidata
 80003a8:	4b0b      	ldr	r3, [pc, #44]	; (80003d8 <LoopFillZerobss+0x14>)
  ldr r3, [r3, r1]
 80003aa:	585b      	ldr	r3, [r3, r1]
  str r3, [r0, r1]
 80003ac:	5043      	str	r3, [r0, r1]
  adds r1, r1, #4
 80003ae:	3104      	adds	r1, #4

080003b0 <LoopCopyDataInit>:

LoopCopyDataInit:
  ldr r0, =_sdata
 80003b0:	480a      	ldr	r0, [pc, #40]	; (80003dc <LoopFillZerobss+0x18>)
  ldr r3, =_edata
 80003b2:	4b0b      	ldr	r3, [pc, #44]	; (80003e0 <LoopFillZerobss+0x1c>)
  adds r2, r0, r1
 80003b4:	1842      	adds	r2, r0, r1
  cmp r2, r3
 80003b6:	429a      	cmp	r2, r3
  bcc CopyDataInit
 80003b8:	d3f6      	bcc.n	80003a8 <CopyDataInit>
  ldr r2, =_sbss
 80003ba:	4a0a      	ldr	r2, [pc, #40]	; (80003e4 <LoopFillZerobss+0x20>)
  b LoopFillZerobss
 80003bc:	e002      	b.n	80003c4 <LoopFillZerobss>

080003be <FillZerobss>:
/* Zero fill the bss segment. */
FillZerobss:
  movs r3, #0
 80003be:	2300      	movs	r3, #0
  str r3, [r2], #4
 80003c0:	f842 3b04 	str.w	r3, [r2], #4

080003c4 <LoopFillZerobss>:

LoopFillZerobss:
  ldr r3, = _ebss
 80003c4:	4b08      	ldr	r3, [pc, #32]	; (80003e8 <LoopFillZerobss+0x24>)
  cmp r2, r3
 80003c6:	429a      	cmp	r2, r3
  bcc FillZerobss
 80003c8:	d3f9      	bcc.n	80003be <FillZerobss>

/* Call the clock system intitialization function.*/
    bl  SystemInit
 80003ca:	f000 fa3b 	bl	8000844 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 80003ce:	f7ff ff17 	bl	8000200 <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 80003d2:	f000 fa31 	bl	8000838 <main>
  bx lr
 80003d6:	4770      	bx	lr
/* Copy the data segment initializers from flash to SRAM */
  movs r1, #0
  b LoopCopyDataInit

CopyDataInit:
  ldr r3, =_sidata
 80003d8:	08001efc 	.word	0x08001efc
  ldr r3, [r3, r1]
  str r3, [r0, r1]
  adds r1, r1, #4

LoopCopyDataInit:
  ldr r0, =_sdata
 80003dc:	20000000 	.word	0x20000000
  ldr r3, =_edata
 80003e0:	20000438 	.word	0x20000438
  adds r2, r0, r1
  cmp r2, r3
  bcc CopyDataInit
  ldr r2, =_sbss
 80003e4:	20000478 	.word	0x20000478
FillZerobss:
  movs r3, #0
  str r3, [r2], #4

LoopFillZerobss:
  ldr r3, = _ebss
 80003e8:	20000ad0 	.word	0x20000ad0

080003ec <ADC1_2_IRQHandler>:
 * @retval : None
*/
    .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 80003ec:	e7fe      	b.n	80003ec <ADC1_2_IRQHandler>
	...

080003f0 <XBD_BL_DisregardBlock>:
uint8_t buf[8+1];
uint16_t ctr, crc, rx_crc;

uint8_t realTXlen;

void XBD_BL_DisregardBlock(uint8_t len, uint8_t *data) {
 80003f0:	b510      	push	{r4, lr}
	//disregard block
	XBD_loadStringFromConstDataArea((char *)XBD_response, XBDcrc);
 80003f2:	4909      	ldr	r1, [pc, #36]	; (8000418 <XBD_BL_DisregardBlock+0x28>)
uint8_t buf[8+1];
uint16_t ctr, crc, rx_crc;

uint8_t realTXlen;

void XBD_BL_DisregardBlock(uint8_t len, uint8_t *data) {
 80003f4:	4604      	mov	r4, r0
	//disregard block
	XBD_loadStringFromConstDataArea((char *)XBD_response, XBDcrc);
 80003f6:	4809      	ldr	r0, [pc, #36]	; (800041c <XBD_BL_DisregardBlock+0x2c>)
 80003f8:	f000 fc82 	bl	8000d00 <XBD_loadStringFromConstDataArea>
	realTXlen=XBD_COMMAND_LEN+CRC16SIZE;
 80003fc:	4b08      	ldr	r3, [pc, #32]	; (8000420 <XBD_BL_DisregardBlock+0x30>)
 80003fe:	220a      	movs	r2, #10
 8000400:	701a      	strb	r2, [r3, #0]

	XBD_DEBUG((char *)XBD_response);
	XBD_DEBUG(" :");
	for (ctr = 0; ctr < len - CRC16SIZE; ++ctr) {
 8000402:	2300      	movs	r3, #0
 8000404:	1ea1      	subs	r1, r4, #2
 8000406:	1c5a      	adds	r2, r3, #1
 8000408:	428b      	cmp	r3, r1
 800040a:	b292      	uxth	r2, r2
 800040c:	da01      	bge.n	8000412 <XBD_BL_DisregardBlock+0x22>
 800040e:	4613      	mov	r3, r2
 8000410:	e7f8      	b.n	8000404 <XBD_BL_DisregardBlock+0x14>
 8000412:	4a04      	ldr	r2, [pc, #16]	; (8000424 <XBD_BL_DisregardBlock+0x34>)
 8000414:	8013      	strh	r3, [r2, #0]
 8000416:	bd10      	pop	{r4, pc}
 8000418:	08001e5e 	.word	0x08001e5e
 800041c:	20000998 	.word	0x20000998
 8000420:	20000aa1 	.word	0x20000aa1
 8000424:	2000097c 	.word	0x2000097c

08000428 <XBD_BL_HandleLOopbackRequest>:
	XBD_DEBUG_BYTE(rx_crc >> 8); XBD_DEBUG_BYTE(rx_crc & 0xff);
	XBD_DEBUG("\n---------------------\n");
	return;
}

void XBD_BL_HandleLOopbackRequest(uint8_t len, uint8_t *data) {
 8000428:	b510      	push	{r4, lr}
 800042a:	4604      	mov	r4, r0
 800042c:	480a      	ldr	r0, [pc, #40]	; (8000458 <XBD_BL_HandleLOopbackRequest+0x30>)
 800042e:	3107      	adds	r1, #7
	uint16_t cnt;

	for(cnt=XBD_COMMAND_LEN;cnt<len;++cnt)
 8000430:	2308      	movs	r3, #8
 8000432:	42a3      	cmp	r3, r4
 8000434:	d207      	bcs.n	8000446 <XBD_BL_HandleLOopbackRequest+0x1e>
	{
		XBD_response[cnt]=data[cnt]+1;	
 8000436:	f811 2f01 	ldrb.w	r2, [r1, #1]!
}

void XBD_BL_HandleLOopbackRequest(uint8_t len, uint8_t *data) {
	uint16_t cnt;

	for(cnt=XBD_COMMAND_LEN;cnt<len;++cnt)
 800043a:	3301      	adds	r3, #1
	{
		XBD_response[cnt]=data[cnt]+1;	
 800043c:	3201      	adds	r2, #1
 800043e:	f800 2f01 	strb.w	r2, [r0, #1]!
}

void XBD_BL_HandleLOopbackRequest(uint8_t len, uint8_t *data) {
	uint16_t cnt;

	for(cnt=XBD_COMMAND_LEN;cnt<len;++cnt)
 8000442:	b29b      	uxth	r3, r3
 8000444:	e7f5      	b.n	8000432 <XBD_BL_HandleLOopbackRequest+0xa>
	{
		XBD_response[cnt]=data[cnt]+1;	
	}
	XBD_loadStringFromConstDataArea((char *)XBD_response, XBDloo);
 8000446:	4805      	ldr	r0, [pc, #20]	; (800045c <XBD_BL_HandleLOopbackRequest+0x34>)
 8000448:	4905      	ldr	r1, [pc, #20]	; (8000460 <XBD_BL_HandleLOopbackRequest+0x38>)
 800044a:	f000 fc59 	bl	8000d00 <XBD_loadStringFromConstDataArea>
	realTXlen=len+CRC16SIZE;
 800044e:	4b05      	ldr	r3, [pc, #20]	; (8000464 <XBD_BL_HandleLOopbackRequest+0x3c>)
 8000450:	3402      	adds	r4, #2
 8000452:	701c      	strb	r4, [r3, #0]
 8000454:	bd10      	pop	{r4, pc}
 8000456:	bf00      	nop
 8000458:	2000099f 	.word	0x2000099f
 800045c:	20000998 	.word	0x20000998
 8000460:	08001e0d 	.word	0x08001e0d
 8000464:	20000aa1 	.word	0x20000aa1

08000468 <XBD_BL_HandleProgramFlashRequest>:
	return;
}

void XBD_BL_HandleProgramFlashRequest(uint8_t len, uint8_t *data) {
	sw_flashaddr = NTOHL(*((uint32_t*) (data + XBD_COMMAND_LEN)));
	sw_flashleng = NTOHL(*((uint32_t*) (data + XBD_COMMAND_LEN + ADDRSIZE)));
 8000468:	68cb      	ldr	r3, [r1, #12]
 800046a:	4a1c      	ldr	r2, [pc, #112]	; (80004dc <XBD_BL_HandleProgramFlashRequest+0x74>)
 800046c:	ba1b      	rev	r3, r3
	realTXlen=len+CRC16SIZE;
	return;
}

void XBD_BL_HandleProgramFlashRequest(uint8_t len, uint8_t *data) {
	sw_flashaddr = NTOHL(*((uint32_t*) (data + XBD_COMMAND_LEN)));
 800046e:	6888      	ldr	r0, [r1, #8]
	XBD_loadStringFromConstDataArea((char *)XBD_response, XBDloo);
	realTXlen=len+CRC16SIZE;
	return;
}

void XBD_BL_HandleProgramFlashRequest(uint8_t len, uint8_t *data) {
 8000470:	b510      	push	{r4, lr}
	sw_flashaddr = NTOHL(*((uint32_t*) (data + XBD_COMMAND_LEN)));
	sw_flashleng = NTOHL(*((uint32_t*) (data + XBD_COMMAND_LEN + ADDRSIZE)));
 8000472:	6013      	str	r3, [r2, #0]

	if ((sw_flashaddr <= (FLASH_ADDR_MAX - sw_flashleng)) //start addr low enough
 8000474:	f1c3 6200 	rsb	r2, r3, #134217728	; 0x8000000
	realTXlen=len+CRC16SIZE;
	return;
}

void XBD_BL_HandleProgramFlashRequest(uint8_t len, uint8_t *data) {
	sw_flashaddr = NTOHL(*((uint32_t*) (data + XBD_COMMAND_LEN)));
 8000478:	ba00      	rev	r0, r0
 800047a:	4c19      	ldr	r4, [pc, #100]	; (80004e0 <XBD_BL_HandleProgramFlashRequest+0x78>)
	sw_flashleng = NTOHL(*((uint32_t*) (data + XBD_COMMAND_LEN + ADDRSIZE)));

	if ((sw_flashaddr <= (FLASH_ADDR_MAX - sw_flashleng)) //start addr low enough
 800047c:	f502 3200 	add.w	r2, r2, #131072	; 0x20000
 8000480:	4290      	cmp	r0, r2
	realTXlen=len+CRC16SIZE;
	return;
}

void XBD_BL_HandleProgramFlashRequest(uint8_t len, uint8_t *data) {
	sw_flashaddr = NTOHL(*((uint32_t*) (data + XBD_COMMAND_LEN)));
 8000482:	6020      	str	r0, [r4, #0]
	sw_flashleng = NTOHL(*((uint32_t*) (data + XBD_COMMAND_LEN + ADDRSIZE)));

	if ((sw_flashaddr <= (FLASH_ADDR_MAX - sw_flashleng)) //start addr low enough
 8000484:	d81d      	bhi.n	80004c2 <XBD_BL_HandleProgramFlashRequest+0x5a>
			&& (sw_flashaddr >= FLASH_ADDR_MIN )
 8000486:	4a17      	ldr	r2, [pc, #92]	; (80004e4 <XBD_BL_HandleProgramFlashRequest+0x7c>)
 8000488:	4290      	cmp	r0, r2
 800048a:	d91a      	bls.n	80004c2 <XBD_BL_HandleProgramFlashRequest+0x5a>
			&& (sw_flashleng <= FLASH_ADDR_MAX) //length small enough
 800048c:	4a16      	ldr	r2, [pc, #88]	; (80004e8 <XBD_BL_HandleProgramFlashRequest+0x80>)
 800048e:	4293      	cmp	r3, r2
 8000490:	d817      	bhi.n	80004c2 <XBD_BL_HandleProgramFlashRequest+0x5a>
		//put flash programming call here
//		XBD_DEBUG("Rec'd correct request to flash:");
//		XBD_DEBUG("\nADDR="), XBD_DEBUG_32B(sw_flashaddr);
//		XBD_DEBUG("\nLENG="), XBD_DEBUG_32B(sw_flashleng);

		XBD_readPage((sw_flashaddr & PAGE_ALIGN_MASK), sw_flashbuffer);
 8000492:	4b16      	ldr	r3, [pc, #88]	; (80004ec <XBD_BL_HandleProgramFlashRequest+0x84>)
 8000494:	f420 707f 	bic.w	r0, r0, #1020	; 0x3fc
 8000498:	6819      	ldr	r1, [r3, #0]
 800049a:	f020 0003 	bic.w	r0, r0, #3
 800049e:	f000 fc31 	bl	8000d04 <XBD_readPage>
		sw_flash_fbidx = (sw_flashaddr & ~PAGE_ALIGN_MASK);
 80004a2:	6823      	ldr	r3, [r4, #0]
 80004a4:	4a12      	ldr	r2, [pc, #72]	; (80004f0 <XBD_BL_HandleProgramFlashRequest+0x88>)
 80004a6:	f3c3 0309 	ubfx	r3, r3, #0, #10
 80004aa:	8013      	strh	r3, [r2, #0]
		xbd_state = flash;
 80004ac:	4b11      	ldr	r3, [pc, #68]	; (80004f4 <XBD_BL_HandleProgramFlashRequest+0x8c>)
 80004ae:	2201      	movs	r2, #1
 80004b0:	701a      	strb	r2, [r3, #0]
		sw_flashseqn = 0;
 80004b2:	4a11      	ldr	r2, [pc, #68]	; (80004f8 <XBD_BL_HandleProgramFlashRequest+0x90>)
 80004b4:	2300      	movs	r3, #0
 80004b6:	6013      	str	r3, [r2, #0]
		//sw_flash_fbidx = 0;
		sw_flashprocessed = 0;
 80004b8:	4a10      	ldr	r2, [pc, #64]	; (80004fc <XBD_BL_HandleProgramFlashRequest+0x94>)

		//prepare 'OK' response to XBH
		XBD_loadStringFromConstDataArea((char *)buf, XBDpfo);
 80004ba:	4811      	ldr	r0, [pc, #68]	; (8000500 <XBD_BL_HandleProgramFlashRequest+0x98>)
		XBD_readPage((sw_flashaddr & PAGE_ALIGN_MASK), sw_flashbuffer);
		sw_flash_fbidx = (sw_flashaddr & ~PAGE_ALIGN_MASK);
		xbd_state = flash;
		sw_flashseqn = 0;
		//sw_flash_fbidx = 0;
		sw_flashprocessed = 0;
 80004bc:	6013      	str	r3, [r2, #0]

		//prepare 'OK' response to XBH
		XBD_loadStringFromConstDataArea((char *)buf, XBDpfo);
 80004be:	4911      	ldr	r1, [pc, #68]	; (8000504 <XBD_BL_HandleProgramFlashRequest+0x9c>)
 80004c0:	e001      	b.n	80004c6 <XBD_BL_HandleProgramFlashRequest+0x5e>
	} else {
		XBD_DEBUG("Rec'd W-R-O-N-G request to flash:");
		XBD_DEBUG("\nADDR="); XBD_DEBUG_32B(sw_flashaddr);
		XBD_DEBUG("\nLENG="); XBD_DEBUG_32B(sw_flashleng);
		//prepare 'FAIL' response to XBH
		XBD_loadStringFromConstDataArea((char *)buf, XBDpff);
 80004c2:	480f      	ldr	r0, [pc, #60]	; (8000500 <XBD_BL_HandleProgramFlashRequest+0x98>)
 80004c4:	4910      	ldr	r1, [pc, #64]	; (8000508 <XBD_BL_HandleProgramFlashRequest+0xa0>)
 80004c6:	f000 fc1b 	bl	8000d00 <XBD_loadStringFromConstDataArea>
	}

//	XBD_DEBUG("\n");
//	XBD_DEBUG((char *)buf);
//	XBD_DEBUG("\n");
	strcpy((char *)XBD_response, (char *)buf);
 80004ca:	4810      	ldr	r0, [pc, #64]	; (800050c <XBD_BL_HandleProgramFlashRequest+0xa4>)
 80004cc:	490c      	ldr	r1, [pc, #48]	; (8000500 <XBD_BL_HandleProgramFlashRequest+0x98>)
 80004ce:	f000 fba0 	bl	8000c12 <strcpy>
	realTXlen=XBD_COMMAND_LEN+CRC16SIZE;
 80004d2:	4b0f      	ldr	r3, [pc, #60]	; (8000510 <XBD_BL_HandleProgramFlashRequest+0xa8>)
 80004d4:	220a      	movs	r2, #10
 80004d6:	701a      	strb	r2, [r3, #0]
 80004d8:	bd10      	pop	{r4, pc}
 80004da:	bf00      	nop
 80004dc:	20000980 	.word	0x20000980
 80004e0:	20000988 	.word	0x20000988
 80004e4:	08002fff 	.word	0x08002fff
 80004e8:	08020000 	.word	0x08020000
 80004ec:	20000428 	.word	0x20000428
 80004f0:	20000578 	.word	0x20000578
 80004f4:	20000494 	.word	0x20000494
 80004f8:	20000984 	.word	0x20000984
 80004fc:	20000990 	.word	0x20000990
 8000500:	20000a98 	.word	0x20000a98
 8000504:	08001dfb 	.word	0x08001dfb
 8000508:	08001e28 	.word	0x08001e28
 800050c:	20000998 	.word	0x20000998
 8000510:	20000aa1 	.word	0x20000aa1

08000514 <XBD_BL_HandleFlashDownloadRequest>:
	return;
}

void XBD_BL_HandleFlashDownloadRequest(uint8_t len, uint8_t *data) {
 8000514:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if ((sw_flashseqn == NTOHL(*((uint32_t*) (data + XBD_COMMAND_LEN)))) && //sequence number correct
 8000518:	4f27      	ldr	r7, [pc, #156]	; (80005b8 <XBD_BL_HandleFlashDownloadRequest+0xa4>)
 800051a:	688b      	ldr	r3, [r1, #8]
 800051c:	683a      	ldr	r2, [r7, #0]
 800051e:	ba1b      	rev	r3, r3
 8000520:	429a      	cmp	r2, r3
	strcpy((char *)XBD_response, (char *)buf);
	realTXlen=XBD_COMMAND_LEN+CRC16SIZE;
	return;
}

void XBD_BL_HandleFlashDownloadRequest(uint8_t len, uint8_t *data) {
 8000522:	4680      	mov	r8, r0
	if ((sw_flashseqn == NTOHL(*((uint32_t*) (data + XBD_COMMAND_LEN)))) && //sequence number correct
 8000524:	d13b      	bne.n	800059e <XBD_BL_HandleFlashDownloadRequest+0x8a>
			(xbd_state == flash)) {
 8000526:	4b25      	ldr	r3, [pc, #148]	; (80005bc <XBD_BL_HandleFlashDownloadRequest+0xa8>)
	realTXlen=XBD_COMMAND_LEN+CRC16SIZE;
	return;
}

void XBD_BL_HandleFlashDownloadRequest(uint8_t len, uint8_t *data) {
	if ((sw_flashseqn == NTOHL(*((uint32_t*) (data + XBD_COMMAND_LEN)))) && //sequence number correct
 8000528:	781a      	ldrb	r2, [r3, #0]
 800052a:	461d      	mov	r5, r3
 800052c:	2a01      	cmp	r2, #1
 800052e:	d136      	bne.n	800059e <XBD_BL_HandleFlashDownloadRequest+0x8a>
//		XBD_DEBUG("Rec'd correct flash download:");
//		XBD_DEBUG("\nSEQN="), XBD_DEBUG_32B(sw_flashseqn);
//		XBD_DEBUG("\nADDR="), XBD_DEBUG_32B(sw_flashaddr);
//		XBD_DEBUG("\nLENG="), XBD_DEBUG_32B(sw_flashleng);

		if (PAGESIZE >= (sw_flash_fbidx + len - XBD_COMMAND_LEN - SEQNSIZE)) {
 8000530:	4c23      	ldr	r4, [pc, #140]	; (80005c0 <XBD_BL_HandleFlashDownloadRequest+0xac>)
 8000532:	8820      	ldrh	r0, [r4, #0]
 8000534:	eb00 0208 	add.w	r2, r0, r8
 8000538:	3a0c      	subs	r2, #12
 800053a:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
 800053e:	d82c      	bhi.n	800059a <XBD_BL_HandleFlashDownloadRequest+0x86>
			uint8_t *p_src = (void*) (data+XBD_COMMAND_LEN + SEQNSIZE);
			uint8_t cpylen = len - XBD_COMMAND_LEN - SEQNSIZE;
			memcpy(&sw_flashbuffer[sw_flash_fbidx], p_src,cpylen );
 8000540:	4e20      	ldr	r6, [pc, #128]	; (80005c4 <XBD_BL_HandleFlashDownloadRequest+0xb0>)
//		XBD_DEBUG("\nADDR="), XBD_DEBUG_32B(sw_flashaddr);
//		XBD_DEBUG("\nLENG="), XBD_DEBUG_32B(sw_flashleng);

		if (PAGESIZE >= (sw_flash_fbidx + len - XBD_COMMAND_LEN - SEQNSIZE)) {
			uint8_t *p_src = (void*) (data+XBD_COMMAND_LEN + SEQNSIZE);
			uint8_t cpylen = len - XBD_COMMAND_LEN - SEQNSIZE;
 8000542:	f1a8 020c 	sub.w	r2, r8, #12
			memcpy(&sw_flashbuffer[sw_flash_fbidx], p_src,cpylen );
 8000546:	6833      	ldr	r3, [r6, #0]
 8000548:	310c      	adds	r1, #12
 800054a:	4418      	add	r0, r3
 800054c:	b2d2      	uxtb	r2, r2
 800054e:	f000 fb57 	bl	8000c00 <memcpy>
			sw_flash_fbidx += len - XBD_COMMAND_LEN - SEQNSIZE;
			sw_flashleng -= len - XBD_COMMAND_LEN - SEQNSIZE;
 8000552:	4a1d      	ldr	r2, [pc, #116]	; (80005c8 <XBD_BL_HandleFlashDownloadRequest+0xb4>)
 8000554:	8823      	ldrh	r3, [r4, #0]
 8000556:	6810      	ldr	r0, [r2, #0]
 8000558:	3b0c      	subs	r3, #12
			++sw_flashseqn;
 800055a:	6839      	ldr	r1, [r7, #0]

		if (PAGESIZE >= (sw_flash_fbidx + len - XBD_COMMAND_LEN - SEQNSIZE)) {
			uint8_t *p_src = (void*) (data+XBD_COMMAND_LEN + SEQNSIZE);
			uint8_t cpylen = len - XBD_COMMAND_LEN - SEQNSIZE;
			memcpy(&sw_flashbuffer[sw_flash_fbidx], p_src,cpylen );
			sw_flash_fbidx += len - XBD_COMMAND_LEN - SEQNSIZE;
 800055c:	4443      	add	r3, r8
 800055e:	b29b      	uxth	r3, r3
 8000560:	300c      	adds	r0, #12
			sw_flashleng -= len - XBD_COMMAND_LEN - SEQNSIZE;
 8000562:	ebc8 0000 	rsb	r0, r8, r0
			++sw_flashseqn;
 8000566:	3101      	adds	r1, #1

			if ((PAGESIZE == sw_flash_fbidx) || (0 == sw_flashleng)) {
 8000568:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
			uint8_t *p_src = (void*) (data+XBD_COMMAND_LEN + SEQNSIZE);
			uint8_t cpylen = len - XBD_COMMAND_LEN - SEQNSIZE;
			memcpy(&sw_flashbuffer[sw_flash_fbidx], p_src,cpylen );
			sw_flash_fbidx += len - XBD_COMMAND_LEN - SEQNSIZE;
			sw_flashleng -= len - XBD_COMMAND_LEN - SEQNSIZE;
			++sw_flashseqn;
 800056c:	6039      	str	r1, [r7, #0]

		if (PAGESIZE >= (sw_flash_fbidx + len - XBD_COMMAND_LEN - SEQNSIZE)) {
			uint8_t *p_src = (void*) (data+XBD_COMMAND_LEN + SEQNSIZE);
			uint8_t cpylen = len - XBD_COMMAND_LEN - SEQNSIZE;
			memcpy(&sw_flashbuffer[sw_flash_fbidx], p_src,cpylen );
			sw_flash_fbidx += len - XBD_COMMAND_LEN - SEQNSIZE;
 800056e:	8023      	strh	r3, [r4, #0]
			sw_flashleng -= len - XBD_COMMAND_LEN - SEQNSIZE;
 8000570:	6010      	str	r0, [r2, #0]
 8000572:	4617      	mov	r7, r2
			++sw_flashseqn;

			if ((PAGESIZE == sw_flash_fbidx) || (0 == sw_flashleng)) {
 8000574:	d000      	beq.n	8000578 <XBD_BL_HandleFlashDownloadRequest+0x64>
 8000576:	b950      	cbnz	r0, 800058e <XBD_BL_HandleFlashDownloadRequest+0x7a>
				//boot_program_page(sw_flashaddr, sw_flashbuffer);
				XBD_programPage((sw_flashaddr & PAGE_ALIGN_MASK), sw_flashbuffer);
 8000578:	4b14      	ldr	r3, [pc, #80]	; (80005cc <XBD_BL_HandleFlashDownloadRequest+0xb8>)
 800057a:	6831      	ldr	r1, [r6, #0]
 800057c:	6818      	ldr	r0, [r3, #0]
 800057e:	f420 707f 	bic.w	r0, r0, #1020	; 0x3fc
 8000582:	f020 0003 	bic.w	r0, r0, #3
 8000586:	f000 fbc5 	bl	8000d14 <XBD_programPage>
				sw_flash_fbidx = 0;
 800058a:	2300      	movs	r3, #0
 800058c:	8023      	strh	r3, [r4, #0]
			}

			if (0 == sw_flashleng) {
 800058e:	683b      	ldr	r3, [r7, #0]
 8000590:	b903      	cbnz	r3, 8000594 <XBD_BL_HandleFlashDownloadRequest+0x80>
				xbd_state = idle;
 8000592:	702b      	strb	r3, [r5, #0]
			}

			//prepare 'OK' response to XBH
			XBD_loadStringFromConstDataArea((char *)buf, XBDpfo);
 8000594:	480e      	ldr	r0, [pc, #56]	; (80005d0 <XBD_BL_HandleFlashDownloadRequest+0xbc>)
 8000596:	490f      	ldr	r1, [pc, #60]	; (80005d4 <XBD_BL_HandleFlashDownloadRequest+0xc0>)
 8000598:	e003      	b.n	80005a2 <XBD_BL_HandleFlashDownloadRequest+0x8e>
		} else {
			// TODO: downloads von >1 page unterstuetzen
			XBD_DEBUG("\nDownload > 1 Page not yet supported.");
			xbd_state = idle;
 800059a:	2200      	movs	r2, #0
 800059c:	701a      	strb	r2, [r3, #0]
		XBD_DEBUG("\nADDR="); XBD_DEBUG_32B(sw_flashaddr);
		XBD_DEBUG("\nLENG="); XBD_DEBUG_32B(sw_flashleng);
		XBD_DEBUG("\nEXPECTED SQ="); XBD_DEBUG_32B(sw_flashseqn);
		XBD_DEBUG("\nRec'd SQ="); XBD_DEBUG_32B(NTOHL(*((uint32_t*) (data + XBD_COMMAND_LEN))));
                //prepare 'FAIL' response to XBH
		XBD_loadStringFromConstDataArea((char *)buf, XBDpff);
 800059e:	480c      	ldr	r0, [pc, #48]	; (80005d0 <XBD_BL_HandleFlashDownloadRequest+0xbc>)
 80005a0:	490d      	ldr	r1, [pc, #52]	; (80005d8 <XBD_BL_HandleFlashDownloadRequest+0xc4>)
 80005a2:	f000 fbad 	bl	8000d00 <XBD_loadStringFromConstDataArea>
	}

//	XBD_DEBUG("\n");
//	XBD_DEBUG((char *)buf);
//	XBD_DEBUG("\n");
	strcpy((char *)XBD_response, (char *)buf);
 80005a6:	480d      	ldr	r0, [pc, #52]	; (80005dc <XBD_BL_HandleFlashDownloadRequest+0xc8>)
 80005a8:	4909      	ldr	r1, [pc, #36]	; (80005d0 <XBD_BL_HandleFlashDownloadRequest+0xbc>)
 80005aa:	f000 fb32 	bl	8000c12 <strcpy>
	realTXlen=XBD_COMMAND_LEN+CRC16SIZE;
 80005ae:	4b0c      	ldr	r3, [pc, #48]	; (80005e0 <XBD_BL_HandleFlashDownloadRequest+0xcc>)
 80005b0:	220a      	movs	r2, #10
 80005b2:	701a      	strb	r2, [r3, #0]
 80005b4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80005b8:	20000984 	.word	0x20000984
 80005bc:	20000494 	.word	0x20000494
 80005c0:	20000578 	.word	0x20000578
 80005c4:	20000428 	.word	0x20000428
 80005c8:	20000980 	.word	0x20000980
 80005cc:	20000988 	.word	0x20000988
 80005d0:	20000a98 	.word	0x20000a98
 80005d4:	08001dfb 	.word	0x08001dfb
 80005d8:	08001e28 	.word	0x08001e28
 80005dc:	20000998 	.word	0x20000998
 80005e0:	20000aa1 	.word	0x20000aa1

080005e4 <XBD_BL_HandleVersionInformationRequest>:

void XBD_BL_HandleStartApplicationRequest(){
	XBD_switchToApplication();
}

void XBD_BL_HandleVersionInformationRequest(){
 80005e4:	b508      	push	{r3, lr}
	XBD_loadStringFromConstDataArea((char *)XBD_response, XBDblo);
 80005e6:	4804      	ldr	r0, [pc, #16]	; (80005f8 <XBD_BL_HandleVersionInformationRequest+0x14>)
 80005e8:	4904      	ldr	r1, [pc, #16]	; (80005fc <XBD_BL_HandleVersionInformationRequest+0x18>)
 80005ea:	f000 fb89 	bl	8000d00 <XBD_loadStringFromConstDataArea>
	realTXlen=XBD_COMMAND_LEN+CRC16SIZE;
 80005ee:	4b04      	ldr	r3, [pc, #16]	; (8000600 <XBD_BL_HandleVersionInformationRequest+0x1c>)
 80005f0:	220a      	movs	r2, #10
 80005f2:	701a      	strb	r2, [r3, #0]
 80005f4:	bd08      	pop	{r3, pc}
 80005f6:	bf00      	nop
 80005f8:	20000998 	.word	0x20000998
 80005fc:	08001e55 	.word	0x08001e55
 8000600:	20000aa1 	.word	0x20000aa1

08000604 <XBD_BL_HandleTimingCalibrationRequest>:
}

void XBD_BL_HandleTimingCalibrationRequest(){
 8000604:	b537      	push	{r0, r1, r2, r4, r5, lr}
	uint32_t cycles_elapsed = XBD_busyLoopWithTiming(DEVICE_SPECIFIC_SANE_TC_VALUE);
 8000606:	480b      	ldr	r0, [pc, #44]	; (8000634 <XBD_BL_HandleTimingCalibrationRequest+0x30>)
 8000608:	f000 fbd6 	bl	8000db8 <XBD_busyLoopWithTiming>
	uint32_t cycles_elapsed_n = HTONL(cycles_elapsed);

    XBD_loadStringFromConstDataArea((char *)XBD_response, XBDtco);
 800060c:	4d0a      	ldr	r5, [pc, #40]	; (8000638 <XBD_BL_HandleTimingCalibrationRequest+0x34>)
	realTXlen=XBD_COMMAND_LEN+CRC16SIZE;
}

void XBD_BL_HandleTimingCalibrationRequest(){
	uint32_t cycles_elapsed = XBD_busyLoopWithTiming(DEVICE_SPECIFIC_SANE_TC_VALUE);
	uint32_t cycles_elapsed_n = HTONL(cycles_elapsed);
 800060e:	ac02      	add	r4, sp, #8
 8000610:	ba00      	rev	r0, r0
 8000612:	f844 0d04 	str.w	r0, [r4, #-4]!

    XBD_loadStringFromConstDataArea((char *)XBD_response, XBDtco);
 8000616:	4909      	ldr	r1, [pc, #36]	; (800063c <XBD_BL_HandleTimingCalibrationRequest+0x38>)
 8000618:	4628      	mov	r0, r5
 800061a:	f000 fb71 	bl	8000d00 <XBD_loadStringFromConstDataArea>
    memcpy(XBD_response+XBD_COMMAND_LEN,&cycles_elapsed_n, sizeof(cycles_elapsed_n));
 800061e:	f105 0008 	add.w	r0, r5, #8
 8000622:	4621      	mov	r1, r4
 8000624:	2204      	movs	r2, #4
 8000626:	f000 faeb 	bl	8000c00 <memcpy>
    realTXlen=XBD_COMMAND_LEN+TIMESIZE+CRC16SIZE;
 800062a:	4b05      	ldr	r3, [pc, #20]	; (8000640 <XBD_BL_HandleTimingCalibrationRequest+0x3c>)
 800062c:	220e      	movs	r2, #14
 800062e:	701a      	strb	r2, [r3, #0]
}
 8000630:	b003      	add	sp, #12
 8000632:	bd30      	pop	{r4, r5, pc}
 8000634:	00f42400 	.word	0x00f42400
 8000638:	20000998 	.word	0x20000998
 800063c:	08001e3a 	.word	0x08001e3a
 8000640:	20000aa1 	.word	0x20000aa1

08000644 <XBD_BL_HandleTargetRevisionRequest>:

void XBD_BL_HandleTargetRevisionRequest(){
 8000644:	b510      	push	{r4, lr}
	uint8_t i;
	uint8_t revLen = strlen(XBD_Rev);
 8000646:	4811      	ldr	r0, [pc, #68]	; (800068c <XBD_BL_HandleTargetRevisionRequest+0x48>)
 8000648:	f001 fb04 	bl	8001c54 <strlen>
 800064c:	b2c0      	uxtb	r0, r0

    revLen = (revLen > REVNSIZE) ? REVNSIZE: revLen;
 800064e:	2807      	cmp	r0, #7
 8000650:	bf28      	it	cs
 8000652:	2007      	movcs	r0, #7
 8000654:	4604      	mov	r4, r0

	XBD_loadStringFromConstDataArea((char *)XBD_response, XBDtro);
 8000656:	490e      	ldr	r1, [pc, #56]	; (8000690 <XBD_BL_HandleTargetRevisionRequest+0x4c>)
 8000658:	480e      	ldr	r0, [pc, #56]	; (8000694 <XBD_BL_HandleTargetRevisionRequest+0x50>)
 800065a:	f000 fb51 	bl	8000d00 <XBD_loadStringFromConstDataArea>
	
	for(i=0;i<REVNSIZE-revLen;++i)
 800065e:	2200      	movs	r2, #0
 8000660:	b2d3      	uxtb	r3, r2
 8000662:	f1c4 0107 	rsb	r1, r4, #7
 8000666:	428b      	cmp	r3, r1
 8000668:	f102 0201 	add.w	r2, r2, #1
 800066c:	4809      	ldr	r0, [pc, #36]	; (8000694 <XBD_BL_HandleTargetRevisionRequest+0x50>)
 800066e:	da03      	bge.n	8000678 <XBD_BL_HandleTargetRevisionRequest+0x34>
	{
		XBD_response[XBD_COMMAND_LEN+i]='0';
 8000670:	4403      	add	r3, r0
 8000672:	2130      	movs	r1, #48	; 0x30
 8000674:	7219      	strb	r1, [r3, #8]
 8000676:	e7f3      	b.n	8000660 <XBD_BL_HandleTargetRevisionRequest+0x1c>
	}
	XBD_loadStringFromConstDataArea((char *)&XBD_response[XBD_COMMAND_LEN+i], XBD_Rev);
 8000678:	3308      	adds	r3, #8
 800067a:	4418      	add	r0, r3
 800067c:	4903      	ldr	r1, [pc, #12]	; (800068c <XBD_BL_HandleTargetRevisionRequest+0x48>)
 800067e:	f000 fb3f 	bl	8000d00 <XBD_loadStringFromConstDataArea>
	realTXlen=XBD_COMMAND_LEN+REVNSIZE+CRC16SIZE;
 8000682:	4b05      	ldr	r3, [pc, #20]	; (8000698 <XBD_BL_HandleTargetRevisionRequest+0x54>)
 8000684:	2211      	movs	r2, #17
 8000686:	701a      	strb	r2, [r3, #0]
 8000688:	bd10      	pop	{r4, pc}
 800068a:	bf00      	nop
 800068c:	08001d78 	.word	0x08001d78
 8000690:	08001de9 	.word	0x08001de9
 8000694:	20000998 	.word	0x20000998
 8000698:	20000aa1 	.word	0x20000aa1

0800069c <FRW_msgRecHand>:
}

void FRW_msgRecHand(uint8_t len, uint8_t* data) {
 800069c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800069e:	460c      	mov	r4, r1
	XBD_DEBUG("\n");
	#endif

	//check crc and disregard block if wrong

	rx_crc = UNPACK_CRC(&data[len - CRC16SIZE]);
 80006a0:	180a      	adds	r2, r1, r0
 80006a2:	f812 1c02 	ldrb.w	r1, [r2, #-2]
 80006a6:	f812 3c01 	ldrb.w	r3, [r2, #-1]
 80006aa:	4f44      	ldr	r7, [pc, #272]	; (80007bc <FRW_msgRecHand+0x120>)
	crc = crc16buffer(data, len - CRC16SIZE);
 80006ac:	1e85      	subs	r5, r0, #2
	XBD_DEBUG("\n");
	#endif

	//check crc and disregard block if wrong

	rx_crc = UNPACK_CRC(&data[len - CRC16SIZE]);
 80006ae:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
	}
	XBD_loadStringFromConstDataArea((char *)&XBD_response[XBD_COMMAND_LEN+i], XBD_Rev);
	realTXlen=XBD_COMMAND_LEN+REVNSIZE+CRC16SIZE;
}

void FRW_msgRecHand(uint8_t len, uint8_t* data) {
 80006b2:	4606      	mov	r6, r0
	#endif

	//check crc and disregard block if wrong

	rx_crc = UNPACK_CRC(&data[len - CRC16SIZE]);
	crc = crc16buffer(data, len - CRC16SIZE);
 80006b4:	b2a9      	uxth	r1, r5
 80006b6:	4620      	mov	r0, r4
	XBD_DEBUG("\n");
	#endif

	//check crc and disregard block if wrong

	rx_crc = UNPACK_CRC(&data[len - CRC16SIZE]);
 80006b8:	803b      	strh	r3, [r7, #0]
	crc = crc16buffer(data, len - CRC16SIZE);
 80006ba:	f000 fa50 	bl	8000b5e <crc16buffer>
 80006be:	4b40      	ldr	r3, [pc, #256]	; (80007c0 <FRW_msgRecHand+0x124>)
 80006c0:	8018      	strh	r0, [r3, #0]
	if (rx_crc != crc) {
 80006c2:	883b      	ldrh	r3, [r7, #0]
 80006c4:	4283      	cmp	r3, r0
 80006c6:	d005      	beq.n	80006d4 <FRW_msgRecHand+0x38>
		XBD_BL_DisregardBlock(len, data);
 80006c8:	4630      	mov	r0, r6
 80006ca:	4621      	mov	r1, r4
    realTXlen = strlen(XBDunk);
	#ifdef XBX_DEBUG_BL
	XBD_DEBUG((char *)XBD_response);
	XBD_DEBUG("\n");
	#endif
}
 80006cc:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	//check crc and disregard block if wrong

	rx_crc = UNPACK_CRC(&data[len - CRC16SIZE]);
	crc = crc16buffer(data, len - CRC16SIZE);
	if (rx_crc != crc) {
		XBD_BL_DisregardBlock(len, data);
 80006d0:	f7ff be8e 	b.w	80003f0 <XBD_BL_DisregardBlock>
	}

	// l 
	// o opback
	// r equest
	XBD_loadStringFromConstDataArea((char *)buf, XBDlor);
 80006d4:	483b      	ldr	r0, [pc, #236]	; (80007c4 <FRW_msgRecHand+0x128>)
 80006d6:	493c      	ldr	r1, [pc, #240]	; (80007c8 <FRW_msgRecHand+0x12c>)
 80006d8:	f000 fb12 	bl	8000d00 <XBD_loadStringFromConstDataArea>
	if (0 == strncmp((char *)buf, (char*) data, XBD_COMMAND_LEN)) {
 80006dc:	4839      	ldr	r0, [pc, #228]	; (80007c4 <FRW_msgRecHand+0x128>)
 80006de:	4621      	mov	r1, r4
 80006e0:	2208      	movs	r2, #8
	realTXlen=XBD_COMMAND_LEN+REVNSIZE+CRC16SIZE;
}

void FRW_msgRecHand(uint8_t len, uint8_t* data) {

	uint8_t dataLen=len-CRC16SIZE;
 80006e2:	b2ed      	uxtb	r5, r5

	// l 
	// o opback
	// r equest
	XBD_loadStringFromConstDataArea((char *)buf, XBDlor);
	if (0 == strncmp((char *)buf, (char*) data, XBD_COMMAND_LEN)) {
 80006e4:	f001 fae4 	bl	8001cb0 <strncmp>
 80006e8:	b928      	cbnz	r0, 80006f6 <FRW_msgRecHand+0x5a>
		XBD_BL_HandleLOopbackRequest(dataLen, data);
 80006ea:	4628      	mov	r0, r5
 80006ec:	4621      	mov	r1, r4
    realTXlen = strlen(XBDunk);
	#ifdef XBX_DEBUG_BL
	XBD_DEBUG((char *)XBD_response);
	XBD_DEBUG("\n");
	#endif
}
 80006ee:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	// l 
	// o opback
	// r equest
	XBD_loadStringFromConstDataArea((char *)buf, XBDlor);
	if (0 == strncmp((char *)buf, (char*) data, XBD_COMMAND_LEN)) {
		XBD_BL_HandleLOopbackRequest(dataLen, data);
 80006f2:	f7ff be99 	b.w	8000428 <XBD_BL_HandleLOopbackRequest>


	// p rogram
	// f lash
	// r equest
	XBD_loadStringFromConstDataArea((char *)buf, XBDpfr);
 80006f6:	4833      	ldr	r0, [pc, #204]	; (80007c4 <FRW_msgRecHand+0x128>)
 80006f8:	4934      	ldr	r1, [pc, #208]	; (80007cc <FRW_msgRecHand+0x130>)
 80006fa:	f000 fb01 	bl	8000d00 <XBD_loadStringFromConstDataArea>
	if (0 == strncmp((char *)buf, (char*) data, XBD_COMMAND_LEN)) {
 80006fe:	4831      	ldr	r0, [pc, #196]	; (80007c4 <FRW_msgRecHand+0x128>)
 8000700:	4621      	mov	r1, r4
 8000702:	2208      	movs	r2, #8
 8000704:	f001 fad4 	bl	8001cb0 <strncmp>
 8000708:	b928      	cbnz	r0, 8000716 <FRW_msgRecHand+0x7a>
		XBD_BL_HandleProgramFlashRequest(dataLen, data);
 800070a:	4628      	mov	r0, r5
 800070c:	4621      	mov	r1, r4
    realTXlen = strlen(XBDunk);
	#ifdef XBX_DEBUG_BL
	XBD_DEBUG((char *)XBD_response);
	XBD_DEBUG("\n");
	#endif
}
 800070e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	// p rogram
	// f lash
	// r equest
	XBD_loadStringFromConstDataArea((char *)buf, XBDpfr);
	if (0 == strncmp((char *)buf, (char*) data, XBD_COMMAND_LEN)) {
		XBD_BL_HandleProgramFlashRequest(dataLen, data);
 8000712:	f7ff bea9 	b.w	8000468 <XBD_BL_HandleProgramFlashRequest>
	}

	// f lash
	// d ownload
	// r equest
	XBD_loadStringFromConstDataArea((char *)buf, XBDfdr);
 8000716:	482b      	ldr	r0, [pc, #172]	; (80007c4 <FRW_msgRecHand+0x128>)
 8000718:	492d      	ldr	r1, [pc, #180]	; (80007d0 <FRW_msgRecHand+0x134>)
 800071a:	f000 faf1 	bl	8000d00 <XBD_loadStringFromConstDataArea>
	if (0 == strncmp((char *)buf, (char*) data, XBD_COMMAND_LEN)) {
 800071e:	4829      	ldr	r0, [pc, #164]	; (80007c4 <FRW_msgRecHand+0x128>)
 8000720:	4621      	mov	r1, r4
 8000722:	2208      	movs	r2, #8
 8000724:	f001 fac4 	bl	8001cb0 <strncmp>
 8000728:	b928      	cbnz	r0, 8000736 <FRW_msgRecHand+0x9a>
		XBD_BL_HandleFlashDownloadRequest(dataLen, data);
 800072a:	4628      	mov	r0, r5
 800072c:	4621      	mov	r1, r4
    realTXlen = strlen(XBDunk);
	#ifdef XBX_DEBUG_BL
	XBD_DEBUG((char *)XBD_response);
	XBD_DEBUG("\n");
	#endif
}
 800072e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	// f lash
	// d ownload
	// r equest
	XBD_loadStringFromConstDataArea((char *)buf, XBDfdr);
	if (0 == strncmp((char *)buf, (char*) data, XBD_COMMAND_LEN)) {
		XBD_BL_HandleFlashDownloadRequest(dataLen, data);
 8000732:	f7ff beef 	b.w	8000514 <XBD_BL_HandleFlashDownloadRequest>
	}

	// s tart
	// a application
	// r equest
	XBD_loadStringFromConstDataArea((char *)buf, XBDsar);
 8000736:	4823      	ldr	r0, [pc, #140]	; (80007c4 <FRW_msgRecHand+0x128>)
 8000738:	4926      	ldr	r1, [pc, #152]	; (80007d4 <FRW_msgRecHand+0x138>)
 800073a:	f000 fae1 	bl	8000d00 <XBD_loadStringFromConstDataArea>
	if (0 == strncmp((char *)buf, (char*) data, XBD_COMMAND_LEN)) {
 800073e:	4821      	ldr	r0, [pc, #132]	; (80007c4 <FRW_msgRecHand+0x128>)
 8000740:	4621      	mov	r1, r4
 8000742:	2208      	movs	r2, #8
 8000744:	f001 fab4 	bl	8001cb0 <strncmp>
 8000748:	b918      	cbnz	r0, 8000752 <FRW_msgRecHand+0xb6>
    realTXlen = strlen(XBDunk);
	#ifdef XBX_DEBUG_BL
	XBD_DEBUG((char *)XBD_response);
	XBD_DEBUG("\n");
	#endif
}
 800074a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	realTXlen=XBD_COMMAND_LEN+CRC16SIZE;
	return;
}

void XBD_BL_HandleStartApplicationRequest(){
	XBD_switchToApplication();
 800074e:	f000 bb2d 	b.w	8000dac <XBD_switchToApplication>
	}

	// v ersion
	// i nformation
	// r equest
	XBD_loadStringFromConstDataArea((char *)buf, XBDvir);
 8000752:	481c      	ldr	r0, [pc, #112]	; (80007c4 <FRW_msgRecHand+0x128>)
 8000754:	4920      	ldr	r1, [pc, #128]	; (80007d8 <FRW_msgRecHand+0x13c>)
 8000756:	f000 fad3 	bl	8000d00 <XBD_loadStringFromConstDataArea>
	if (0 == strncmp((char *)buf, (char*) data, XBD_COMMAND_LEN)) {
 800075a:	481a      	ldr	r0, [pc, #104]	; (80007c4 <FRW_msgRecHand+0x128>)
 800075c:	4621      	mov	r1, r4
 800075e:	2208      	movs	r2, #8
 8000760:	f001 faa6 	bl	8001cb0 <strncmp>
 8000764:	b918      	cbnz	r0, 800076e <FRW_msgRecHand+0xd2>
    realTXlen = strlen(XBDunk);
	#ifdef XBX_DEBUG_BL
	XBD_DEBUG((char *)XBD_response);
	XBD_DEBUG("\n");
	#endif
}
 8000766:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	// v ersion
	// i nformation
	// r equest
	XBD_loadStringFromConstDataArea((char *)buf, XBDvir);
	if (0 == strncmp((char *)buf, (char*) data, XBD_COMMAND_LEN)) {
		XBD_BL_HandleVersionInformationRequest();
 800076a:	f7ff bf3b 	b.w	80005e4 <XBD_BL_HandleVersionInformationRequest>


	// t iming
	// c alibration
	// r equest
	XBD_loadStringFromConstDataArea((char *)buf, XBDtcr);
 800076e:	4815      	ldr	r0, [pc, #84]	; (80007c4 <FRW_msgRecHand+0x128>)
 8000770:	491a      	ldr	r1, [pc, #104]	; (80007dc <FRW_msgRecHand+0x140>)
 8000772:	f000 fac5 	bl	8000d00 <XBD_loadStringFromConstDataArea>
	if (0 == strncmp((char *)buf, (char*) data, XBD_COMMAND_LEN)) {
 8000776:	4813      	ldr	r0, [pc, #76]	; (80007c4 <FRW_msgRecHand+0x128>)
 8000778:	4621      	mov	r1, r4
 800077a:	2208      	movs	r2, #8
 800077c:	f001 fa98 	bl	8001cb0 <strncmp>
 8000780:	b918      	cbnz	r0, 800078a <FRW_msgRecHand+0xee>
    realTXlen = strlen(XBDunk);
	#ifdef XBX_DEBUG_BL
	XBD_DEBUG((char *)XBD_response);
	XBD_DEBUG("\n");
	#endif
}
 8000782:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	// t iming
	// c alibration
	// r equest
	XBD_loadStringFromConstDataArea((char *)buf, XBDtcr);
	if (0 == strncmp((char *)buf, (char*) data, XBD_COMMAND_LEN)) {
		XBD_BL_HandleTimingCalibrationRequest();
 8000786:	f7ff bf3d 	b.w	8000604 <XBD_BL_HandleTimingCalibrationRequest>
	}

	// t arget
	// r evision
	// r equest
	XBD_loadStringFromConstDataArea((char *)buf, XBDtrr);
 800078a:	480e      	ldr	r0, [pc, #56]	; (80007c4 <FRW_msgRecHand+0x128>)
 800078c:	4914      	ldr	r1, [pc, #80]	; (80007e0 <FRW_msgRecHand+0x144>)
 800078e:	f000 fab7 	bl	8000d00 <XBD_loadStringFromConstDataArea>
	if (0 == strncmp((char *)buf, (char*) data, XBD_COMMAND_LEN)) {
 8000792:	480c      	ldr	r0, [pc, #48]	; (80007c4 <FRW_msgRecHand+0x128>)
 8000794:	4621      	mov	r1, r4
 8000796:	2208      	movs	r2, #8
 8000798:	f001 fa8a 	bl	8001cb0 <strncmp>
 800079c:	b918      	cbnz	r0, 80007a6 <FRW_msgRecHand+0x10a>
    realTXlen = strlen(XBDunk);
	#ifdef XBX_DEBUG_BL
	XBD_DEBUG((char *)XBD_response);
	XBD_DEBUG("\n");
	#endif
}
 800079e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	// t arget
	// r evision
	// r equest
	XBD_loadStringFromConstDataArea((char *)buf, XBDtrr);
	if (0 == strncmp((char *)buf, (char*) data, XBD_COMMAND_LEN)) {
		XBD_BL_HandleTargetRevisionRequest();
 80007a2:	f7ff bf4f 	b.w	8000644 <XBD_BL_HandleTargetRevisionRequest>
		return;
	}

	//no known command recognized
	XBD_loadStringFromConstDataArea((char *)XBD_response, XBDunk);
 80007a6:	480f      	ldr	r0, [pc, #60]	; (80007e4 <FRW_msgRecHand+0x148>)
 80007a8:	490f      	ldr	r1, [pc, #60]	; (80007e8 <FRW_msgRecHand+0x14c>)
 80007aa:	f000 faa9 	bl	8000d00 <XBD_loadStringFromConstDataArea>
    realTXlen = strlen(XBDunk);
 80007ae:	480e      	ldr	r0, [pc, #56]	; (80007e8 <FRW_msgRecHand+0x14c>)
 80007b0:	f001 fa50 	bl	8001c54 <strlen>
 80007b4:	4b0d      	ldr	r3, [pc, #52]	; (80007ec <FRW_msgRecHand+0x150>)
 80007b6:	7018      	strb	r0, [r3, #0]
 80007b8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80007ba:	bf00      	nop
 80007bc:	20000994 	.word	0x20000994
 80007c0:	2000098c 	.word	0x2000098c
 80007c4:	20000a98 	.word	0x20000a98
 80007c8:	08001df2 	.word	0x08001df2
 80007cc:	08001e31 	.word	0x08001e31
 80007d0:	08001e1f 	.word	0x08001e1f
 80007d4:	08001e16 	.word	0x08001e16
 80007d8:	08001e67 	.word	0x08001e67
 80007dc:	08001e43 	.word	0x08001e43
 80007e0:	08001e4c 	.word	0x08001e4c
 80007e4:	20000998 	.word	0x20000998
 80007e8:	08001e04 	.word	0x08001e04
 80007ec:	20000aa1 	.word	0x20000aa1

080007f0 <FRW_msgTraHand>:
	XBD_DEBUG((char *)XBD_response);
	XBD_DEBUG("\n");
	#endif
}

uint8_t FRW_msgTraHand(uint8_t maxlen, uint8_t* data) {
 80007f0:	b570      	push	{r4, r5, r6, lr}
    //XBD_DEBUG("\n");
		maxlen = XBD_ANSWER_MAXLEN;
	}

    // Truncate transmission if greater than maxlen
    txLen = (realTXlen > maxlen) ? maxlen: realTXlen;
 80007f2:	4b0e      	ldr	r3, [pc, #56]	; (800082c <FRW_msgTraHand+0x3c>)
 80007f4:	2811      	cmp	r0, #17
 80007f6:	781c      	ldrb	r4, [r3, #0]
 80007f8:	bf28      	it	cs
 80007fa:	2011      	movcs	r0, #17
 80007fc:	4284      	cmp	r4, r0
 80007fe:	bf28      	it	cs
 8000800:	4604      	movcs	r4, r0
	XBD_DEBUG((char *)XBD_response);
	XBD_DEBUG("\n");
	#endif
}

uint8_t FRW_msgTraHand(uint8_t maxlen, uint8_t* data) {
 8000802:	460d      	mov	r5, r1
	}

    // Truncate transmission if greater than maxlen
    txLen = (realTXlen > maxlen) ? maxlen: realTXlen;

	memcpy((char*) data, (char *)XBD_response, txLen-CRC16SIZE);
 8000804:	3c02      	subs	r4, #2
 8000806:	4622      	mov	r2, r4
 8000808:	4606      	mov	r6, r0
 800080a:	4608      	mov	r0, r1
 800080c:	4908      	ldr	r1, [pc, #32]	; (8000830 <FRW_msgTraHand+0x40>)
 800080e:	f000 f9f7 	bl	8000c00 <memcpy>
	crc = crc16buffer(data, txLen-CRC16SIZE);                
 8000812:	4628      	mov	r0, r5
 8000814:	b2a1      	uxth	r1, r4
 8000816:	f000 f9a2 	bl	8000b5e <crc16buffer>
 800081a:	4b06      	ldr	r3, [pc, #24]	; (8000834 <FRW_msgTraHand+0x44>)
	uint8_t *target=data+txLen-CRC16SIZE;             
 800081c:	192a      	adds	r2, r5, r4

    // Truncate transmission if greater than maxlen
    txLen = (realTXlen > maxlen) ? maxlen: realTXlen;

	memcpy((char*) data, (char *)XBD_response, txLen-CRC16SIZE);
	crc = crc16buffer(data, txLen-CRC16SIZE);                
 800081e:	8018      	strh	r0, [r3, #0]
	uint8_t *target=data+txLen-CRC16SIZE;             
	PACK_CRC(crc,target);
 8000820:	0a00      	lsrs	r0, r0, #8
 8000822:	5528      	strb	r0, [r5, r4]
 8000824:	881b      	ldrh	r3, [r3, #0]
	//XBD_DEBUG_BUF("FRW_msgTraHand", data, maxlen);
	return maxlen;
}
 8000826:	4630      	mov	r0, r6
    txLen = (realTXlen > maxlen) ? maxlen: realTXlen;

	memcpy((char*) data, (char *)XBD_response, txLen-CRC16SIZE);
	crc = crc16buffer(data, txLen-CRC16SIZE);                
	uint8_t *target=data+txLen-CRC16SIZE;             
	PACK_CRC(crc,target);
 8000828:	7053      	strb	r3, [r2, #1]
	//XBD_DEBUG_BUF("FRW_msgTraHand", data, maxlen);
	return maxlen;
}
 800082a:	bd70      	pop	{r4, r5, r6, pc}
 800082c:	20000aa1 	.word	0x20000aa1
 8000830:	20000998 	.word	0x20000998
 8000834:	2000098c 	.word	0x2000098c

08000838 <main>:


int main(void)
{  
 8000838:	b508      	push	{r3, lr}

	XBD_init();
 800083a:	f000 fa19 	bl	8000c70 <XBD_init>

	XBD_DEBUG("XBD BL "XBX_REVISION" started\r\n");

	while(1)
	{
		XBD_serveCommunication();
 800083e:	f000 fa5d 	bl	8000cfc <XBD_serveCommunication>

	}
 8000842:	e7fc      	b.n	800083e <main+0x6>

08000844 <SystemInit>:
  */
void SystemInit (void)
{
  /* Reset the RCC clock configuration to the default reset state(for debug purpose) */
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8000844:	4b0f      	ldr	r3, [pc, #60]	; (8000884 <SystemInit+0x40>)
 8000846:	681a      	ldr	r2, [r3, #0]
 8000848:	f042 0201 	orr.w	r2, r2, #1
 800084c:	601a      	str	r2, [r3, #0]

  /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
#if !defined(STM32F105xC) && !defined(STM32F107xC)
  RCC->CFGR &= (uint32_t)0xF8FF0000;
 800084e:	6859      	ldr	r1, [r3, #4]
 8000850:	4a0d      	ldr	r2, [pc, #52]	; (8000888 <SystemInit+0x44>)
 8000852:	400a      	ands	r2, r1
 8000854:	605a      	str	r2, [r3, #4]
#else
  RCC->CFGR &= (uint32_t)0xF0FF0000;
#endif /* STM32F105xC */   
  
  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 8000856:	681a      	ldr	r2, [r3, #0]
 8000858:	f022 7284 	bic.w	r2, r2, #17301504	; 0x1080000
 800085c:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8000860:	601a      	str	r2, [r3, #0]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8000862:	681a      	ldr	r2, [r3, #0]
 8000864:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8000868:	601a      	str	r2, [r3, #0]

  /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
  RCC->CFGR &= (uint32_t)0xFF80FFFF;
 800086a:	685a      	ldr	r2, [r3, #4]
 800086c:	f422 02fe 	bic.w	r2, r2, #8323072	; 0x7f0000
 8000870:	605a      	str	r2, [r3, #4]

  /* Reset CFGR2 register */
  RCC->CFGR2 = 0x00000000;      
#else
  /* Disable all interrupts and clear pending bits  */
  RCC->CIR = 0x009F0000;
 8000872:	f44f 021f 	mov.w	r2, #10420224	; 0x9f0000
 8000876:	609a      	str	r2, [r3, #8]
#endif 

#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM. */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH. */
 8000878:	4b04      	ldr	r3, [pc, #16]	; (800088c <SystemInit+0x48>)
 800087a:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 800087e:	609a      	str	r2, [r3, #8]
 8000880:	4770      	bx	lr
 8000882:	bf00      	nop
 8000884:	40021000 	.word	0x40021000
 8000888:	f8ff0000 	.word	0xf8ff0000
 800088c:	e000ed00 	.word	0xe000ed00

08000890 <NMI_Handler>:
  * @brief  This function handles NMI exception.
  * @param  None
  * @retval None
  */
void NMI_Handler(void)
{
 8000890:	4770      	bx	lr

08000892 <HardFault_Handler>:
void HardFault_Handler(void)
{
  /* Go to infinite loop when Hard Fault exception occurs */
  while (1)
  {
  }
 8000892:	e7fe      	b.n	8000892 <HardFault_Handler>

08000894 <MemManage_Handler>:
void MemManage_Handler(void)
{
  /* Go to infinite loop when Memory Manage exception occurs */
  while (1)
  {
  }
 8000894:	e7fe      	b.n	8000894 <MemManage_Handler>

08000896 <BusFault_Handler>:
void BusFault_Handler(void)
{
  /* Go to infinite loop when Bus Fault exception occurs */
  while (1)
  {
  }
 8000896:	e7fe      	b.n	8000896 <BusFault_Handler>

08000898 <UsageFault_Handler>:
void UsageFault_Handler(void)
{
  /* Go to infinite loop when Usage Fault exception occurs */
  while (1)
  {
  }
 8000898:	e7fe      	b.n	8000898 <UsageFault_Handler>

0800089a <SVC_Handler>:
  * @brief  This function handles SVCall exception.
  * @param  None
  * @retval None
  */
void SVC_Handler(void)
{
 800089a:	4770      	bx	lr

0800089c <DebugMon_Handler>:
  * @brief  This function handles Debug Monitor exception.
  * @param  None
  * @retval None
  */
void DebugMon_Handler(void)
{
 800089c:	4770      	bx	lr

0800089e <PendSV_Handler>:
  * @brief  This function handles PendSVC exception.
  * @param  None
  * @retval None
  */
void PendSV_Handler(void)
{
 800089e:	4770      	bx	lr

080008a0 <SysTick_Handler>:
  * @param  None
  * @retval None
  */
void SysTick_Handler(void)
{
  HAL_IncTick();
 80008a0:	f000 be52 	b.w	8001548 <HAL_IncTick>

080008a4 <i2c_init>:
#define I2C_TIMEOUT_ADDR_SLAVE    ((uint32_t)10000)  /*!< Timeout 10 s  */
#define I2C_TIMEOUT_BUSY_FLAG     ((uint32_t)10000)  /*!< Timeout 10 s  */

#ifndef XBD_AF
int i2c_init(void) {
	I2cHandle.Instance             = I2Cx;
 80008a4:	480f      	ldr	r0, [pc, #60]	; (80008e4 <i2c_init+0x40>)
	#ifdef STM32F103xB
	I2cHandle.Init.ClockSpeed      = I2C_SPEEDCLOCK;
 80008a6:	4a10      	ldr	r2, [pc, #64]	; (80008e8 <i2c_init+0x44>)
 80008a8:	4b10      	ldr	r3, [pc, #64]	; (80008ec <i2c_init+0x48>)
#define I2C_TIMEOUT_FLAG          ((uint32_t)35)     /*!< Timeout 35 ms */
#define I2C_TIMEOUT_ADDR_SLAVE    ((uint32_t)10000)  /*!< Timeout 10 s  */
#define I2C_TIMEOUT_BUSY_FLAG     ((uint32_t)10000)  /*!< Timeout 10 s  */

#ifndef XBD_AF
int i2c_init(void) {
 80008aa:	b510      	push	{r4, lr}
	I2cHandle.Init.Timing          = I2C_TIMING;
	#else
	#error "UNDEFINED I2C INIT"	
	#endif
	I2cHandle.Init.OwnAddress1     = I2C_ADDRESS;
	I2cHandle.Init.AddressingMode  = I2C_ADDRESSINGMODE_7BIT;
 80008ac:	f44f 4180 	mov.w	r1, #16384	; 0x4000

#ifndef XBD_AF
int i2c_init(void) {
	I2cHandle.Instance             = I2Cx;
	#ifdef STM32F103xB
	I2cHandle.Init.ClockSpeed      = I2C_SPEEDCLOCK;
 80008b0:	e880 000c 	stmia.w	r0, {r2, r3}
	I2cHandle.Init.DutyCycle       = I2C_DUTYCYCLE;
 80008b4:	2300      	movs	r3, #0
	#elif defined(STM32F091xC)
	I2cHandle.Init.Timing          = I2C_TIMING;
	#else
	#error "UNDEFINED I2C INIT"	
	#endif
	I2cHandle.Init.OwnAddress1     = I2C_ADDRESS;
 80008b6:	22ea      	movs	r2, #234	; 0xea
#ifndef XBD_AF
int i2c_init(void) {
	I2cHandle.Instance             = I2Cx;
	#ifdef STM32F103xB
	I2cHandle.Init.ClockSpeed      = I2C_SPEEDCLOCK;
	I2cHandle.Init.DutyCycle       = I2C_DUTYCYCLE;
 80008b8:	6083      	str	r3, [r0, #8]
	#elif defined(STM32F091xC)
	I2cHandle.Init.Timing          = I2C_TIMING;
	#else
	#error "UNDEFINED I2C INIT"	
	#endif
	I2cHandle.Init.OwnAddress1     = I2C_ADDRESS;
 80008ba:	60c2      	str	r2, [r0, #12]
	I2cHandle.Init.AddressingMode  = I2C_ADDRESSINGMODE_7BIT;
 80008bc:	6101      	str	r1, [r0, #16]
	I2cHandle.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
 80008be:	6143      	str	r3, [r0, #20]
	I2cHandle.Init.OwnAddress2     = I2C_ADDRESS;
 80008c0:	6182      	str	r2, [r0, #24]
	I2cHandle.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
 80008c2:	61c3      	str	r3, [r0, #28]
	I2cHandle.Init.NoStretchMode   = I2C_NOSTRETCH_DISABLE;
 80008c4:	6203      	str	r3, [r0, #32]

	I2cHandle.Instance             = I2Cx;
	

	I2cHandle.State = HAL_I2C_STATE_RESET;
 80008c6:	f880 3035 	strb.w	r3, [r0, #53]	; 0x35
	if(HAL_I2C_Init(&I2cHandle) != HAL_OK)
 80008ca:	f000 fff3 	bl	80018b4 <HAL_I2C_Init>
 80008ce:	4604      	mov	r4, r0
 80008d0:	b120      	cbz	r0, 80008dc <i2c_init+0x38>
	{
		printf_xbd("Failed to initialize i2c\n");
 80008d2:	4807      	ldr	r0, [pc, #28]	; (80008f0 <i2c_init+0x4c>)
 80008d4:	f000 f972 	bl	8000bbc <printf_xbd>
		/* Initialization Error */
		return 1;
 80008d8:	2001      	movs	r0, #1
 80008da:	bd10      	pop	{r4, pc}
	#if defined(STM32F091xC)
	HAL_I2CEx_ConfigAnalogFilter(&I2cHandle,I2C_ANALOGFILTER_ENABLE);
	#elif defined(STM32F103xB)
	#endif

	BSP_LED_Init(LED2);
 80008dc:	f001 f86c 	bl	80019b8 <BSP_LED_Init>

	return 0;
 80008e0:	4620      	mov	r0, r4
}
 80008e2:	bd10      	pop	{r4, pc}
 80008e4:	20000438 	.word	0x20000438
 80008e8:	40005400 	.word	0x40005400
 80008ec:	00061a80 	.word	0x00061a80
 80008f0:	08001db9 	.word	0x08001db9

080008f4 <i2c_set_rx>:
}
#endif

void i2c_set_rx(void (*i2cSlaveRx_func)(uint8_t
            receiveDataLength, uint8_t* recieveData)) {
	i2cSlaveReceive = i2cSlaveRx_func;
 80008f4:	4b01      	ldr	r3, [pc, #4]	; (80008fc <i2c_set_rx+0x8>)
 80008f6:	6018      	str	r0, [r3, #0]
 80008f8:	4770      	bx	lr
 80008fa:	bf00      	nop
 80008fc:	20000550 	.word	0x20000550

08000900 <i2c_set_tx>:
}


void i2c_set_tx(uint8_t (*i2cSlaveTx_func)(uint8_t
            transmitDataLengthMax, uint8_t* transmitData)) {
	i2cSlaveTransmit = i2cSlaveTx_func;
 8000900:	4b01      	ldr	r3, [pc, #4]	; (8000908 <i2c_set_tx+0x8>)
 8000902:	6018      	str	r0, [r3, #0]
 8000904:	4770      	bx	lr
 8000906:	bf00      	nop
 8000908:	2000054c 	.word	0x2000054c

0800090c <i2c_handle>:

void i2c_handle(void) {

	

	I2C_HandleTypeDef *hi2c = i2c_ptr;
 800090c:	4b59      	ldr	r3, [pc, #356]	; (8000a74 <i2c_handle+0x168>)
#if defined(STM32F103xB)
void i2c_reset(void) {
	HAL_I2C_DeInit(&I2cHandle);
}

void i2c_handle(void) {
 800090e:	b5f0      	push	{r4, r5, r6, r7, lr}

	

	I2C_HandleTypeDef *hi2c = i2c_ptr;
 8000910:	681c      	ldr	r4, [r3, #0]
	uint8_t *pData = (uint8_t *)i2c_buf;
	uint32_t Timeout = 100000;
	i2c_size_read = 0;
 8000912:	4d59      	ldr	r5, [pc, #356]	; (8000a78 <i2c_handle+0x16c>)
	I2C_DEBUG("About to handle i2c comms\n");


	if(hi2c->State == HAL_I2C_STATE_READY)
 8000914:	f894 2035 	ldrb.w	r2, [r4, #53]	; 0x35
	

	I2C_HandleTypeDef *hi2c = i2c_ptr;
	uint8_t *pData = (uint8_t *)i2c_buf;
	uint32_t Timeout = 100000;
	i2c_size_read = 0;
 8000918:	2000      	movs	r0, #0
	I2C_DEBUG("About to handle i2c comms\n");


	if(hi2c->State == HAL_I2C_STATE_READY)
 800091a:	b2d2      	uxtb	r2, r2
 800091c:	2a20      	cmp	r2, #32
#if defined(STM32F103xB)
void i2c_reset(void) {
	HAL_I2C_DeInit(&I2cHandle);
}

void i2c_handle(void) {
 800091e:	b085      	sub	sp, #20
	

	I2C_HandleTypeDef *hi2c = i2c_ptr;
	uint8_t *pData = (uint8_t *)i2c_buf;
	uint32_t Timeout = 100000;
	i2c_size_read = 0;
 8000920:	8028      	strh	r0, [r5, #0]
	I2C_DEBUG("About to handle i2c comms\n");


	if(hi2c->State == HAL_I2C_STATE_READY)
 8000922:	f040 80a5 	bne.w	8000a70 <i2c_handle+0x164>
	  {



	    /* Disable Pos */
	    CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
 8000926:	6823      	ldr	r3, [r4, #0]
 8000928:	6819      	ldr	r1, [r3, #0]
 800092a:	f421 6100 	bic.w	r1, r1, #2048	; 0x800
 800092e:	6019      	str	r1, [r3, #0]

	    hi2c->State = HAL_I2C_STATE_BUSY_RX;
 8000930:	2122      	movs	r1, #34	; 0x22
 8000932:	f884 1035 	strb.w	r1, [r4, #53]	; 0x35
	    hi2c->Mode = HAL_I2C_MODE_SLAVE;
 8000936:	f884 2036 	strb.w	r2, [r4, #54]	; 0x36
	    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 800093a:	63a0      	str	r0, [r4, #56]	; 0x38

	    /* Enable Address Acknowledge */
	    SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 800093c:	681a      	ldr	r2, [r3, #0]
 800093e:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8000942:	601a      	str	r2, [r3, #0]
static HAL_StatusTypeDef I2C_WaitOnFlagUntilTimeout_xbd(I2C_HandleTypeDef *hi2c, uint32_t Flag, FlagStatus Status, uint32_t Timeout)
{
  uint32_t tickstart = 0;

  /* Get tick */
  tickstart = HAL_GetTick();
 8000944:	f000 fe08 	bl	8001558 <HAL_GetTick>
 8000948:	4606      	mov	r6, r0

  /* Wait until flag is set */
  if(Status == RESET)
  {
    while(__HAL_I2C_GET_FLAG(hi2c, Flag) == RESET)
 800094a:	6823      	ldr	r3, [r4, #0]
 800094c:	695a      	ldr	r2, [r3, #20]
 800094e:	0790      	lsls	r0, r2, #30
 8000950:	d40c      	bmi.n	800096c <i2c_handle+0x60>
    {
      /* Check for the Timeout */
      if(Timeout != HAL_MAX_DELAY)
      {
        if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
 8000952:	f000 fe01 	bl	8001558 <HAL_GetTick>
 8000956:	4b49      	ldr	r3, [pc, #292]	; (8000a7c <i2c_handle+0x170>)
 8000958:	1b80      	subs	r0, r0, r6
 800095a:	4298      	cmp	r0, r3
 800095c:	d9f5      	bls.n	800094a <i2c_handle+0x3e>
        {
          hi2c->State= HAL_I2C_STATE_READY;
 800095e:	2320      	movs	r3, #32
 8000960:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35

          /* Process Unlocked */
          __HAL_UNLOCK(hi2c);
 8000964:	2300      	movs	r3, #0
 8000966:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
 800096a:	e081      	b.n	8000a70 <i2c_handle+0x164>
	   }
	   pData = (uint8_t *)i2c_buf;
	   I2C_DEBUG("received addr flag\n");

	   /* Clear ADDR flag */
	   __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 800096c:	695a      	ldr	r2, [r3, #20]
 800096e:	9201      	str	r2, [sp, #4]
 8000970:	699a      	ldr	r2, [r3, #24]
 8000972:	9201      	str	r2, [sp, #4]
 8000974:	9a01      	ldr	r2, [sp, #4]

	  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET && __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == RESET);
 8000976:	695a      	ldr	r2, [r3, #20]
 8000978:	0611      	lsls	r1, r2, #24
 800097a:	d402      	bmi.n	8000982 <i2c_handle+0x76>
 800097c:	695a      	ldr	r2, [r3, #20]
 800097e:	0652      	lsls	r2, r2, #25
 8000980:	d5f9      	bpl.n	8000976 <i2c_handle+0x6a>

	   if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET) {
 8000982:	695a      	ldr	r2, [r3, #20]
 8000984:	f012 0640 	ands.w	r6, r2, #64	; 0x40
 8000988:	d036      	beq.n	80009f8 <i2c_handle+0xec>
 800098a:	882f      	ldrh	r7, [r5, #0]
 800098c:	4e3c      	ldr	r6, [pc, #240]	; (8000a80 <i2c_handle+0x174>)
 800098e:	4630      	mov	r0, r6
 8000990:	1bbb      	subs	r3, r7, r6
 8000992:	4403      	add	r3, r0
		   I2C_DEBUG("Master is attempting to send\n");
		   uint8_t rcv = 1;
		   while (rcv == 1) {
			   while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == RESET)
 8000994:	6822      	ldr	r2, [r4, #0]
 8000996:	b29b      	uxth	r3, r3
 8000998:	6951      	ldr	r1, [r2, #20]
 800099a:	f011 0140 	ands.w	r1, r1, #64	; 0x40
 800099e:	d119      	bne.n	80009d4 <i2c_handle+0xc8>
				{

				  /* Check if a STOPF is detected */
				  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET)
 80009a0:	f8d2 e014 	ldr.w	lr, [r2, #20]
 80009a4:	f01e 0f10 	tst.w	lr, #16
 80009a8:	d0f6      	beq.n	8000998 <i2c_handle+0x8c>
 80009aa:	802b      	strh	r3, [r5, #0]
				  {
					/* Clear STOP Flag */
					__HAL_I2C_CLEAR_STOPFLAG(hi2c);
 80009ac:	6953      	ldr	r3, [r2, #20]
 80009ae:	9302      	str	r3, [sp, #8]
 80009b0:	6813      	ldr	r3, [r2, #0]
 80009b2:	f043 0301 	orr.w	r3, r3, #1
 80009b6:	6013      	str	r3, [r2, #0]
 80009b8:	9302      	str	r3, [sp, #8]
 80009ba:	9b02      	ldr	r3, [sp, #8]

					//CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
					hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
					hi2c->State= HAL_I2C_STATE_READY;
 80009bc:	2320      	movs	r3, #32
				  {
					/* Clear STOP Flag */
					__HAL_I2C_CLEAR_STOPFLAG(hi2c);

					//CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
					hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 80009be:	63a1      	str	r1, [r4, #56]	; 0x38
					hi2c->State= HAL_I2C_STATE_READY;
 80009c0:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35

					/* Process Unlocked */

					I2C_DEBUG("Received message from Master\n");
					// Make sure to clear all reads
					(*pData++) = hi2c->Instance->DR;
 80009c4:	6913      	ldr	r3, [r2, #16]
					I2C_DEBUG(i2c_buf);
					i2cSlaveReceive(i2c_size_read, i2c_buf);
 80009c6:	492e      	ldr	r1, [pc, #184]	; (8000a80 <i2c_handle+0x174>)

					/* Process Unlocked */

					I2C_DEBUG("Received message from Master\n");
					// Make sure to clear all reads
					(*pData++) = hi2c->Instance->DR;
 80009c8:	7003      	strb	r3, [r0, #0]
					I2C_DEBUG(i2c_buf);
					i2cSlaveReceive(i2c_size_read, i2c_buf);
 80009ca:	4b2e      	ldr	r3, [pc, #184]	; (8000a84 <i2c_handle+0x178>)
 80009cc:	7828      	ldrb	r0, [r5, #0]
 80009ce:	681b      	ldr	r3, [r3, #0]
 80009d0:	4798      	blx	r3
					rcv = 0;
					return;
 80009d2:	e04d      	b.n	8000a70 <i2c_handle+0x164>
				  }
				}
			   /* Read data from DR */
			(*pData++) = hi2c->Instance->DR;
 80009d4:	4601      	mov	r1, r0
 80009d6:	6912      	ldr	r2, [r2, #16]
 80009d8:	f801 2b01 	strb.w	r2, [r1], #1
			i2c_size_read++;

			if((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET))
 80009dc:	6822      	ldr	r2, [r4, #0]
 80009de:	f8d2 e014 	ldr.w	lr, [r2, #20]
 80009e2:	f01e 0f04 	tst.w	lr, #4
 80009e6:	d005      	beq.n	80009f4 <i2c_handle+0xe8>
			{
			/* Read data from DR */
			(*pData++) = hi2c->Instance->DR;
 80009e8:	6912      	ldr	r2, [r2, #16]
				i2c_size_read++;
 80009ea:	3302      	adds	r3, #2
			i2c_size_read++;

			if((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET))
			{
			/* Read data from DR */
			(*pData++) = hi2c->Instance->DR;
 80009ec:	1c86      	adds	r6, r0, #2
 80009ee:	7042      	strb	r2, [r0, #1]
				i2c_size_read++;
 80009f0:	b29f      	uxth	r7, r3
 80009f2:	e7cc      	b.n	800098e <i2c_handle+0x82>
 80009f4:	4608      	mov	r0, r1
 80009f6:	e7cb      	b.n	8000990 <i2c_handle+0x84>
			}

	}

	   } else if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == SET) {
 80009f8:	695b      	ldr	r3, [r3, #20]
 80009fa:	061f      	lsls	r7, r3, #24
 80009fc:	d538      	bpl.n	8000a70 <i2c_handle+0x164>
		   I2C_DEBUG("Master is attempting to receive\n");
		   uint8_t resp_size = i2cSlaveTransmit(160, i2c_buf);
 80009fe:	4b22      	ldr	r3, [pc, #136]	; (8000a88 <i2c_handle+0x17c>)
 8000a00:	20a0      	movs	r0, #160	; 0xa0
 8000a02:	681b      	ldr	r3, [r3, #0]
 8000a04:	491e      	ldr	r1, [pc, #120]	; (8000a80 <i2c_handle+0x174>)
 8000a06:	4798      	blx	r3
		   uint8_t tx = 1;
		   volatile unsigned int sent = 0;
		   while (tx == 1) {
			   while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 8000a08:	6823      	ldr	r3, [r4, #0]
	    /* Wait until ADDR flag is set */
	   if(I2C_WaitOnFlagUntilTimeout_xbd(hi2c, I2C_FLAG_ADDR, RESET, Timeout) != HAL_OK)
	   {
		 return;
	   }
	   pData = (uint8_t *)i2c_buf;
 8000a0a:	4a1d      	ldr	r2, [pc, #116]	; (8000a80 <i2c_handle+0x174>)

	   } else if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == SET) {
		   I2C_DEBUG("Master is attempting to receive\n");
		   uint8_t resp_size = i2cSlaveTransmit(160, i2c_buf);
		   uint8_t tx = 1;
		   volatile unsigned int sent = 0;
 8000a0c:	9603      	str	r6, [sp, #12]
		   while (tx == 1) {
			   while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 8000a0e:	6959      	ldr	r1, [r3, #20]
 8000a10:	f011 0180 	ands.w	r1, r1, #128	; 0x80
 8000a14:	d11d      	bne.n	8000a52 <i2c_handle+0x146>
				{
				   if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 8000a16:	6958      	ldr	r0, [r3, #20]
 8000a18:	0546      	lsls	r6, r0, #21
 8000a1a:	d50d      	bpl.n	8000a38 <i2c_handle+0x12c>
				    {
					   /* Clear AF flag */
					 __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8000a1c:	695a      	ldr	r2, [r3, #20]
 8000a1e:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8000a22:	615a      	str	r2, [r3, #20]

					hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
					hi2c->State= HAL_I2C_STATE_READY;
 8000a24:	2320      	movs	r3, #32
				   if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
				    {
					   /* Clear AF flag */
					 __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);

					hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8000a26:	63a1      	str	r1, [r4, #56]	; 0x38
					hi2c->State= HAL_I2C_STATE_READY;
 8000a28:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35

					if (sent > 0) {
 8000a2c:	9b03      	ldr	r3, [sp, #12]
 8000a2e:	b1fb      	cbz	r3, 8000a70 <i2c_handle+0x164>
						print_int_xbd(sent);
 8000a30:	9803      	ldr	r0, [sp, #12]
 8000a32:	f000 f8d3 	bl	8000bdc <print_int_xbd>
 8000a36:	e01b      	b.n	8000a70 <i2c_handle+0x164>

					I2C_DEBUG("Transmitted message to Master\n");
					//CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
					tx = 0;
					return;
				  } else if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ADDR) == SET) {
 8000a38:	6959      	ldr	r1, [r3, #20]
 8000a3a:	078d      	lsls	r5, r1, #30
 8000a3c:	d5e7      	bpl.n	8000a0e <i2c_handle+0x102>
					// Got stuck in loop
					printf_xbd("Error, stuck in loop\n");
 8000a3e:	4813      	ldr	r0, [pc, #76]	; (8000a8c <i2c_handle+0x180>)
 8000a40:	f000 f8bc 	bl	8000bbc <printf_xbd>
					HAL_I2C_DeInit(&I2cHandle);
 8000a44:	4812      	ldr	r0, [pc, #72]	; (8000a90 <i2c_handle+0x184>)
 8000a46:	f000 ff9f 	bl	8001988 <HAL_I2C_DeInit>
					HAL_I2C_Init(&I2cHandle);
 8000a4a:	4811      	ldr	r0, [pc, #68]	; (8000a90 <i2c_handle+0x184>)
 8000a4c:	f000 ff32 	bl	80018b4 <HAL_I2C_Init>
					return;
 8000a50:	e00e      	b.n	8000a70 <i2c_handle+0x164>
				  }
				}

			   /* Write data to DR */
				hi2c->Instance->DR = (*pData++);
 8000a52:	4611      	mov	r1, r2
 8000a54:	f811 0b01 	ldrb.w	r0, [r1], #1
 8000a58:	6118      	str	r0, [r3, #16]
				sent++;
 8000a5a:	9803      	ldr	r0, [sp, #12]
 8000a5c:	3001      	adds	r0, #1
 8000a5e:	9003      	str	r0, [sp, #12]

				 if((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET))
 8000a60:	6958      	ldr	r0, [r3, #20]
 8000a62:	0740      	lsls	r0, r0, #29
				 {
				   /* Write data to DR */
				   hi2c->Instance->DR = (*pData++);
 8000a64:	bf49      	itett	mi
 8000a66:	7851      	ldrbmi	r1, [r2, #1]
 8000a68:	460a      	movpl	r2, r1
 8000a6a:	6119      	strmi	r1, [r3, #16]
 8000a6c:	3202      	addmi	r2, #2
 8000a6e:	e7ce      	b.n	8000a0e <i2c_handle+0x102>
				 }
		   }
	   }

	  }
}
 8000a70:	b005      	add	sp, #20
 8000a72:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000a74:	20000430 	.word	0x20000430
 8000a78:	20000496 	.word	0x20000496
 8000a7c:	000186a0 	.word	0x000186a0
 8000a80:	20000498 	.word	0x20000498
 8000a84:	20000550 	.word	0x20000550
 8000a88:	2000054c 	.word	0x2000054c
 8000a8c:	08001dd3 	.word	0x08001dd3
 8000a90:	20000438 	.word	0x20000438

08000a94 <HAL_I2C_MspInit>:
{
  GPIO_InitTypeDef  GPIO_InitStruct;
  
  /*##-1- Enable peripherals and GPIO Clocks #################################*/
  /* Enable GPIO TX/RX clock */
  I2Cx_SCL_GPIO_CLK_ENABLE();
 8000a94:	4b1a      	ldr	r3, [pc, #104]	; (8000b00 <HAL_I2C_MspInit+0x6c>)
  *           - NVIC configuration for DMA interrupt request enable
  * @param hi2c: I2C handle pointer
  * @retval None
  */
void HAL_I2C_MspInit(I2C_HandleTypeDef *hi2c)
{
 8000a96:	b510      	push	{r4, lr}
  GPIO_InitTypeDef  GPIO_InitStruct;
  
  /*##-1- Enable peripherals and GPIO Clocks #################################*/
  /* Enable GPIO TX/RX clock */
  I2Cx_SCL_GPIO_CLK_ENABLE();
 8000a98:	699a      	ldr	r2, [r3, #24]
  *           - NVIC configuration for DMA interrupt request enable
  * @param hi2c: I2C handle pointer
  * @retval None
  */
void HAL_I2C_MspInit(I2C_HandleTypeDef *hi2c)
{
 8000a9a:	b088      	sub	sp, #32
  GPIO_InitTypeDef  GPIO_InitStruct;
  
  /*##-1- Enable peripherals and GPIO Clocks #################################*/
  /* Enable GPIO TX/RX clock */
  I2Cx_SCL_GPIO_CLK_ENABLE();
 8000a9c:	f042 0208 	orr.w	r2, r2, #8
 8000aa0:	619a      	str	r2, [r3, #24]
 8000aa2:	699a      	ldr	r2, [r3, #24]
  /* I2C TX GPIO pin configuration  */
  GPIO_InitStruct.Pin       = I2Cx_SCL_PIN;
  GPIO_InitStruct.Mode      = GPIO_MODE_AF_OD;
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
  GPIO_InitStruct.Speed     = GPIO_SPEED_FREQ_HIGH;
  HAL_GPIO_Init(I2Cx_SCL_GPIO_PORT, &GPIO_InitStruct);
 8000aa4:	4c17      	ldr	r4, [pc, #92]	; (8000b04 <HAL_I2C_MspInit+0x70>)
{
  GPIO_InitTypeDef  GPIO_InitStruct;
  
  /*##-1- Enable peripherals and GPIO Clocks #################################*/
  /* Enable GPIO TX/RX clock */
  I2Cx_SCL_GPIO_CLK_ENABLE();
 8000aa6:	f002 0208 	and.w	r2, r2, #8
 8000aaa:	9201      	str	r2, [sp, #4]
 8000aac:	9a01      	ldr	r2, [sp, #4]
  I2Cx_SDA_GPIO_CLK_ENABLE();
 8000aae:	699a      	ldr	r2, [r3, #24]
  /* I2C TX GPIO pin configuration  */
  GPIO_InitStruct.Pin       = I2Cx_SCL_PIN;
  GPIO_InitStruct.Mode      = GPIO_MODE_AF_OD;
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
  GPIO_InitStruct.Speed     = GPIO_SPEED_FREQ_HIGH;
  HAL_GPIO_Init(I2Cx_SCL_GPIO_PORT, &GPIO_InitStruct);
 8000ab0:	4620      	mov	r0, r4
  GPIO_InitTypeDef  GPIO_InitStruct;
  
  /*##-1- Enable peripherals and GPIO Clocks #################################*/
  /* Enable GPIO TX/RX clock */
  I2Cx_SCL_GPIO_CLK_ENABLE();
  I2Cx_SDA_GPIO_CLK_ENABLE();
 8000ab2:	f042 0208 	orr.w	r2, r2, #8
 8000ab6:	619a      	str	r2, [r3, #24]
 8000ab8:	699a      	ldr	r2, [r3, #24]
  /* I2C TX GPIO pin configuration  */
  GPIO_InitStruct.Pin       = I2Cx_SCL_PIN;
  GPIO_InitStruct.Mode      = GPIO_MODE_AF_OD;
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
  GPIO_InitStruct.Speed     = GPIO_SPEED_FREQ_HIGH;
  HAL_GPIO_Init(I2Cx_SCL_GPIO_PORT, &GPIO_InitStruct);
 8000aba:	a904      	add	r1, sp, #16
  GPIO_InitTypeDef  GPIO_InitStruct;
  
  /*##-1- Enable peripherals and GPIO Clocks #################################*/
  /* Enable GPIO TX/RX clock */
  I2Cx_SCL_GPIO_CLK_ENABLE();
  I2Cx_SDA_GPIO_CLK_ENABLE();
 8000abc:	f002 0208 	and.w	r2, r2, #8
 8000ac0:	9202      	str	r2, [sp, #8]
 8000ac2:	9a02      	ldr	r2, [sp, #8]
  /* Enable I2Cx clock */
  I2Cx_CLK_ENABLE(); 
 8000ac4:	69da      	ldr	r2, [r3, #28]
 8000ac6:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 8000aca:	61da      	str	r2, [r3, #28]
 8000acc:	69db      	ldr	r3, [r3, #28]
 8000ace:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8000ad2:	9303      	str	r3, [sp, #12]
 8000ad4:	9b03      	ldr	r3, [sp, #12]

  /*##-2- Configure peripheral GPIO ##########################################*/  
  /* I2C TX GPIO pin configuration  */
  GPIO_InitStruct.Pin       = I2Cx_SCL_PIN;
 8000ad6:	f44f 7380 	mov.w	r3, #256	; 0x100
 8000ada:	9304      	str	r3, [sp, #16]
  GPIO_InitStruct.Mode      = GPIO_MODE_AF_OD;
 8000adc:	2312      	movs	r3, #18
 8000ade:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
 8000ae0:	2301      	movs	r3, #1
 8000ae2:	9306      	str	r3, [sp, #24]
  GPIO_InitStruct.Speed     = GPIO_SPEED_FREQ_HIGH;
 8000ae4:	2303      	movs	r3, #3
 8000ae6:	9307      	str	r3, [sp, #28]
  HAL_GPIO_Init(I2Cx_SCL_GPIO_PORT, &GPIO_InitStruct);
 8000ae8:	f000 fdb2 	bl	8001650 <HAL_GPIO_Init>
    
  /* I2C RX GPIO pin configuration  */
  GPIO_InitStruct.Pin       = I2Cx_SDA_PIN;
 8000aec:	f44f 7300 	mov.w	r3, #512	; 0x200
  HAL_GPIO_Init(I2Cx_SDA_GPIO_PORT, &GPIO_InitStruct);
 8000af0:	4620      	mov	r0, r4
 8000af2:	a904      	add	r1, sp, #16
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
  GPIO_InitStruct.Speed     = GPIO_SPEED_FREQ_HIGH;
  HAL_GPIO_Init(I2Cx_SCL_GPIO_PORT, &GPIO_InitStruct);
    
  /* I2C RX GPIO pin configuration  */
  GPIO_InitStruct.Pin       = I2Cx_SDA_PIN;
 8000af4:	9304      	str	r3, [sp, #16]
  HAL_GPIO_Init(I2Cx_SDA_GPIO_PORT, &GPIO_InitStruct);
 8000af6:	f000 fdab 	bl	8001650 <HAL_GPIO_Init>
}
 8000afa:	b008      	add	sp, #32
 8000afc:	bd10      	pop	{r4, pc}
 8000afe:	bf00      	nop
 8000b00:	40021000 	.word	0x40021000
 8000b04:	40010c00 	.word	0x40010c00

08000b08 <HAL_I2C_MspDeInit>:
  */
void HAL_I2C_MspDeInit(I2C_HandleTypeDef *hi2c)
{
  
  /*##-1- Reset peripherals ##################################################*/
  I2Cx_FORCE_RESET();
 8000b08:	4b0b      	ldr	r3, [pc, #44]	; (8000b38 <HAL_I2C_MspDeInit+0x30>)
  *          - Revert GPIO, DMA and NVIC configuration to their default state
  * @param hi2c: I2C handle pointer
  * @retval None
  */
void HAL_I2C_MspDeInit(I2C_HandleTypeDef *hi2c)
{
 8000b0a:	b510      	push	{r4, lr}
  
  /*##-1- Reset peripherals ##################################################*/
  I2Cx_FORCE_RESET();
 8000b0c:	691a      	ldr	r2, [r3, #16]
  I2Cx_RELEASE_RESET();

  /*##-2- Disable peripherals and GPIO Clocks #################################*/
  /* Configure I2C Tx as alternate function  */
  HAL_GPIO_DeInit(I2Cx_SCL_GPIO_PORT, I2Cx_SCL_PIN);
 8000b0e:	4c0b      	ldr	r4, [pc, #44]	; (8000b3c <HAL_I2C_MspDeInit+0x34>)
  */
void HAL_I2C_MspDeInit(I2C_HandleTypeDef *hi2c)
{
  
  /*##-1- Reset peripherals ##################################################*/
  I2Cx_FORCE_RESET();
 8000b10:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 8000b14:	611a      	str	r2, [r3, #16]
  I2Cx_RELEASE_RESET();
 8000b16:	691a      	ldr	r2, [r3, #16]

  /*##-2- Disable peripherals and GPIO Clocks #################################*/
  /* Configure I2C Tx as alternate function  */
  HAL_GPIO_DeInit(I2Cx_SCL_GPIO_PORT, I2Cx_SCL_PIN);
 8000b18:	4620      	mov	r0, r4
void HAL_I2C_MspDeInit(I2C_HandleTypeDef *hi2c)
{
  
  /*##-1- Reset peripherals ##################################################*/
  I2Cx_FORCE_RESET();
  I2Cx_RELEASE_RESET();
 8000b1a:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000

  /*##-2- Disable peripherals and GPIO Clocks #################################*/
  /* Configure I2C Tx as alternate function  */
  HAL_GPIO_DeInit(I2Cx_SCL_GPIO_PORT, I2Cx_SCL_PIN);
 8000b1e:	f44f 7180 	mov.w	r1, #256	; 0x100
void HAL_I2C_MspDeInit(I2C_HandleTypeDef *hi2c)
{
  
  /*##-1- Reset peripherals ##################################################*/
  I2Cx_FORCE_RESET();
  I2Cx_RELEASE_RESET();
 8000b22:	611a      	str	r2, [r3, #16]

  /*##-2- Disable peripherals and GPIO Clocks #################################*/
  /* Configure I2C Tx as alternate function  */
  HAL_GPIO_DeInit(I2Cx_SCL_GPIO_PORT, I2Cx_SCL_PIN);
 8000b24:	f000 fe5a 	bl	80017dc <HAL_GPIO_DeInit>
  /* Configure I2C Rx as alternate function  */
  HAL_GPIO_DeInit(I2Cx_SDA_GPIO_PORT, I2Cx_SDA_PIN);
 8000b28:	4620      	mov	r0, r4
}
 8000b2a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  /*##-2- Disable peripherals and GPIO Clocks #################################*/
  /* Configure I2C Tx as alternate function  */
  HAL_GPIO_DeInit(I2Cx_SCL_GPIO_PORT, I2Cx_SCL_PIN);
  /* Configure I2C Rx as alternate function  */
  HAL_GPIO_DeInit(I2Cx_SDA_GPIO_PORT, I2Cx_SDA_PIN);
 8000b2e:	f44f 7100 	mov.w	r1, #512	; 0x200
 8000b32:	f000 be53 	b.w	80017dc <HAL_GPIO_DeInit>
 8000b36:	bf00      	nop
 8000b38:	40021000 	.word	0x40021000
 8000b3c:	40010c00 	.word	0x40010c00

08000b40 <crc16_update>:

uint16_t crc16_update(uint16_t crc, uint8_t a)
{
    int i;

    crc ^= a;
 8000b40:	4048      	eors	r0, r1
 8000b42:	2308      	movs	r3, #8
    for (i = 0; i < 8; ++i)
    {
        if (crc & 1)
 8000b44:	f010 0f01 	tst.w	r0, #1
 8000b48:	ea4f 0050 	mov.w	r0, r0, lsr #1
            crc = (crc >> 1) ^ 0xA001;
 8000b4c:	bf1a      	itte	ne
 8000b4e:	f480 4020 	eorne.w	r0, r0, #40960	; 0xa000
 8000b52:	f080 0001 	eorne.w	r0, r0, #1
        else
            crc = (crc >> 1);
 8000b56:	b280      	uxtheq	r0, r0
uint16_t crc16_update(uint16_t crc, uint8_t a)
{
    int i;

    crc ^= a;
    for (i = 0; i < 8; ++i)
 8000b58:	3b01      	subs	r3, #1
 8000b5a:	d1f3      	bne.n	8000b44 <crc16_update+0x4>
            crc = (crc >> 1) ^ 0xA001;
        else
            crc = (crc >> 1);
    }
    return crc;
}
 8000b5c:	4770      	bx	lr

08000b5e <crc16buffer>:


uint16_t crc16buffer(const uint8_t *data, uint16_t len) {
 8000b5e:	3901      	subs	r1, #1
 8000b60:	b538      	push	{r3, r4, r5, lr}
 8000b62:	1e45      	subs	r5, r0, #1
 8000b64:	1844      	adds	r4, r0, r1
	uint16_t crc = 0xffff, ctr;
 8000b66:	f64f 70ff 	movw	r0, #65535	; 0xffff

	for (ctr = 0; ctr < len; ++ctr) {
 8000b6a:	42a5      	cmp	r5, r4
 8000b6c:	d004      	beq.n	8000b78 <crc16buffer+0x1a>
		crc = crc16_update(crc, data[ctr]);
 8000b6e:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8000b72:	f7ff ffe5 	bl	8000b40 <crc16_update>
 8000b76:	e7f8      	b.n	8000b6a <crc16buffer+0xc>
	}
	
	return crc;
}
 8000b78:	bd38      	pop	{r3, r4, r5, pc}
	...

08000b7c <printf_gdb>:
char * print_ptr;
unsigned int integer_print;
// Set optimization to 0 so this doesn't get removed by compiler
int __attribute__((optimize("O0")))
printf_gdb(char *str)
{
 8000b7c:	b480      	push	{r7}
 8000b7e:	b083      	sub	sp, #12
 8000b80:	af00      	add	r7, sp, #0
 8000b82:	6078      	str	r0, [r7, #4]
	print_ptr = str;
 8000b84:	4a04      	ldr	r2, [pc, #16]	; (8000b98 <printf_gdb+0x1c>)
 8000b86:	687b      	ldr	r3, [r7, #4]
 8000b88:	6013      	str	r3, [r2, #0]
	return 0;
 8000b8a:	2300      	movs	r3, #0
}
 8000b8c:	4618      	mov	r0, r3
 8000b8e:	370c      	adds	r7, #12
 8000b90:	46bd      	mov	sp, r7
 8000b92:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000b96:	4770      	bx	lr
 8000b98:	20000aa4 	.word	0x20000aa4

08000b9c <print_int_gdb>:

int __attribute__((optimize("O0")))
print_int_gdb(unsigned int print_int)
{
 8000b9c:	b480      	push	{r7}
 8000b9e:	b083      	sub	sp, #12
 8000ba0:	af00      	add	r7, sp, #0
 8000ba2:	6078      	str	r0, [r7, #4]
	integer_print = print_int;
 8000ba4:	4a04      	ldr	r2, [pc, #16]	; (8000bb8 <print_int_gdb+0x1c>)
 8000ba6:	687b      	ldr	r3, [r7, #4]
 8000ba8:	6013      	str	r3, [r2, #0]
	return 0;
 8000baa:	2300      	movs	r3, #0
}
 8000bac:	4618      	mov	r0, r3
 8000bae:	370c      	adds	r7, #12
 8000bb0:	46bd      	mov	sp, r7
 8000bb2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000bb6:	4770      	bx	lr
 8000bb8:	20000aa8 	.word	0x20000aa8

08000bbc <printf_xbd>:

void __attribute__((optimize("O0")))
printf_xbd(char *str)
{
 8000bbc:	b580      	push	{r7, lr}
 8000bbe:	b082      	sub	sp, #8
 8000bc0:	af00      	add	r7, sp, #0
 8000bc2:	6078      	str	r0, [r7, #4]
	print_ptr = str;
 8000bc4:	4a04      	ldr	r2, [pc, #16]	; (8000bd8 <printf_xbd+0x1c>)
 8000bc6:	687b      	ldr	r3, [r7, #4]
 8000bc8:	6013      	str	r3, [r2, #0]
	printf_gdb(str);
 8000bca:	6878      	ldr	r0, [r7, #4]
 8000bcc:	f7ff ffd6 	bl	8000b7c <printf_gdb>
}
 8000bd0:	3708      	adds	r7, #8
 8000bd2:	46bd      	mov	sp, r7
 8000bd4:	bd80      	pop	{r7, pc}
 8000bd6:	bf00      	nop
 8000bd8:	20000aa4 	.word	0x20000aa4

08000bdc <print_int_xbd>:

int __attribute__((optimize("O0")))
print_int_xbd(unsigned int print_int)
{
 8000bdc:	b580      	push	{r7, lr}
 8000bde:	b082      	sub	sp, #8
 8000be0:	af00      	add	r7, sp, #0
 8000be2:	6078      	str	r0, [r7, #4]
	integer_print = print_int;
 8000be4:	4a05      	ldr	r2, [pc, #20]	; (8000bfc <print_int_xbd+0x20>)
 8000be6:	687b      	ldr	r3, [r7, #4]
 8000be8:	6013      	str	r3, [r2, #0]
	print_int_gdb(print_int);
 8000bea:	6878      	ldr	r0, [r7, #4]
 8000bec:	f7ff ffd6 	bl	8000b9c <print_int_gdb>
	return 0;
 8000bf0:	2300      	movs	r3, #0
}
 8000bf2:	4618      	mov	r0, r3
 8000bf4:	3708      	adds	r7, #8
 8000bf6:	46bd      	mov	sp, r7
 8000bf8:	bd80      	pop	{r7, pc}
 8000bfa:	bf00      	nop
 8000bfc:	20000aa8 	.word	0x20000aa8

08000c00 <memcpy>:

void memcpy(void *dst, void *src, uint32_t size)
{
 8000c00:	b510      	push	{r4, lr}
	unsigned int i = 0;
	for (i = 0; i < size; i++) {
 8000c02:	2300      	movs	r3, #0
 8000c04:	4293      	cmp	r3, r2
 8000c06:	d003      	beq.n	8000c10 <memcpy+0x10>
		((char *)dst)[i] = ((char *)src)[i];
 8000c08:	5ccc      	ldrb	r4, [r1, r3]
 8000c0a:	54c4      	strb	r4, [r0, r3]
}

void memcpy(void *dst, void *src, uint32_t size)
{
	unsigned int i = 0;
	for (i = 0; i < size; i++) {
 8000c0c:	3301      	adds	r3, #1
 8000c0e:	e7f9      	b.n	8000c04 <memcpy+0x4>
		((char *)dst)[i] = ((char *)src)[i];
	}
}
 8000c10:	bd10      	pop	{r4, pc}

08000c12 <strcpy>:

void strcpy(char *dst, const char *src)
{
	unsigned int i = 0;
	for (i = 0; ((char *)src)[i] != 0; i++) {
 8000c12:	2300      	movs	r3, #0
 8000c14:	5cca      	ldrb	r2, [r1, r3]
		((char *)dst)[i] = ((char *)src)[i];
 8000c16:	54c2      	strb	r2, [r0, r3]
}

void strcpy(char *dst, const char *src)
{
	unsigned int i = 0;
	for (i = 0; ((char *)src)[i] != 0; i++) {
 8000c18:	b10a      	cbz	r2, 8000c1e <strcpy+0xc>
 8000c1a:	3301      	adds	r3, #1
 8000c1c:	e7fa      	b.n	8000c14 <strcpy+0x2>
		((char *)dst)[i] = ((char *)src)[i];
	}
	((char *)dst)[i] = 0;
 8000c1e:	4770      	bx	lr

08000c20 <SystemClock_Config>:
}
#if defined(STM32F103xB)
void SystemClock_Config(void)
{
 8000c20:	b510      	push	{r4, lr}
 8000c22:	b090      	sub	sp, #64	; 0x40
  RCC_ClkInitTypeDef clkinitstruct = {0};
 8000c24:	2100      	movs	r1, #0
 8000c26:	2214      	movs	r2, #20
 8000c28:	a801      	add	r0, sp, #4
 8000c2a:	f7ff fb11 	bl	8000250 <memset>
  RCC_OscInitTypeDef oscinitstruct = {0};
 8000c2e:	a806      	add	r0, sp, #24
 8000c30:	2100      	movs	r1, #0
 8000c32:	2228      	movs	r2, #40	; 0x28
 8000c34:	f7ff fb0c 	bl	8000250 <memset>
  /* PREDIV1 configuration: PREDIV1CLK = PLLCLK / HSEPredivValue = 16 / 1 = 16 MHz */
  /* Enable HSI and activate PLL with HSi_DIV2 as source */
  oscinitstruct.OscillatorType  = RCC_OSCILLATORTYPE_HSI;
  oscinitstruct.HSEState        = RCC_HSE_OFF;
  oscinitstruct.LSEState        = RCC_LSE_OFF;
  oscinitstruct.HSIState        = RCC_HSI_ON;
 8000c38:	2301      	movs	r3, #1
 8000c3a:	930a      	str	r3, [sp, #40]	; 0x28
  oscinitstruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
 8000c3c:	2310      	movs	r3, #16

  /* Configure PLL ------------------------------------------------------*/
  /* PLL configuration: PLLCLK = (HSI / 2) * PLLMUL = (8 / 2) * 4 = 16 MHz */
  /* PREDIV1 configuration: PREDIV1CLK = PLLCLK / HSEPredivValue = 16 / 1 = 16 MHz */
  /* Enable HSI and activate PLL with HSi_DIV2 as source */
  oscinitstruct.OscillatorType  = RCC_OSCILLATORTYPE_HSI;
 8000c3e:	2402      	movs	r4, #2
  oscinitstruct.HSEState        = RCC_HSE_OFF;
  oscinitstruct.LSEState        = RCC_LSE_OFF;
  oscinitstruct.HSIState        = RCC_HSI_ON;
  oscinitstruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
 8000c40:	930b      	str	r3, [sp, #44]	; 0x2c
  oscinitstruct.HSEPredivValue    = RCC_HSE_PREDIV_DIV1;
  oscinitstruct.PLL.PLLState    = RCC_PLL_ON;
  oscinitstruct.PLL.PLLSource   = RCC_PLLSOURCE_HSI_DIV2;
  oscinitstruct.PLL.PLLMUL      = RCC_PLL_MUL4;

  if (HAL_RCC_OscConfig(&oscinitstruct)!= HAL_OK)
 8000c42:	a806      	add	r0, sp, #24
  oscinitstruct.HSIState        = RCC_HSI_ON;
  oscinitstruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
  oscinitstruct.HSEPredivValue    = RCC_HSE_PREDIV_DIV1;
  oscinitstruct.PLL.PLLState    = RCC_PLL_ON;
  oscinitstruct.PLL.PLLSource   = RCC_PLLSOURCE_HSI_DIV2;
  oscinitstruct.PLL.PLLMUL      = RCC_PLL_MUL4;
 8000c44:	f44f 2300 	mov.w	r3, #524288	; 0x80000

  /* Configure PLL ------------------------------------------------------*/
  /* PLL configuration: PLLCLK = (HSI / 2) * PLLMUL = (8 / 2) * 4 = 16 MHz */
  /* PREDIV1 configuration: PREDIV1CLK = PLLCLK / HSEPredivValue = 16 / 1 = 16 MHz */
  /* Enable HSI and activate PLL with HSi_DIV2 as source */
  oscinitstruct.OscillatorType  = RCC_OSCILLATORTYPE_HSI;
 8000c48:	9406      	str	r4, [sp, #24]
  oscinitstruct.HSEState        = RCC_HSE_OFF;
  oscinitstruct.LSEState        = RCC_LSE_OFF;
  oscinitstruct.HSIState        = RCC_HSI_ON;
  oscinitstruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
  oscinitstruct.HSEPredivValue    = RCC_HSE_PREDIV_DIV1;
  oscinitstruct.PLL.PLLState    = RCC_PLL_ON;
 8000c4a:	940d      	str	r4, [sp, #52]	; 0x34
  oscinitstruct.PLL.PLLSource   = RCC_PLLSOURCE_HSI_DIV2;
  oscinitstruct.PLL.PLLMUL      = RCC_PLL_MUL4;
 8000c4c:	930f      	str	r3, [sp, #60]	; 0x3c

  if (HAL_RCC_OscConfig(&oscinitstruct)!= HAL_OK)
 8000c4e:	f000 f8dd 	bl	8000e0c <HAL_RCC_OscConfig>
 8000c52:	b958      	cbnz	r0, 8000c6c <SystemClock_Config+0x4c>
	return;
  }

  /* Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2
     clocks dividers */
  clkinitstruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
 8000c54:	230f      	movs	r3, #15
 8000c56:	9301      	str	r3, [sp, #4]
  clkinitstruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  clkinitstruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 8000c58:	9003      	str	r0, [sp, #12]
  clkinitstruct.APB2CLKDivider = RCC_HCLK_DIV1;
 8000c5a:	9005      	str	r0, [sp, #20]
  clkinitstruct.APB1CLKDivider = RCC_HCLK_DIV2;
 8000c5c:	f44f 6380 	mov.w	r3, #1024	; 0x400
  if (HAL_RCC_ClockConfig(&clkinitstruct, FLASH_LATENCY_2)!= HAL_OK)
 8000c60:	a801      	add	r0, sp, #4
 8000c62:	4621      	mov	r1, r4
  }

  /* Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2
     clocks dividers */
  clkinitstruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
  clkinitstruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 8000c64:	9402      	str	r4, [sp, #8]
  clkinitstruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  clkinitstruct.APB2CLKDivider = RCC_HCLK_DIV1;
  clkinitstruct.APB1CLKDivider = RCC_HCLK_DIV2;
 8000c66:	9304      	str	r3, [sp, #16]
  if (HAL_RCC_ClockConfig(&clkinitstruct, FLASH_LATENCY_2)!= HAL_OK)
 8000c68:	f000 fb78 	bl	800135c <HAL_RCC_ClockConfig>
  {
    /* Initialization Error */
    //while(1);
	return;
  }
}
 8000c6c:	b010      	add	sp, #64	; 0x40
 8000c6e:	bd10      	pop	{r4, pc}

08000c70 <XBD_init>:
    while(1); 
  }
}
#endif

void XBD_init() {
 8000c70:	b537      	push	{r0, r1, r2, r4, r5, lr}
	// Remap pins such that i2c is pb8 and pb9
        //__HAL_AFIO_REMAP_I2C1_ENABLE();
	//volatile unsigned int *remap = &(AFIO->MAPR);
	//if ((*remap & 0x2) == 0) {
		RCC->APB2ENR |= RCC_APB2ENR_AFIOEN;
 8000c72:	4a1b      	ldr	r2, [pc, #108]	; (8000ce0 <XBD_init+0x70>)
 8000c74:	6993      	ldr	r3, [r2, #24]
 8000c76:	f043 0301 	orr.w	r3, r3, #1
 8000c7a:	6193      	str	r3, [r2, #24]
        	volatile unsigned int test = AFIO->MAPR;
 8000c7c:	4b19      	ldr	r3, [pc, #100]	; (8000ce4 <XBD_init+0x74>)
 8000c7e:	685a      	ldr	r2, [r3, #4]
 8000c80:	9201      	str	r2, [sp, #4]
        	SET_BIT(AFIO->MAPR, AFIO_MAPR_I2C1_REMAP);
 8000c82:	685a      	ldr	r2, [r3, #4]
 8000c84:	f042 0202 	orr.w	r2, r2, #2
 8000c88:	605a      	str	r2, [r3, #4]
        	test = AFIO->MAPR;
 8000c8a:	685a      	ldr	r2, [r3, #4]
 8000c8c:	9201      	str	r2, [sp, #4]
		volatile unsigned int *tet = &(AFIO->MAPR);
		AFIO->MAPR |= 0x2;
 8000c8e:	685a      	ldr	r2, [r3, #4]
 8000c90:	f042 0202 	orr.w	r2, r2, #2
 8000c94:	605a      	str	r2, [r3, #4]
	

		// Call init using STM32Cube HAL library
		HAL_Init();
 8000c96:	f000 fc45 	bl	8001524 <HAL_Init>

		/* Configure the system clock to 64 MHz */
		SystemClock_Config();
 8000c9a:	f7ff ffc1 	bl	8000c20 <SystemClock_Config>
	//volatile unsigned int test = AFIO->MAPR;
	//SET_BIT(AFIO->MAPR, AFIO_MAPR_I2C1_REMAP);
	//test = AFIO->MAPR;

	// Prepare i2c communications
	if (i2c_init()) {
 8000c9e:	f7ff fe01 	bl	80008a4 <i2c_init>
 8000ca2:	b110      	cbz	r0, 8000caa <XBD_init+0x3a>
		printf_xbd("Failed to initialize i2c comms !\n");
 8000ca4:	4810      	ldr	r0, [pc, #64]	; (8000ce8 <XBD_init+0x78>)
 8000ca6:	f7ff ff89 	bl	8000bbc <printf_xbd>
	}

	i2c_set_rx(FRW_msgRecHand);
 8000caa:	4810      	ldr	r0, [pc, #64]	; (8000cec <XBD_init+0x7c>)
 8000cac:	f7ff fe22 	bl	80008f4 <i2c_set_rx>
	i2c_set_tx(FRW_msgTraHand);
 8000cb0:	480f      	ldr	r0, [pc, #60]	; (8000cf0 <XBD_init+0x80>)
 8000cb2:	f7ff fe25 	bl	8000900 <i2c_set_tx>

	// Initialize GPIO pin for execution signal
	static GPIO_InitTypeDef  GPIO_InitStruct;
	GPIO_InitStruct.Mode  = GPIO_MODE_OUTPUT_PP;
 8000cb6:	490f      	ldr	r1, [pc, #60]	; (8000cf4 <XBD_init+0x84>)
	GPIO_InitStruct.Pull  = GPIO_PULLUP;
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8000cb8:	2303      	movs	r3, #3
	i2c_set_rx(FRW_msgRecHand);
	i2c_set_tx(FRW_msgTraHand);

	// Initialize GPIO pin for execution signal
	static GPIO_InitTypeDef  GPIO_InitStruct;
	GPIO_InitStruct.Mode  = GPIO_MODE_OUTPUT_PP;
 8000cba:	2401      	movs	r4, #1
	GPIO_InitStruct.Pull  = GPIO_PULLUP;
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;

	GPIO_InitStruct.Pin = TF_PIN;
 8000cbc:	2540      	movs	r5, #64	; 0x40
	HAL_GPIO_Init(TF_GPIO_PORT, &GPIO_InitStruct);
 8000cbe:	480e      	ldr	r0, [pc, #56]	; (8000cf8 <XBD_init+0x88>)

	// Initialize GPIO pin for execution signal
	static GPIO_InitTypeDef  GPIO_InitStruct;
	GPIO_InitStruct.Mode  = GPIO_MODE_OUTPUT_PP;
	GPIO_InitStruct.Pull  = GPIO_PULLUP;
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8000cc0:	60cb      	str	r3, [r1, #12]
	i2c_set_rx(FRW_msgRecHand);
	i2c_set_tx(FRW_msgTraHand);

	// Initialize GPIO pin for execution signal
	static GPIO_InitTypeDef  GPIO_InitStruct;
	GPIO_InitStruct.Mode  = GPIO_MODE_OUTPUT_PP;
 8000cc2:	604c      	str	r4, [r1, #4]
	GPIO_InitStruct.Pull  = GPIO_PULLUP;
 8000cc4:	608c      	str	r4, [r1, #8]
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;

	GPIO_InitStruct.Pin = TF_PIN;
 8000cc6:	600d      	str	r5, [r1, #0]
	HAL_GPIO_Init(TF_GPIO_PORT, &GPIO_InitStruct);
 8000cc8:	f000 fcc2 	bl	8001650 <HAL_GPIO_Init>
	HAL_GPIO_WritePin(TF_GPIO_PORT, TF_PIN, GPIO_PIN_SET);
 8000ccc:	480a      	ldr	r0, [pc, #40]	; (8000cf8 <XBD_init+0x88>)
 8000cce:	4629      	mov	r1, r5
 8000cd0:	4622      	mov	r2, r4
 8000cd2:	f000 fdeb 	bl	80018ac <HAL_GPIO_WritePin>

	HAL_SuspendTick();
 8000cd6:	f000 fc53 	bl	8001580 <HAL_SuspendTick>
}
 8000cda:	b003      	add	sp, #12
 8000cdc:	bd30      	pop	{r4, r5, pc}
 8000cde:	bf00      	nop
 8000ce0:	40021000 	.word	0x40021000
 8000ce4:	40010000 	.word	0x40010000
 8000ce8:	08001e70 	.word	0x08001e70
 8000cec:	0800069d 	.word	0x0800069d
 8000cf0:	080007f1 	.word	0x080007f1
 8000cf4:	20000554 	.word	0x20000554
 8000cf8:	40010800 	.word	0x40010800

08000cfc <XBD_serveCommunication>:

void XBD_serveCommunication(void) {
	// Call underlying receive/send
	i2c_handle();
 8000cfc:	f7ff be06 	b.w	800090c <i2c_handle>

08000d00 <XBD_loadStringFromConstDataArea>:

void XBD_loadStringFromConstDataArea( char *dst, const char *src  ) {
  /* copy a zero terminated string from src (CONSTDATAAREA) to dst
  e.g. strcpy if CONSTDATAREA empty, strcpy_P for PROGMEM
  */
  strcpy(dst,src);
 8000d00:	f7ff bf87 	b.w	8000c12 <strcpy>

08000d04 <XBD_readPage>:
}

void XBD_readPage( uint32_t pageStartAddress, uint8_t * buf ) {
 8000d04:	4603      	mov	r3, r0
  /* read PAGESIZE bytes from the binary buffer, index pageStartAddress
  to buf */
  memcpy(buf,(uint8_t *)pageStartAddress,PAGESIZE);
 8000d06:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8000d0a:	4608      	mov	r0, r1
 8000d0c:	4619      	mov	r1, r3
 8000d0e:	f7ff bf77 	b.w	8000c00 <memcpy>
	...

08000d14 <XBD_programPage>:
}

void XBD_programPage(uint32_t pageStartAddress, uint8_t *buf) {
 8000d14:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 8000d18:	4607      	mov	r7, r0
	static FLASH_EraseInitTypeDef EraseInitStruct;
	uint32_t PAGEError = 0, address = pageStartAddress, i = 0;
 8000d1a:	2400      	movs	r4, #0
 8000d1c:	ae02      	add	r6, sp, #8
  /* read PAGESIZE bytes from the binary buffer, index pageStartAddress
  to buf */
  memcpy(buf,(uint8_t *)pageStartAddress,PAGESIZE);
}

void XBD_programPage(uint32_t pageStartAddress, uint8_t *buf) {
 8000d1e:	4688      	mov	r8, r1
	static FLASH_EraseInitTypeDef EraseInitStruct;
	uint32_t PAGEError = 0, address = pageStartAddress, i = 0;
 8000d20:	f846 4d04 	str.w	r4, [r6, #-4]!

	// Unlock flash for writing
	HAL_FLASH_Unlock();
 8000d24:	f000 fe96 	bl	8001a54 <HAL_FLASH_Unlock>
	EraseInitStruct.TypeErase   = FLASH_TYPEERASE_PAGES;
 8000d28:	4815      	ldr	r0, [pc, #84]	; (8000d80 <XBD_programPage+0x6c>)
	EraseInitStruct.PageAddress = pageStartAddress;
	EraseInitStruct.NbPages     = 1;
 8000d2a:	2301      	movs	r3, #1


	// First erase the page (i.e. knock all bits to 1)
	if (HAL_FLASHEx_Erase(&EraseInitStruct, &PAGEError) != HAL_OK) {
 8000d2c:	4631      	mov	r1, r6
	static FLASH_EraseInitTypeDef EraseInitStruct;
	uint32_t PAGEError = 0, address = pageStartAddress, i = 0;

	// Unlock flash for writing
	HAL_FLASH_Unlock();
	EraseInitStruct.TypeErase   = FLASH_TYPEERASE_PAGES;
 8000d2e:	6004      	str	r4, [r0, #0]
	EraseInitStruct.PageAddress = pageStartAddress;
 8000d30:	6087      	str	r7, [r0, #8]
	EraseInitStruct.NbPages     = 1;
 8000d32:	60c3      	str	r3, [r0, #12]


	// First erase the page (i.e. knock all bits to 1)
	if (HAL_FLASHEx_Erase(&EraseInitStruct, &PAGEError) != HAL_OK) {
 8000d34:	f000 ff40 	bl	8001bb8 <HAL_FLASHEx_Erase>
 8000d38:	b118      	cbz	r0, 8000d42 <XBD_programPage+0x2e>
		printf_xbd("Failed to erase requested page\n");
 8000d3a:	4812      	ldr	r0, [pc, #72]	; (8000d84 <XBD_programPage+0x70>)
 8000d3c:	f7ff ff3e 	bl	8000bbc <printf_xbd>
 8000d40:	e01b      	b.n	8000d7a <XBD_programPage+0x66>
 8000d42:	463d      	mov	r5, r7
	EraseInitStruct.PageAddress = pageStartAddress;
	EraseInitStruct.NbPages     = 1;


	// First erase the page (i.e. knock all bits to 1)
	if (HAL_FLASHEx_Erase(&EraseInitStruct, &PAGEError) != HAL_OK) {
 8000d44:	4604      	mov	r4, r0

	unsigned int tmp_address = address;

	// Next program each word of the page using the supplied buffer
	for (i = 0; i < PAGESIZE; i += 4) {
		if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_WORD, address, *(uint32_t *)(&buf[i])) != HAL_OK) {
 8000d46:	2002      	movs	r0, #2
 8000d48:	4629      	mov	r1, r5
 8000d4a:	f858 2004 	ldr.w	r2, [r8, r4]
 8000d4e:	2300      	movs	r3, #0
 8000d50:	f000 fec6 	bl	8001ae0 <HAL_FLASH_Program>
 8000d54:	b150      	cbz	r0, 8000d6c <XBD_programPage+0x58>
			printf_xbd("Failed to program requested page, retrying\n");
 8000d56:	480c      	ldr	r0, [pc, #48]	; (8000d88 <XBD_programPage+0x74>)
 8000d58:	f7ff ff30 	bl	8000bbc <printf_xbd>
			HAL_FLASHEx_Erase(&EraseInitStruct, &PAGEError);
 8000d5c:	4808      	ldr	r0, [pc, #32]	; (8000d80 <XBD_programPage+0x6c>)
 8000d5e:	4631      	mov	r1, r6
 8000d60:	f000 ff2a 	bl	8001bb8 <HAL_FLASHEx_Erase>
			address = tmp_address;
 8000d64:	463d      	mov	r5, r7
			i = -4;
 8000d66:	f06f 0403 	mvn.w	r4, #3
 8000d6a:	e000      	b.n	8000d6e <XBD_programPage+0x5a>
			
		} else {
			//printf_xbd("programmed word\n");
			address += 4;
 8000d6c:	3504      	adds	r5, #4
	//printf_xbd("Erased page successfully\n");

	unsigned int tmp_address = address;

	// Next program each word of the page using the supplied buffer
	for (i = 0; i < PAGESIZE; i += 4) {
 8000d6e:	3404      	adds	r4, #4
 8000d70:	f5b4 6f80 	cmp.w	r4, #1024	; 0x400
 8000d74:	d3e7      	bcc.n	8000d46 <XBD_programPage+0x32>
			address += 4;
		}
	}

	// Lock flash for writing
	HAL_FLASH_Lock();
 8000d76:	f000 fe7f 	bl	8001a78 <HAL_FLASH_Lock>

}
 8000d7a:	b002      	add	sp, #8
 8000d7c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8000d80:	20000564 	.word	0x20000564
 8000d84:	08001ea1 	.word	0x08001ea1
 8000d88:	08001ec1 	.word	0x08001ec1

08000d8c <XBD_sendExecutionStartSignal>:
{

}

inline void XBD_sendExecutionStartSignal() {
	HAL_GPIO_WritePin(TF_GPIO_PORT, TF_PIN, GPIO_PIN_RESET);
 8000d8c:	4802      	ldr	r0, [pc, #8]	; (8000d98 <XBD_sendExecutionStartSignal+0xc>)
 8000d8e:	2140      	movs	r1, #64	; 0x40
 8000d90:	2200      	movs	r2, #0
 8000d92:	f000 bd8b 	b.w	80018ac <HAL_GPIO_WritePin>
 8000d96:	bf00      	nop
 8000d98:	40010800 	.word	0x40010800

08000d9c <XBD_sendExecutionCompleteSignal>:
}

inline void XBD_sendExecutionCompleteSignal() {
	HAL_GPIO_WritePin(TF_GPIO_PORT, TF_PIN, GPIO_PIN_SET);
 8000d9c:	4802      	ldr	r0, [pc, #8]	; (8000da8 <XBD_sendExecutionCompleteSignal+0xc>)
 8000d9e:	2140      	movs	r1, #64	; 0x40
 8000da0:	2201      	movs	r2, #1
 8000da2:	f000 bd83 	b.w	80018ac <HAL_GPIO_WritePin>
 8000da6:	bf00      	nop
 8000da8:	40010800 	.word	0x40010800

08000dac <XBD_switchToApplication>:
void XBD_switchToBootLoader(void) {
	HAL_NVIC_SystemReset();
}

void XBD_switchToApplication() {
	asm("mov pc,%[addr]"::[addr] "r" (FLASH_ADDR_MIN));
 8000dac:	4b01      	ldr	r3, [pc, #4]	; (8000db4 <XBD_switchToApplication+0x8>)
 8000dae:	469f      	mov	pc, r3
 8000db0:	4770      	bx	lr
 8000db2:	bf00      	nop
 8000db4:	08003000 	.word	0x08003000

08000db8 <XBD_busyLoopWithTiming>:
}

uint32_t XBD_busyLoopWithTiming(uint32_t approxCycles) {
 8000db8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8000dba:	4605      	mov	r5, r0
	volatile uint32_t exactCycles = 0;

	HAL_SuspendTick();


	uint32_t ctrl = SysTick->CTRL;
 8000dbc:	4c12      	ldr	r4, [pc, #72]	; (8000e08 <XBD_busyLoopWithTiming+0x50>)
void XBD_switchToApplication() {
	asm("mov pc,%[addr]"::[addr] "r" (FLASH_ADDR_MIN));
}

uint32_t XBD_busyLoopWithTiming(uint32_t approxCycles) {
	volatile uint32_t exactCycles = 0;
 8000dbe:	2600      	movs	r6, #0
 8000dc0:	9601      	str	r6, [sp, #4]

	HAL_SuspendTick();
 8000dc2:	f000 fbdd 	bl	8001580 <HAL_SuspendTick>


	uint32_t ctrl = SysTick->CTRL;
	SysTick->LOAD = approxCycles + 1000;
 8000dc6:	f505 737a 	add.w	r3, r5, #1000	; 0x3e8
	volatile uint32_t exactCycles = 0;

	HAL_SuspendTick();


	uint32_t ctrl = SysTick->CTRL;
 8000dca:	6827      	ldr	r7, [r4, #0]
	SysTick->LOAD = approxCycles + 1000;
 8000dcc:	6063      	str	r3, [r4, #4]
	SysTick->VAL = 0;
	SysTick->CTRL = 5;
 8000dce:	2305      	movs	r3, #5
	HAL_SuspendTick();


	uint32_t ctrl = SysTick->CTRL;
	SysTick->LOAD = approxCycles + 1000;
	SysTick->VAL = 0;
 8000dd0:	60a6      	str	r6, [r4, #8]
	SysTick->CTRL = 5;
 8000dd2:	6023      	str	r3, [r4, #0]
	XBD_sendExecutionStartSignal();
 8000dd4:	f7ff ffda 	bl	8000d8c <XBD_sendExecutionStartSignal>
	exactCycles=SysTick->VAL;
 8000dd8:	68a3      	ldr	r3, [r4, #8]
 8000dda:	9301      	str	r3, [sp, #4]
	while ((exactCycles=SysTick->VAL) > 1000);
 8000ddc:	68a3      	ldr	r3, [r4, #8]
 8000dde:	4e0a      	ldr	r6, [pc, #40]	; (8000e08 <XBD_busyLoopWithTiming+0x50>)
 8000de0:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 8000de4:	9301      	str	r3, [sp, #4]
 8000de6:	d8f9      	bhi.n	8000ddc <XBD_busyLoopWithTiming+0x24>

	XBD_sendExecutionCompleteSignal();
 8000de8:	f7ff ffd8 	bl	8000d9c <XBD_sendExecutionCompleteSignal>

	exactCycles = approxCycles + 1000 - SysTick->VAL;
 8000dec:	68b3      	ldr	r3, [r6, #8]

	/*Configure the SysTick to have interrupt in 1ms time basis*/
	//HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
	SysTick->CTRL = ctrl;
	HAL_InitTick(TICK_INT_PRIORITY);
 8000dee:	200f      	movs	r0, #15
 8000df0:	f5c3 737a 	rsb	r3, r3, #1000	; 0x3e8
	exactCycles=SysTick->VAL;
	while ((exactCycles=SysTick->VAL) > 1000);

	XBD_sendExecutionCompleteSignal();

	exactCycles = approxCycles + 1000 - SysTick->VAL;
 8000df4:	441d      	add	r5, r3
 8000df6:	9501      	str	r5, [sp, #4]

	/*Configure the SysTick to have interrupt in 1ms time basis*/
	//HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
	SysTick->CTRL = ctrl;
 8000df8:	6037      	str	r7, [r6, #0]
	HAL_InitTick(TICK_INT_PRIORITY);
 8000dfa:	f000 fb80 	bl	80014fe <HAL_InitTick>
	HAL_ResumeTick();
 8000dfe:	f000 fbc7 	bl	8001590 <HAL_ResumeTick>
	return exactCycles;
 8000e02:	9801      	ldr	r0, [sp, #4]
}
 8000e04:	b003      	add	sp, #12
 8000e06:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000e08:	e000e010 	.word	0xe000e010

08000e0c <HAL_RCC_OscConfig>:
  /* Check the parameters */
  assert_param(RCC_OscInitStruct != NULL);
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  
  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8000e0c:	6803      	ldr	r3, [r0, #0]
  *         supported by this macro. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 8000e0e:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8000e10:	4605      	mov	r5, r0
  /* Check the parameters */
  assert_param(RCC_OscInitStruct != NULL);
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  
  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8000e12:	07d8      	lsls	r0, r3, #31
 8000e14:	d403      	bmi.n	8000e1e <HAL_RCC_OscConfig+0x12>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8000e16:	682b      	ldr	r3, [r5, #0]
 8000e18:	0799      	lsls	r1, r3, #30
 8000e1a:	d473      	bmi.n	8000f04 <HAL_RCC_OscConfig+0xf8>
 8000e1c:	e0f0      	b.n	8001000 <HAL_RCC_OscConfig+0x1f4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
        
    /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE) 
 8000e1e:	4cb7      	ldr	r4, [pc, #732]	; (80010fc <HAL_RCC_OscConfig+0x2f0>)
 8000e20:	6863      	ldr	r3, [r4, #4]
 8000e22:	f003 030c 	and.w	r3, r3, #12
 8000e26:	2b04      	cmp	r3, #4
 8000e28:	d007      	beq.n	8000e3a <HAL_RCC_OscConfig+0x2e>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE)))
 8000e2a:	6863      	ldr	r3, [r4, #4]
 8000e2c:	f003 030c 	and.w	r3, r3, #12
 8000e30:	2b08      	cmp	r3, #8
 8000e32:	d116      	bne.n	8000e62 <HAL_RCC_OscConfig+0x56>
 8000e34:	6863      	ldr	r3, [r4, #4]
 8000e36:	03da      	lsls	r2, r3, #15
 8000e38:	d513      	bpl.n	8000e62 <HAL_RCC_OscConfig+0x56>
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8000e3a:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 8000e3e:	fa93 f2a3 	rbit	r2, r3
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8000e42:	6822      	ldr	r2, [r4, #0]
 8000e44:	fa93 f3a3 	rbit	r3, r3
 8000e48:	fab3 f383 	clz	r3, r3
 8000e4c:	f003 031f 	and.w	r3, r3, #31
 8000e50:	fa22 f303 	lsr.w	r3, r2, r3
 8000e54:	07db      	lsls	r3, r3, #31
 8000e56:	d5de      	bpl.n	8000e16 <HAL_RCC_OscConfig+0xa>
 8000e58:	686b      	ldr	r3, [r5, #4]
 8000e5a:	2b00      	cmp	r3, #0
 8000e5c:	d1db      	bne.n	8000e16 <HAL_RCC_OscConfig+0xa>
      {
        return HAL_ERROR;
 8000e5e:	2001      	movs	r0, #1
 8000e60:	e230      	b.n	80012c4 <HAL_RCC_OscConfig+0x4b8>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8000e62:	686b      	ldr	r3, [r5, #4]
 8000e64:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8000e68:	d013      	beq.n	8000e92 <HAL_RCC_OscConfig+0x86>
 8000e6a:	b95b      	cbnz	r3, 8000e84 <HAL_RCC_OscConfig+0x78>
 8000e6c:	6823      	ldr	r3, [r4, #0]
 8000e6e:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8000e72:	6023      	str	r3, [r4, #0]
 8000e74:	6823      	ldr	r3, [r4, #0]
 8000e76:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8000e7a:	6023      	str	r3, [r4, #0]
        }
      }
      else
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8000e7c:	f000 fb6c 	bl	8001558 <HAL_GetTick>
 8000e80:	4606      	mov	r6, r0
        
        /* Wait till HSE is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8000e82:	e02f      	b.n	8000ee4 <HAL_RCC_OscConfig+0xd8>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8000e84:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 8000e88:	6823      	ldr	r3, [r4, #0]
 8000e8a:	d106      	bne.n	8000e9a <HAL_RCC_OscConfig+0x8e>
 8000e8c:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8000e90:	6023      	str	r3, [r4, #0]
 8000e92:	6823      	ldr	r3, [r4, #0]
 8000e94:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8000e98:	e005      	b.n	8000ea6 <HAL_RCC_OscConfig+0x9a>
 8000e9a:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8000e9e:	6023      	str	r3, [r4, #0]
 8000ea0:	6823      	ldr	r3, [r4, #0]
 8000ea2:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8000ea6:	6023      	str	r3, [r4, #0]

       /* Check the HSE State */
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8000ea8:	f000 fb56 	bl	8001558 <HAL_GetTick>
 8000eac:	4606      	mov	r6, r0
 8000eae:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 8000eb2:	fa93 f2a3 	rbit	r2, r3
        
        /* Wait till HSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8000eb6:	6822      	ldr	r2, [r4, #0]
 8000eb8:	fa93 f3a3 	rbit	r3, r3
 8000ebc:	fab3 f383 	clz	r3, r3
 8000ec0:	f003 031f 	and.w	r3, r3, #31
 8000ec4:	fa22 f303 	lsr.w	r3, r2, r3
 8000ec8:	07df      	lsls	r7, r3, #31
 8000eca:	d4a4      	bmi.n	8000e16 <HAL_RCC_OscConfig+0xa>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8000ecc:	f000 fb44 	bl	8001558 <HAL_GetTick>
 8000ed0:	1b80      	subs	r0, r0, r6
 8000ed2:	2864      	cmp	r0, #100	; 0x64
 8000ed4:	d9eb      	bls.n	8000eae <HAL_RCC_OscConfig+0xa2>
          {
            return HAL_TIMEOUT;
 8000ed6:	2003      	movs	r0, #3
 8000ed8:	e1f4      	b.n	80012c4 <HAL_RCC_OscConfig+0x4b8>
        tickstart = HAL_GetTick();
        
        /* Wait till HSE is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
        {
           if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8000eda:	f000 fb3d 	bl	8001558 <HAL_GetTick>
 8000ede:	1b80      	subs	r0, r0, r6
 8000ee0:	2864      	cmp	r0, #100	; 0x64
 8000ee2:	d8f8      	bhi.n	8000ed6 <HAL_RCC_OscConfig+0xca>
 8000ee4:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 8000ee8:	fa93 f2a3 	rbit	r2, r3
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
        
        /* Wait till HSE is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8000eec:	6822      	ldr	r2, [r4, #0]
 8000eee:	fa93 f3a3 	rbit	r3, r3
 8000ef2:	fab3 f383 	clz	r3, r3
 8000ef6:	f003 031f 	and.w	r3, r3, #31
 8000efa:	fa22 f303 	lsr.w	r3, r2, r3
 8000efe:	07d8      	lsls	r0, r3, #31
 8000f00:	d4eb      	bmi.n	8000eda <HAL_RCC_OscConfig+0xce>
 8000f02:	e788      	b.n	8000e16 <HAL_RCC_OscConfig+0xa>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
    
    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */ 
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI) 
 8000f04:	4c7d      	ldr	r4, [pc, #500]	; (80010fc <HAL_RCC_OscConfig+0x2f0>)
 8000f06:	6863      	ldr	r3, [r4, #4]
 8000f08:	f013 0f0c 	tst.w	r3, #12
 8000f0c:	d007      	beq.n	8000f1e <HAL_RCC_OscConfig+0x112>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI_DIV2)))
 8000f0e:	6863      	ldr	r3, [r4, #4]
 8000f10:	f003 030c 	and.w	r3, r3, #12
 8000f14:	2b08      	cmp	r3, #8
 8000f16:	d120      	bne.n	8000f5a <HAL_RCC_OscConfig+0x14e>
 8000f18:	6863      	ldr	r3, [r4, #4]
 8000f1a:	03d9      	lsls	r1, r3, #15
 8000f1c:	d41d      	bmi.n	8000f5a <HAL_RCC_OscConfig+0x14e>
 8000f1e:	2302      	movs	r3, #2
 8000f20:	fa93 f2a3 	rbit	r2, r3
    {
      /* When HSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 8000f24:	6822      	ldr	r2, [r4, #0]
 8000f26:	fa93 f3a3 	rbit	r3, r3
 8000f2a:	fab3 f383 	clz	r3, r3
 8000f2e:	f003 031f 	and.w	r3, r3, #31
 8000f32:	fa22 f303 	lsr.w	r3, r2, r3
 8000f36:	07da      	lsls	r2, r3, #31
 8000f38:	d502      	bpl.n	8000f40 <HAL_RCC_OscConfig+0x134>
 8000f3a:	692b      	ldr	r3, [r5, #16]
 8000f3c:	2b01      	cmp	r3, #1
 8000f3e:	d18e      	bne.n	8000e5e <HAL_RCC_OscConfig+0x52>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8000f40:	6822      	ldr	r2, [r4, #0]
 8000f42:	21f8      	movs	r1, #248	; 0xf8
 8000f44:	fa91 f1a1 	rbit	r1, r1
 8000f48:	fab1 f181 	clz	r1, r1
 8000f4c:	696b      	ldr	r3, [r5, #20]
 8000f4e:	f022 02f8 	bic.w	r2, r2, #248	; 0xf8
 8000f52:	408b      	lsls	r3, r1
 8000f54:	4313      	orrs	r3, r2
 8000f56:	6023      	str	r3, [r4, #0]
    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */ 
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI) 
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI_DIV2)))
    {
      /* When HSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 8000f58:	e052      	b.n	8001000 <HAL_RCC_OscConfig+0x1f4>
      }
    }
    else
    {
      /* Check the HSI State */
      if(RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 8000f5a:	692a      	ldr	r2, [r5, #16]
 8000f5c:	2301      	movs	r3, #1
 8000f5e:	b372      	cbz	r2, 8000fbe <HAL_RCC_OscConfig+0x1b2>
 8000f60:	fa93 f2a3 	rbit	r2, r3
      {
       /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 8000f64:	fab2 f282 	clz	r2, r2
 8000f68:	0092      	lsls	r2, r2, #2
 8000f6a:	f102 4284 	add.w	r2, r2, #1107296256	; 0x42000000
 8000f6e:	f502 0284 	add.w	r2, r2, #4325376	; 0x420000
 8000f72:	6013      	str	r3, [r2, #0]
        
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8000f74:	f000 faf0 	bl	8001558 <HAL_GetTick>
 8000f78:	4606      	mov	r6, r0
 8000f7a:	2302      	movs	r3, #2
 8000f7c:	fa93 f2a3 	rbit	r2, r3
        
        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8000f80:	485e      	ldr	r0, [pc, #376]	; (80010fc <HAL_RCC_OscConfig+0x2f0>)
 8000f82:	6822      	ldr	r2, [r4, #0]
 8000f84:	fa93 f3a3 	rbit	r3, r3
 8000f88:	fab3 f383 	clz	r3, r3
 8000f8c:	f003 031f 	and.w	r3, r3, #31
 8000f90:	fa22 f303 	lsr.w	r3, r2, r3
 8000f94:	07db      	lsls	r3, r3, #31
 8000f96:	d405      	bmi.n	8000fa4 <HAL_RCC_OscConfig+0x198>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8000f98:	f000 fade 	bl	8001558 <HAL_GetTick>
 8000f9c:	1b80      	subs	r0, r0, r6
 8000f9e:	2802      	cmp	r0, #2
 8000fa0:	d9eb      	bls.n	8000f7a <HAL_RCC_OscConfig+0x16e>
 8000fa2:	e798      	b.n	8000ed6 <HAL_RCC_OscConfig+0xca>
            return HAL_TIMEOUT;
          }
        }
                
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8000fa4:	6802      	ldr	r2, [r0, #0]
 8000fa6:	21f8      	movs	r1, #248	; 0xf8
 8000fa8:	fa91 f1a1 	rbit	r1, r1
 8000fac:	fab1 f181 	clz	r1, r1
 8000fb0:	696b      	ldr	r3, [r5, #20]
 8000fb2:	f022 02f8 	bic.w	r2, r2, #248	; 0xf8
 8000fb6:	408b      	lsls	r3, r1
 8000fb8:	4313      	orrs	r3, r2
 8000fba:	6003      	str	r3, [r0, #0]
 8000fbc:	e020      	b.n	8001000 <HAL_RCC_OscConfig+0x1f4>
 8000fbe:	fa93 f3a3 	rbit	r3, r3
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 8000fc2:	fab3 f383 	clz	r3, r3
 8000fc6:	009b      	lsls	r3, r3, #2
 8000fc8:	f103 4384 	add.w	r3, r3, #1107296256	; 0x42000000
 8000fcc:	f503 0384 	add.w	r3, r3, #4325376	; 0x420000
 8000fd0:	601a      	str	r2, [r3, #0]
        
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8000fd2:	f000 fac1 	bl	8001558 <HAL_GetTick>
 8000fd6:	4606      	mov	r6, r0
 8000fd8:	2302      	movs	r3, #2
 8000fda:	fa93 f2a3 	rbit	r2, r3
        
        /* Wait till HSI is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8000fde:	6822      	ldr	r2, [r4, #0]
 8000fe0:	fa93 f3a3 	rbit	r3, r3
 8000fe4:	fab3 f383 	clz	r3, r3
 8000fe8:	f003 031f 	and.w	r3, r3, #31
 8000fec:	fa22 f303 	lsr.w	r3, r2, r3
 8000ff0:	07df      	lsls	r7, r3, #31
 8000ff2:	d505      	bpl.n	8001000 <HAL_RCC_OscConfig+0x1f4>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8000ff4:	f000 fab0 	bl	8001558 <HAL_GetTick>
 8000ff8:	1b80      	subs	r0, r0, r6
 8000ffa:	2802      	cmp	r0, #2
 8000ffc:	d9ec      	bls.n	8000fd8 <HAL_RCC_OscConfig+0x1cc>
 8000ffe:	e76a      	b.n	8000ed6 <HAL_RCC_OscConfig+0xca>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8001000:	682b      	ldr	r3, [r5, #0]
 8001002:	071c      	lsls	r4, r3, #28
 8001004:	d546      	bpl.n	8001094 <HAL_RCC_OscConfig+0x288>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));
    
    /* Check the LSI State */
    if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 8001006:	69aa      	ldr	r2, [r5, #24]
 8001008:	4c3c      	ldr	r4, [pc, #240]	; (80010fc <HAL_RCC_OscConfig+0x2f0>)
 800100a:	2301      	movs	r3, #1
 800100c:	493c      	ldr	r1, [pc, #240]	; (8001100 <HAL_RCC_OscConfig+0x2f4>)
 800100e:	b312      	cbz	r2, 8001056 <HAL_RCC_OscConfig+0x24a>
 8001010:	fa93 f2a3 	rbit	r2, r3
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 8001014:	fab2 f282 	clz	r2, r2
 8001018:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
      
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 800101c:	f000 fa9c 	bl	8001558 <HAL_GetTick>
 8001020:	4606      	mov	r6, r0
 8001022:	2302      	movs	r3, #2
 8001024:	fa93 f2a3 	rbit	r2, r3
 8001028:	fa93 f2a3 	rbit	r2, r3
      
      /* Wait till LSI is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 800102c:	6a62      	ldr	r2, [r4, #36]	; 0x24
 800102e:	fa93 f3a3 	rbit	r3, r3
 8001032:	fab3 f383 	clz	r3, r3
 8001036:	f003 031f 	and.w	r3, r3, #31
 800103a:	fa22 f303 	lsr.w	r3, r2, r3
 800103e:	07d8      	lsls	r0, r3, #31
 8001040:	d405      	bmi.n	800104e <HAL_RCC_OscConfig+0x242>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8001042:	f000 fa89 	bl	8001558 <HAL_GetTick>
 8001046:	1b80      	subs	r0, r0, r6
 8001048:	2802      	cmp	r0, #2
 800104a:	d9ea      	bls.n	8001022 <HAL_RCC_OscConfig+0x216>
 800104c:	e743      	b.n	8000ed6 <HAL_RCC_OscConfig+0xca>
          return HAL_TIMEOUT;
        }
      }
      /*  To have a fully stabilized clock in the specified range, a software delay of 1ms 
          should be added.*/
      HAL_Delay(1);
 800104e:	2001      	movs	r0, #1
 8001050:	f000 fa88 	bl	8001564 <HAL_Delay>
 8001054:	e01e      	b.n	8001094 <HAL_RCC_OscConfig+0x288>
 8001056:	fa93 f3a3 	rbit	r3, r3
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 800105a:	fab3 f383 	clz	r3, r3
 800105e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
      
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 8001062:	f000 fa79 	bl	8001558 <HAL_GetTick>
 8001066:	4606      	mov	r6, r0
 8001068:	2302      	movs	r3, #2
 800106a:	fa93 f2a3 	rbit	r2, r3
 800106e:	fa93 f2a3 	rbit	r2, r3
      
      /* Wait till LSI is disabled */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8001072:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8001074:	fa93 f3a3 	rbit	r3, r3
 8001078:	fab3 f383 	clz	r3, r3
 800107c:	f003 031f 	and.w	r3, r3, #31
 8001080:	fa22 f303 	lsr.w	r3, r2, r3
 8001084:	07d9      	lsls	r1, r3, #31
 8001086:	d505      	bpl.n	8001094 <HAL_RCC_OscConfig+0x288>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8001088:	f000 fa66 	bl	8001558 <HAL_GetTick>
 800108c:	1b80      	subs	r0, r0, r6
 800108e:	2802      	cmp	r0, #2
 8001090:	d9ea      	bls.n	8001068 <HAL_RCC_OscConfig+0x25c>
 8001092:	e720      	b.n	8000ed6 <HAL_RCC_OscConfig+0xca>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8001094:	682b      	ldr	r3, [r5, #0]
 8001096:	075a      	lsls	r2, r3, #29
 8001098:	d404      	bmi.n	80010a4 <HAL_RCC_OscConfig+0x298>

#endif /* RCC_CR_PLL2ON */
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 800109a:	69ea      	ldr	r2, [r5, #28]
 800109c:	2a00      	cmp	r2, #0
 800109e:	f040 8086 	bne.w	80011ae <HAL_RCC_OscConfig+0x3a2>
 80010a2:	e0de      	b.n	8001262 <HAL_RCC_OscConfig+0x456>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Enable Power Clock*/
      __HAL_RCC_PWR_CLK_ENABLE();
 80010a4:	4c15      	ldr	r4, [pc, #84]	; (80010fc <HAL_RCC_OscConfig+0x2f0>)
    
      /* Enable write access to Backup domain */
      SET_BIT(PWR->CR, PWR_CR_DBP);
 80010a6:	4a17      	ldr	r2, [pc, #92]	; (8001104 <HAL_RCC_OscConfig+0x2f8>)
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Enable Power Clock*/
      __HAL_RCC_PWR_CLK_ENABLE();
 80010a8:	69e3      	ldr	r3, [r4, #28]
 80010aa:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 80010ae:	61e3      	str	r3, [r4, #28]
 80010b0:	69e3      	ldr	r3, [r4, #28]
 80010b2:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80010b6:	9301      	str	r3, [sp, #4]
 80010b8:	9b01      	ldr	r3, [sp, #4]
    
      /* Enable write access to Backup domain */
      SET_BIT(PWR->CR, PWR_CR_DBP);
 80010ba:	6813      	ldr	r3, [r2, #0]
 80010bc:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80010c0:	6013      	str	r3, [r2, #0]
      
      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
 80010c2:	f000 fa49 	bl	8001558 <HAL_GetTick>
 80010c6:	4606      	mov	r6, r0

    while((PWR->CR & PWR_CR_DBP) == RESET)
 80010c8:	4b0e      	ldr	r3, [pc, #56]	; (8001104 <HAL_RCC_OscConfig+0x2f8>)
 80010ca:	681b      	ldr	r3, [r3, #0]
 80010cc:	05db      	lsls	r3, r3, #23
 80010ce:	d405      	bmi.n	80010dc <HAL_RCC_OscConfig+0x2d0>
      {
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 80010d0:	f000 fa42 	bl	8001558 <HAL_GetTick>
 80010d4:	1b80      	subs	r0, r0, r6
 80010d6:	2864      	cmp	r0, #100	; 0x64
 80010d8:	d9f6      	bls.n	80010c8 <HAL_RCC_OscConfig+0x2bc>
 80010da:	e6fc      	b.n	8000ed6 <HAL_RCC_OscConfig+0xca>
          return HAL_TIMEOUT;
        }
      }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80010dc:	68eb      	ldr	r3, [r5, #12]
 80010de:	2b01      	cmp	r3, #1
 80010e0:	d018      	beq.n	8001114 <HAL_RCC_OscConfig+0x308>
 80010e2:	b98b      	cbnz	r3, 8001108 <HAL_RCC_OscConfig+0x2fc>
 80010e4:	6a23      	ldr	r3, [r4, #32]
 80010e6:	f023 0301 	bic.w	r3, r3, #1
 80010ea:	6223      	str	r3, [r4, #32]
 80010ec:	6a23      	ldr	r3, [r4, #32]
 80010ee:	f023 0304 	bic.w	r3, r3, #4
 80010f2:	6223      	str	r3, [r4, #32]
      }
    }
    else
    {
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 80010f4:	f000 fa30 	bl	8001558 <HAL_GetTick>
 80010f8:	4606      	mov	r6, r0
      
      /* Wait till LSE is disabled */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 80010fa:	e040      	b.n	800117e <HAL_RCC_OscConfig+0x372>
 80010fc:	40021000 	.word	0x40021000
 8001100:	42420480 	.word	0x42420480
 8001104:	40007000 	.word	0x40007000
          return HAL_TIMEOUT;
        }
      }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8001108:	2b05      	cmp	r3, #5
 800110a:	6a23      	ldr	r3, [r4, #32]
 800110c:	d106      	bne.n	800111c <HAL_RCC_OscConfig+0x310>
 800110e:	f043 0304 	orr.w	r3, r3, #4
 8001112:	6223      	str	r3, [r4, #32]
 8001114:	6a23      	ldr	r3, [r4, #32]
 8001116:	f043 0301 	orr.w	r3, r3, #1
 800111a:	e005      	b.n	8001128 <HAL_RCC_OscConfig+0x31c>
 800111c:	f023 0301 	bic.w	r3, r3, #1
 8001120:	6223      	str	r3, [r4, #32]
 8001122:	6a23      	ldr	r3, [r4, #32]
 8001124:	f023 0304 	bic.w	r3, r3, #4
 8001128:	6223      	str	r3, [r4, #32]
    /* Check the LSE State */
    if(RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
    {
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 800112a:	f000 fa15 	bl	8001558 <HAL_GetTick>
 800112e:	4606      	mov	r6, r0
 8001130:	2302      	movs	r3, #2
 8001132:	fa93 f2a3 	rbit	r2, r3
 8001136:	fa93 f2a3 	rbit	r2, r3
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800113a:	fab2 f282 	clz	r2, r2
 800113e:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8001142:	0952      	lsrs	r2, r2, #5
 8001144:	429a      	cmp	r2, r3
 8001146:	bf0c      	ite	eq
 8001148:	6a22      	ldreq	r2, [r4, #32]
 800114a:	6a62      	ldrne	r2, [r4, #36]	; 0x24
 800114c:	fa93 f3a3 	rbit	r3, r3
 8001150:	fab3 f383 	clz	r3, r3
 8001154:	f003 031f 	and.w	r3, r3, #31
 8001158:	40da      	lsrs	r2, r3
 800115a:	07d7      	lsls	r7, r2, #31
 800115c:	d49d      	bmi.n	800109a <HAL_RCC_OscConfig+0x28e>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800115e:	f000 f9fb 	bl	8001558 <HAL_GetTick>
 8001162:	f241 3388 	movw	r3, #5000	; 0x1388
 8001166:	1b80      	subs	r0, r0, r6
 8001168:	4298      	cmp	r0, r3
 800116a:	d9e1      	bls.n	8001130 <HAL_RCC_OscConfig+0x324>
 800116c:	e6b3      	b.n	8000ed6 <HAL_RCC_OscConfig+0xca>
      tickstart = HAL_GetTick();
      
      /* Wait till LSE is disabled */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800116e:	f000 f9f3 	bl	8001558 <HAL_GetTick>
 8001172:	f241 3388 	movw	r3, #5000	; 0x1388
 8001176:	1b80      	subs	r0, r0, r6
 8001178:	4298      	cmp	r0, r3
 800117a:	f63f aeac 	bhi.w	8000ed6 <HAL_RCC_OscConfig+0xca>
 800117e:	2302      	movs	r3, #2
 8001180:	fa93 f2a3 	rbit	r2, r3
 8001184:	fa93 f2a3 	rbit	r2, r3
    {
      /* Get Start Tick */
      tickstart = HAL_GetTick();
      
      /* Wait till LSE is disabled */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8001188:	fab2 f282 	clz	r2, r2
 800118c:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8001190:	0952      	lsrs	r2, r2, #5
 8001192:	429a      	cmp	r2, r3
 8001194:	bf0c      	ite	eq
 8001196:	6a22      	ldreq	r2, [r4, #32]
 8001198:	6a62      	ldrne	r2, [r4, #36]	; 0x24
 800119a:	fa93 f3a3 	rbit	r3, r3
 800119e:	fab3 f383 	clz	r3, r3
 80011a2:	f003 031f 	and.w	r3, r3, #31
 80011a6:	40da      	lsrs	r2, r3
 80011a8:	07d0      	lsls	r0, r2, #31
 80011aa:	d4e0      	bmi.n	800116e <HAL_RCC_OscConfig+0x362>
 80011ac:	e775      	b.n	800109a <HAL_RCC_OscConfig+0x28e>
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 80011ae:	4c46      	ldr	r4, [pc, #280]	; (80012c8 <HAL_RCC_OscConfig+0x4bc>)
 80011b0:	6863      	ldr	r3, [r4, #4]
 80011b2:	f003 030c 	and.w	r3, r3, #12
 80011b6:	2b08      	cmp	r3, #8
 80011b8:	f43f ae51 	beq.w	8000e5e <HAL_RCC_OscConfig+0x52>
    { 
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 80011bc:	2a02      	cmp	r2, #2
 80011be:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 80011c2:	d15c      	bne.n	800127e <HAL_RCC_OscConfig+0x472>
 80011c4:	fa93 f3a3 	rbit	r3, r3
        /* Check the parameters */
        assert_param(IS_RCC_PLLSOURCE(RCC_OscInitStruct->PLL.PLLSource));
        assert_param(IS_RCC_PLL_MUL(RCC_OscInitStruct->PLL.PLLMUL));
  
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 80011c8:	fab3 f383 	clz	r3, r3
 80011cc:	009b      	lsls	r3, r3, #2
 80011ce:	f103 4384 	add.w	r3, r3, #1107296256	; 0x42000000
 80011d2:	f503 0384 	add.w	r3, r3, #4325376	; 0x420000
 80011d6:	2200      	movs	r2, #0
 80011d8:	601a      	str	r2, [r3, #0]
        
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 80011da:	f000 f9bd 	bl	8001558 <HAL_GetTick>
 80011de:	4606      	mov	r6, r0
 80011e0:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 80011e4:	fa93 f2a3 	rbit	r2, r3
        
        /* Wait till PLL is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 80011e8:	4f37      	ldr	r7, [pc, #220]	; (80012c8 <HAL_RCC_OscConfig+0x4bc>)
 80011ea:	6822      	ldr	r2, [r4, #0]
 80011ec:	fa93 f3a3 	rbit	r3, r3
 80011f0:	fab3 f383 	clz	r3, r3
 80011f4:	f003 031f 	and.w	r3, r3, #31
 80011f8:	fa22 f303 	lsr.w	r3, r2, r3
 80011fc:	07d9      	lsls	r1, r3, #31
 80011fe:	d432      	bmi.n	8001266 <HAL_RCC_OscConfig+0x45a>
          }
        }

        /* Configure the HSE prediv factor --------------------------------*/
        /* It can be written only when the PLL is disabled. Not used in PLL source is different than HSE */
        if(RCC_OscInitStruct->PLL.PLLSource == RCC_PLLSOURCE_HSE)
 8001200:	6a2e      	ldr	r6, [r5, #32]
 8001202:	f5b6 3f80 	cmp.w	r6, #65536	; 0x10000
          /* Set PREDIV1 source */
          SET_BIT(RCC->CFGR2, RCC_OscInitStruct->Prediv1Source);
#endif /* RCC_CFGR2_PREDIV1SRC */

          /* Set PREDIV1 Value */
          __HAL_RCC_HSE_PREDIV_CONFIG(RCC_OscInitStruct->HSEPredivValue);
 8001206:	bf01      	itttt	eq
 8001208:	6879      	ldreq	r1, [r7, #4]
 800120a:	f421 3000 	biceq.w	r0, r1, #131072	; 0x20000
 800120e:	68a9      	ldreq	r1, [r5, #8]
 8001210:	4301      	orreq	r1, r0
 8001212:	bf08      	it	eq
 8001214:	6079      	streq	r1, [r7, #4]
        }

        /* Configure the main PLL clock source and multiplication factors. */
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8001216:	6863      	ldr	r3, [r4, #4]
 8001218:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 800121a:	f423 1374 	bic.w	r3, r3, #3997696	; 0x3d0000
 800121e:	4332      	orrs	r2, r6
 8001220:	4313      	orrs	r3, r2
 8001222:	6063      	str	r3, [r4, #4]
 8001224:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 8001228:	fa93 f3a3 	rbit	r3, r3
                             RCC_OscInitStruct->PLL.PLLMUL);
        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
 800122c:	fab3 f383 	clz	r3, r3
 8001230:	009b      	lsls	r3, r3, #2
 8001232:	f103 4384 	add.w	r3, r3, #1107296256	; 0x42000000
 8001236:	f503 0384 	add.w	r3, r3, #4325376	; 0x420000
 800123a:	2201      	movs	r2, #1
 800123c:	601a      	str	r2, [r3, #0]
        
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800123e:	f000 f98b 	bl	8001558 <HAL_GetTick>
 8001242:	4605      	mov	r5, r0
 8001244:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 8001248:	fa93 f2a3 	rbit	r2, r3
        
        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == RESET)
 800124c:	6822      	ldr	r2, [r4, #0]
 800124e:	fa93 f3a3 	rbit	r3, r3
 8001252:	fab3 f383 	clz	r3, r3
 8001256:	f003 031f 	and.w	r3, r3, #31
 800125a:	fa22 f303 	lsr.w	r3, r2, r3
 800125e:	07da      	lsls	r2, r3, #31
 8001260:	d507      	bpl.n	8001272 <HAL_RCC_OscConfig+0x466>
    {
      return HAL_ERROR;
    }
  }
  
  return HAL_OK;
 8001262:	2000      	movs	r0, #0
 8001264:	e02e      	b.n	80012c4 <HAL_RCC_OscConfig+0x4b8>
        tickstart = HAL_GetTick();
        
        /* Wait till PLL is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8001266:	f000 f977 	bl	8001558 <HAL_GetTick>
 800126a:	1b80      	subs	r0, r0, r6
 800126c:	2802      	cmp	r0, #2
 800126e:	d9b7      	bls.n	80011e0 <HAL_RCC_OscConfig+0x3d4>
 8001270:	e631      	b.n	8000ed6 <HAL_RCC_OscConfig+0xca>
        tickstart = HAL_GetTick();
        
        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == RESET)
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8001272:	f000 f971 	bl	8001558 <HAL_GetTick>
 8001276:	1b40      	subs	r0, r0, r5
 8001278:	2802      	cmp	r0, #2
 800127a:	d9e3      	bls.n	8001244 <HAL_RCC_OscConfig+0x438>
 800127c:	e62b      	b.n	8000ed6 <HAL_RCC_OscConfig+0xca>
 800127e:	fa93 f3a3 	rbit	r3, r3
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8001282:	fab3 f383 	clz	r3, r3
 8001286:	009b      	lsls	r3, r3, #2
 8001288:	f103 4384 	add.w	r3, r3, #1107296256	; 0x42000000
 800128c:	f503 0384 	add.w	r3, r3, #4325376	; 0x420000
 8001290:	2200      	movs	r2, #0
 8001292:	601a      	str	r2, [r3, #0]
 
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8001294:	f000 f960 	bl	8001558 <HAL_GetTick>
 8001298:	4605      	mov	r5, r0
 800129a:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 800129e:	fa93 f2a3 	rbit	r2, r3
        
        /* Wait till PLL is disabled */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 80012a2:	6822      	ldr	r2, [r4, #0]
 80012a4:	fa93 f3a3 	rbit	r3, r3
 80012a8:	fab3 f383 	clz	r3, r3
 80012ac:	f003 031f 	and.w	r3, r3, #31
 80012b0:	fa22 f303 	lsr.w	r3, r2, r3
 80012b4:	07db      	lsls	r3, r3, #31
 80012b6:	d5d4      	bpl.n	8001262 <HAL_RCC_OscConfig+0x456>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 80012b8:	f000 f94e 	bl	8001558 <HAL_GetTick>
 80012bc:	1b40      	subs	r0, r0, r5
 80012be:	2802      	cmp	r0, #2
 80012c0:	d9eb      	bls.n	800129a <HAL_RCC_OscConfig+0x48e>
 80012c2:	e608      	b.n	8000ed6 <HAL_RCC_OscConfig+0xca>
      return HAL_ERROR;
    }
  }
  
  return HAL_OK;
}
 80012c4:	b003      	add	sp, #12
 80012c6:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80012c8:	40021000 	.word	0x40021000

080012cc <HAL_RCC_GetSysClockFreq>:
{
#if   defined(RCC_CFGR2_PREDIV1SRC)
  const uint8_t aPLLMULFactorTable[12] = {0, 0, 4,  5,  6,  7,  8,  9, 0, 0, 0, 13};
  const uint8_t aPredivFactorTable[16] = { 1, 2,  3,  4,  5,  6,  7,  8, 9,10, 11, 12, 13, 14, 15, 16};
#else
  const uint8_t aPLLMULFactorTable[16] = { 2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 16};
 80012cc:	4b1f      	ldr	r3, [pc, #124]	; (800134c <HAL_RCC_GetSysClockFreq+0x80>)
  *         right SYSCLK value. Otherwise, any configuration based on this function will be incorrect.
  *         
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
 80012ce:	b570      	push	{r4, r5, r6, lr}
#if   defined(RCC_CFGR2_PREDIV1SRC)
  const uint8_t aPLLMULFactorTable[12] = {0, 0, 4,  5,  6,  7,  8,  9, 0, 0, 0, 13};
  const uint8_t aPredivFactorTable[16] = { 1, 2,  3,  4,  5,  6,  7,  8, 9,10, 11, 12, 13, 14, 15, 16};
#else
  const uint8_t aPLLMULFactorTable[16] = { 2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 16};
 80012d0:	f103 0510 	add.w	r5, r3, #16
 80012d4:	462e      	mov	r6, r5
  *         right SYSCLK value. Otherwise, any configuration based on this function will be incorrect.
  *         
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
 80012d6:	b086      	sub	sp, #24
#if   defined(RCC_CFGR2_PREDIV1SRC)
  const uint8_t aPLLMULFactorTable[12] = {0, 0, 4,  5,  6,  7,  8,  9, 0, 0, 0, 13};
  const uint8_t aPredivFactorTable[16] = { 1, 2,  3,  4,  5,  6,  7,  8, 9,10, 11, 12, 13, 14, 15, 16};
#else
  const uint8_t aPLLMULFactorTable[16] = { 2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 16};
 80012d8:	ac02      	add	r4, sp, #8
 80012da:	4622      	mov	r2, r4
 80012dc:	6818      	ldr	r0, [r3, #0]
 80012de:	6859      	ldr	r1, [r3, #4]
 80012e0:	3308      	adds	r3, #8
 80012e2:	c203      	stmia	r2!, {r0, r1}
 80012e4:	42ab      	cmp	r3, r5
 80012e6:	4614      	mov	r4, r2
 80012e8:	d1f7      	bne.n	80012da <HAL_RCC_GetSysClockFreq+0xe>
#if defined(RCC_CFGR2_PREDIV1)
  const uint8_t aPredivFactorTable[16] = { 1, 2,  3,  4,  5,  6,  7,  8, 9,10, 11, 12, 13, 14, 15, 16};
#else
  const uint8_t aPredivFactorTable[2] = { 1, 2};
 80012ea:	8833      	ldrh	r3, [r6, #0]
  uint32_t sysclockfreq = 0;
#if defined(RCC_CFGR2_PREDIV1SRC)
  uint32_t prediv2 = 0, pll2mul = 0;
#endif /*RCC_CFGR2_PREDIV1SRC*/
  
  tmpreg = RCC->CFGR;
 80012ec:	4818      	ldr	r0, [pc, #96]	; (8001350 <HAL_RCC_GetSysClockFreq+0x84>)
#else
  const uint8_t aPLLMULFactorTable[16] = { 2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 16};
#if defined(RCC_CFGR2_PREDIV1)
  const uint8_t aPredivFactorTable[16] = { 1, 2,  3,  4,  5,  6,  7,  8, 9,10, 11, 12, 13, 14, 15, 16};
#else
  const uint8_t aPredivFactorTable[2] = { 1, 2};
 80012ee:	f8ad 3004 	strh.w	r3, [sp, #4]
  uint32_t sysclockfreq = 0;
#if defined(RCC_CFGR2_PREDIV1SRC)
  uint32_t prediv2 = 0, pll2mul = 0;
#endif /*RCC_CFGR2_PREDIV1SRC*/
  
  tmpreg = RCC->CFGR;
 80012f2:	6841      	ldr	r1, [r0, #4]
  
  /* Get SYSCLK source -------------------------------------------------------*/
  switch (tmpreg & RCC_CFGR_SWS)
 80012f4:	f001 030c 	and.w	r3, r1, #12
 80012f8:	2b08      	cmp	r3, #8
 80012fa:	d123      	bne.n	8001344 <HAL_RCC_GetSysClockFreq+0x78>
 80012fc:	f44f 1270 	mov.w	r2, #3932160	; 0x3c0000
 8001300:	fa92 f2a2 	rbit	r2, r2
      sysclockfreq = HSE_VALUE;
      break;
    }
    case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL used as system clock */
    {
      pllmul = aPLLMULFactorTable[(uint32_t)(tmpreg & RCC_CFGR_PLLMULL) >> POSITION_VAL(RCC_CFGR_PLLMULL)];
 8001304:	fab2 f282 	clz	r2, r2
 8001308:	f401 1370 	and.w	r3, r1, #3932160	; 0x3c0000
 800130c:	40d3      	lsrs	r3, r2
 800130e:	aa06      	add	r2, sp, #24
 8001310:	4413      	add	r3, r2
 8001312:	f813 2c10 	ldrb.w	r2, [r3, #-16]
      if ((tmpreg & RCC_CFGR_PLLSRC) != RCC_PLLSOURCE_HSI_DIV2)
 8001316:	03cb      	lsls	r3, r1, #15
 8001318:	d511      	bpl.n	800133e <HAL_RCC_GetSysClockFreq+0x72>
      {
#if defined(RCC_CFGR2_PREDIV1)
        prediv = aPredivFactorTable[(uint32_t)(RCC->CFGR2 & RCC_CFGR2_PREDIV1) >> POSITION_VAL(RCC_CFGR2_PREDIV1)];
#else
        prediv = aPredivFactorTable[(uint32_t)(RCC->CFGR & RCC_CFGR_PLLXTPRE) >> POSITION_VAL(RCC_CFGR_PLLXTPRE)];
 800131a:	6843      	ldr	r3, [r0, #4]
 800131c:	f44f 3100 	mov.w	r1, #131072	; 0x20000
 8001320:	fa91 f1a1 	rbit	r1, r1
 8001324:	fab1 f181 	clz	r1, r1
 8001328:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800132c:	40cb      	lsrs	r3, r1
 800132e:	a906      	add	r1, sp, #24
 8001330:	440b      	add	r3, r1
 8001332:	f813 0c14 	ldrb.w	r0, [r3, #-20]
        {
            pllclk = pllclk / 2;
        }
#else
        /* HSE used as PLL clock source : PLLCLK = HSE/PREDIV1 * PLLMUL */
        pllclk = (uint32_t)((HSE_VALUE / prediv) * pllmul);
 8001336:	4b07      	ldr	r3, [pc, #28]	; (8001354 <HAL_RCC_GetSysClockFreq+0x88>)
 8001338:	fbb3 f0f0 	udiv	r0, r3, r0
 800133c:	e000      	b.n	8001340 <HAL_RCC_GetSysClockFreq+0x74>
#endif /*RCC_CFGR2_PREDIV1SRC*/
      }
      else
      {
        /* HSI used as PLL clock source : PLLCLK = HSI/2 * PLLMUL */
        pllclk = (uint32_t)((HSI_VALUE >> 1) * pllmul);
 800133e:	4806      	ldr	r0, [pc, #24]	; (8001358 <HAL_RCC_GetSysClockFreq+0x8c>)
 8001340:	4350      	muls	r0, r2
 8001342:	e000      	b.n	8001346 <HAL_RCC_GetSysClockFreq+0x7a>
  /* Get SYSCLK source -------------------------------------------------------*/
  switch (tmpreg & RCC_CFGR_SWS)
  {
    case RCC_SYSCLKSOURCE_STATUS_HSE:  /* HSE used as system clock */
    {
      sysclockfreq = HSE_VALUE;
 8001344:	4803      	ldr	r0, [pc, #12]	; (8001354 <HAL_RCC_GetSysClockFreq+0x88>)
      sysclockfreq = HSI_VALUE;
      break;
    }
  }
  return sysclockfreq;
}
 8001346:	b006      	add	sp, #24
 8001348:	bd70      	pop	{r4, r5, r6, pc}
 800134a:	bf00      	nop
 800134c:	08001d5c 	.word	0x08001d5c
 8001350:	40021000 	.word	0x40021000
 8001354:	007a1200 	.word	0x007a1200
 8001358:	003d0900 	.word	0x003d0900

0800135c <HAL_RCC_ClockConfig>:
  must be correctly programmed according to the frequency of the CPU clock 
    (HCLK) of the device. */

#if defined(FLASH_ACR_LATENCY)
  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 800135c:	4a54      	ldr	r2, [pc, #336]	; (80014b0 <HAL_RCC_ClockConfig+0x154>)
  *         You can use @ref HAL_RCC_GetClockConfig() function to know which clock is
  *         currently used as system clock source.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 800135e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  must be correctly programmed according to the frequency of the CPU clock 
    (HCLK) of the device. */

#if defined(FLASH_ACR_LATENCY)
  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 8001360:	6813      	ldr	r3, [r2, #0]
  *         You can use @ref HAL_RCC_GetClockConfig() function to know which clock is
  *         currently used as system clock source.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 8001362:	4606      	mov	r6, r0
  must be correctly programmed according to the frequency of the CPU clock 
    (HCLK) of the device. */

#if defined(FLASH_ACR_LATENCY)
  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 8001364:	f003 0307 	and.w	r3, r3, #7
 8001368:	4299      	cmp	r1, r3
  *         You can use @ref HAL_RCC_GetClockConfig() function to know which clock is
  *         currently used as system clock source.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 800136a:	460d      	mov	r5, r1
  must be correctly programmed according to the frequency of the CPU clock 
    (HCLK) of the device. */

#if defined(FLASH_ACR_LATENCY)
  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 800136c:	d80a      	bhi.n	8001384 <HAL_RCC_ClockConfig+0x28>
    }
  }

#endif /* FLASH_ACR_LATENCY */
  /*-------------------------- HCLK Configuration --------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 800136e:	6831      	ldr	r1, [r6, #0]
 8001370:	078c      	lsls	r4, r1, #30
 8001372:	d513      	bpl.n	800139c <HAL_RCC_ClockConfig+0x40>
  {
    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8001374:	484f      	ldr	r0, [pc, #316]	; (80014b4 <HAL_RCC_ClockConfig+0x158>)
 8001376:	6843      	ldr	r3, [r0, #4]
 8001378:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
 800137c:	68b3      	ldr	r3, [r6, #8]
 800137e:	4313      	orrs	r3, r2
 8001380:	6043      	str	r3, [r0, #4]
 8001382:	e00b      	b.n	800139c <HAL_RCC_ClockConfig+0x40>
#if defined(FLASH_ACR_LATENCY)
  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
  {    
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8001384:	6813      	ldr	r3, [r2, #0]
 8001386:	f023 0307 	bic.w	r3, r3, #7
 800138a:	430b      	orrs	r3, r1
 800138c:	6013      	str	r3, [r2, #0]
    
    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 800138e:	6813      	ldr	r3, [r2, #0]
 8001390:	f003 0307 	and.w	r3, r3, #7
 8001394:	428b      	cmp	r3, r1
 8001396:	d0ea      	beq.n	800136e <HAL_RCC_ClockConfig+0x12>
    {
      return HAL_ERROR;
 8001398:	2001      	movs	r0, #1
 800139a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
  }

  /*------------------------- SYSCLK Configuration ---------------------------*/ 
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 800139c:	07c8      	lsls	r0, r1, #31
 800139e:	d406      	bmi.n	80013ae <HAL_RCC_ClockConfig+0x52>
      }
    }      
  }    
#if defined(FLASH_ACR_LATENCY)
  /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLatency < (FLASH->ACR & FLASH_ACR_LATENCY))
 80013a0:	4a43      	ldr	r2, [pc, #268]	; (80014b0 <HAL_RCC_ClockConfig+0x154>)
 80013a2:	6813      	ldr	r3, [r2, #0]
 80013a4:	f003 0307 	and.w	r3, r3, #7
 80013a8:	429d      	cmp	r5, r3
 80013aa:	d34d      	bcc.n	8001448 <HAL_RCC_ClockConfig+0xec>
 80013ac:	e056      	b.n	800145c <HAL_RCC_ClockConfig+0x100>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
  {    
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
    
    /* HSE is selected as System Clock Source */
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80013ae:	6872      	ldr	r2, [r6, #4]
 80013b0:	4c40      	ldr	r4, [pc, #256]	; (80014b4 <HAL_RCC_ClockConfig+0x158>)
 80013b2:	2a01      	cmp	r2, #1
 80013b4:	d102      	bne.n	80013bc <HAL_RCC_ClockConfig+0x60>
 80013b6:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 80013ba:	e004      	b.n	80013c6 <HAL_RCC_ClockConfig+0x6a>
      {
        return HAL_ERROR;
      }
    }
    /* PLL is selected as System Clock Source */
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 80013bc:	2a02      	cmp	r2, #2
 80013be:	bf0c      	ite	eq
 80013c0:	f04f 7300 	moveq.w	r3, #33554432	; 0x2000000
 80013c4:	2302      	movne	r3, #2
 80013c6:	fa93 f1a3 	rbit	r1, r3
    }
    /* HSI is selected as System Clock Source */
    else
    {
      /* Check the HSI ready flag */  
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80013ca:	6821      	ldr	r1, [r4, #0]
 80013cc:	fa93 f3a3 	rbit	r3, r3
 80013d0:	fab3 f383 	clz	r3, r3
 80013d4:	f003 031f 	and.w	r3, r3, #31
 80013d8:	fa21 f303 	lsr.w	r3, r1, r3
 80013dc:	07d9      	lsls	r1, r3, #31
 80013de:	d5db      	bpl.n	8001398 <HAL_RCC_ClockConfig+0x3c>
      {
        return HAL_ERROR;
      }
    }
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 80013e0:	6863      	ldr	r3, [r4, #4]
 80013e2:	f023 0303 	bic.w	r3, r3, #3
 80013e6:	431a      	orrs	r2, r3
 80013e8:	6062      	str	r2, [r4, #4]

    /* Get Start Tick */
    tickstart = HAL_GetTick();
 80013ea:	f000 f8b5 	bl	8001558 <HAL_GetTick>
    
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80013ee:	6873      	ldr	r3, [r6, #4]
      }
    }
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);

    /* Get Start Tick */
    tickstart = HAL_GetTick();
 80013f0:	4607      	mov	r7, r0
    
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80013f2:	2b01      	cmp	r3, #1
 80013f4:	d10d      	bne.n	8001412 <HAL_RCC_ClockConfig+0xb6>
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 80013f6:	6863      	ldr	r3, [r4, #4]
 80013f8:	f003 030c 	and.w	r3, r3, #12
 80013fc:	2b04      	cmp	r3, #4
 80013fe:	d0cf      	beq.n	80013a0 <HAL_RCC_ClockConfig+0x44>
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001400:	f000 f8aa 	bl	8001558 <HAL_GetTick>
 8001404:	f241 3388 	movw	r3, #5000	; 0x1388
 8001408:	1bc0      	subs	r0, r0, r7
 800140a:	4298      	cmp	r0, r3
 800140c:	d9f3      	bls.n	80013f6 <HAL_RCC_ClockConfig+0x9a>
        {
          return HAL_TIMEOUT;
 800140e:	2003      	movs	r0, #3
 8001410:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        }
      }
    }
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8001412:	2b02      	cmp	r3, #2
 8001414:	d113      	bne.n	800143e <HAL_RCC_ClockConfig+0xe2>
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8001416:	6863      	ldr	r3, [r4, #4]
 8001418:	f003 030c 	and.w	r3, r3, #12
 800141c:	2b08      	cmp	r3, #8
 800141e:	d0bf      	beq.n	80013a0 <HAL_RCC_ClockConfig+0x44>
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001420:	f000 f89a 	bl	8001558 <HAL_GetTick>
 8001424:	f241 3388 	movw	r3, #5000	; 0x1388
 8001428:	1bc0      	subs	r0, r0, r7
 800142a:	4298      	cmp	r0, r3
 800142c:	d9f3      	bls.n	8001416 <HAL_RCC_ClockConfig+0xba>
 800142e:	e7ee      	b.n	800140e <HAL_RCC_ClockConfig+0xb2>
    }
    else
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001430:	f000 f892 	bl	8001558 <HAL_GetTick>
 8001434:	f241 3388 	movw	r3, #5000	; 0x1388
 8001438:	1bc0      	subs	r0, r0, r7
 800143a:	4298      	cmp	r0, r3
 800143c:	d8e7      	bhi.n	800140e <HAL_RCC_ClockConfig+0xb2>
        }
      }
    }
    else
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
 800143e:	6863      	ldr	r3, [r4, #4]
 8001440:	f013 0f0c 	tst.w	r3, #12
 8001444:	d1f4      	bne.n	8001430 <HAL_RCC_ClockConfig+0xd4>
 8001446:	e7ab      	b.n	80013a0 <HAL_RCC_ClockConfig+0x44>
#if defined(FLASH_ACR_LATENCY)
  /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLatency < (FLASH->ACR & FLASH_ACR_LATENCY))
  {    
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8001448:	6813      	ldr	r3, [r2, #0]
 800144a:	f023 0307 	bic.w	r3, r3, #7
 800144e:	432b      	orrs	r3, r5
 8001450:	6013      	str	r3, [r2, #0]
    
    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 8001452:	6813      	ldr	r3, [r2, #0]
 8001454:	f003 0307 	and.w	r3, r3, #7
 8001458:	42ab      	cmp	r3, r5
 800145a:	d19d      	bne.n	8001398 <HAL_RCC_ClockConfig+0x3c>
    }
  }    
#endif /* FLASH_ACR_LATENCY */

  /*-------------------------- PCLK1 Configuration ---------------------------*/ 
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 800145c:	6831      	ldr	r1, [r6, #0]
 800145e:	4c15      	ldr	r4, [pc, #84]	; (80014b4 <HAL_RCC_ClockConfig+0x158>)
 8001460:	f011 0f04 	tst.w	r1, #4
 8001464:	d005      	beq.n	8001472 <HAL_RCC_ClockConfig+0x116>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 8001466:	6863      	ldr	r3, [r4, #4]
 8001468:	f423 62e0 	bic.w	r2, r3, #1792	; 0x700
 800146c:	68f3      	ldr	r3, [r6, #12]
 800146e:	4313      	orrs	r3, r2
 8001470:	6063      	str	r3, [r4, #4]
  }
  
  /*-------------------------- PCLK2 Configuration ---------------------------*/ 
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8001472:	070b      	lsls	r3, r1, #28
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
 8001474:	bf41      	itttt	mi
 8001476:	6863      	ldrmi	r3, [r4, #4]
 8001478:	6932      	ldrmi	r2, [r6, #16]
 800147a:	f423 5360 	bicmi.w	r3, r3, #14336	; 0x3800
 800147e:	ea43 03c2 	orrmi.w	r3, r3, r2, lsl #3
 8001482:	bf48      	it	mi
 8001484:	6063      	strmi	r3, [r4, #4]
  }
 
  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_BITNUMBER];
 8001486:	f7ff ff21 	bl	80012cc <HAL_RCC_GetSysClockFreq>
 800148a:	6863      	ldr	r3, [r4, #4]
 800148c:	22f0      	movs	r2, #240	; 0xf0
 800148e:	fa92 f2a2 	rbit	r2, r2
 8001492:	fab2 f282 	clz	r2, r2
 8001496:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 800149a:	40d3      	lsrs	r3, r2
 800149c:	4a06      	ldr	r2, [pc, #24]	; (80014b8 <HAL_RCC_ClockConfig+0x15c>)
 800149e:	5cd3      	ldrb	r3, [r2, r3]
 80014a0:	40d8      	lsrs	r0, r3
 80014a2:	4b06      	ldr	r3, [pc, #24]	; (80014bc <HAL_RCC_ClockConfig+0x160>)
 80014a4:	6018      	str	r0, [r3, #0]

  /* Configure the source of time base considering new system clocks settings*/
  HAL_InitTick (TICK_INT_PRIORITY);
 80014a6:	200f      	movs	r0, #15
 80014a8:	f000 f829 	bl	80014fe <HAL_InitTick>
  
  return HAL_OK;
 80014ac:	2000      	movs	r0, #0
}
 80014ae:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80014b0:	40022000 	.word	0x40022000
 80014b4:	40021000 	.word	0x40021000
 80014b8:	08001da1 	.word	0x08001da1
 80014bc:	2000042c 	.word	0x2000042c

080014c0 <HAL_RCC_GetHCLKFreq>:
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
  return SystemCoreClock;
}
 80014c0:	4b01      	ldr	r3, [pc, #4]	; (80014c8 <HAL_RCC_GetHCLKFreq+0x8>)
 80014c2:	6818      	ldr	r0, [r3, #0]
 80014c4:	4770      	bx	lr
 80014c6:	bf00      	nop
 80014c8:	2000042c 	.word	0x2000042c

080014cc <HAL_RCC_GetPCLK1Freq>:
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_BITNUMBER]);
 80014cc:	4b08      	ldr	r3, [pc, #32]	; (80014f0 <HAL_RCC_GetPCLK1Freq+0x24>)
 80014ce:	f44f 62e0 	mov.w	r2, #1792	; 0x700
 80014d2:	685b      	ldr	r3, [r3, #4]
 80014d4:	fa92 f2a2 	rbit	r2, r2
 80014d8:	fab2 f282 	clz	r2, r2
 80014dc:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 80014e0:	40d3      	lsrs	r3, r2
 80014e2:	4a04      	ldr	r2, [pc, #16]	; (80014f4 <HAL_RCC_GetPCLK1Freq+0x28>)
 80014e4:	5cd3      	ldrb	r3, [r2, r3]
 80014e6:	4a04      	ldr	r2, [pc, #16]	; (80014f8 <HAL_RCC_GetPCLK1Freq+0x2c>)
 80014e8:	6810      	ldr	r0, [r2, #0]
}    
 80014ea:	40d8      	lsrs	r0, r3
 80014ec:	4770      	bx	lr
 80014ee:	bf00      	nop
 80014f0:	40021000 	.word	0x40021000
 80014f4:	08001db1 	.word	0x08001db1
 80014f8:	2000042c 	.word	0x2000042c

080014fc <HAL_MspInit>:
/**
  * @brief  Initializes the MSP.
  * @retval None
  */
__weak void HAL_MspInit(void)
{
 80014fc:	4770      	bx	lr

080014fe <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 80014fe:	b510      	push	{r4, lr}
 8001500:	4604      	mov	r4, r0
  /*Configure the SysTick to have interrupt in 1ms time basis*/
  HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
 8001502:	f7ff ffdd 	bl	80014c0 <HAL_RCC_GetHCLKFreq>
 8001506:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 800150a:	fbb0 f0f3 	udiv	r0, r0, r3
 800150e:	f000 f889 	bl	8001624 <HAL_SYSTICK_Config>

  /*Configure the SysTick IRQ priority */
  HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority ,0);
 8001512:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8001516:	4621      	mov	r1, r4
 8001518:	2200      	movs	r2, #0
 800151a:	f000 f853 	bl	80015c4 <HAL_NVIC_SetPriority>

   /* Return function status */
  return HAL_OK;
}
 800151e:	2000      	movs	r0, #0
 8001520:	bd10      	pop	{r4, pc}
	...

08001524 <HAL_Init>:
    defined(STM32F102x6) || defined(STM32F102xB) || \
    defined(STM32F103x6) || defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG) || \
    defined(STM32F105xC) || defined(STM32F107xC)

  /* Prefetch buffer is not available on value line devices */
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8001524:	4a07      	ldr	r2, [pc, #28]	; (8001544 <HAL_Init+0x20>)
  *        In the default implementation,Systick is used as source of time base.
  *       The tick variable is incremented each 1ms in its ISR.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 8001526:	b508      	push	{r3, lr}
    defined(STM32F102x6) || defined(STM32F102xB) || \
    defined(STM32F103x6) || defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG) || \
    defined(STM32F105xC) || defined(STM32F107xC)

  /* Prefetch buffer is not available on value line devices */
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8001528:	6813      	ldr	r3, [r2, #0]
#endif
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 800152a:	2003      	movs	r0, #3
    defined(STM32F102x6) || defined(STM32F102xB) || \
    defined(STM32F103x6) || defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG) || \
    defined(STM32F105xC) || defined(STM32F107xC)

  /* Prefetch buffer is not available on value line devices */
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 800152c:	f043 0310 	orr.w	r3, r3, #16
 8001530:	6013      	str	r3, [r2, #0]
#endif
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8001532:	f000 f835 	bl	80015a0 <HAL_NVIC_SetPriorityGrouping>

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is MSI) */
  HAL_InitTick(TICK_INT_PRIORITY);
 8001536:	200f      	movs	r0, #15
 8001538:	f7ff ffe1 	bl	80014fe <HAL_InitTick>

  /* Init the low level hardware */
  HAL_MspInit();
 800153c:	f7ff ffde 	bl	80014fc <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
}
 8001540:	2000      	movs	r0, #0
 8001542:	bd08      	pop	{r3, pc}
 8001544:	40022000 	.word	0x40022000

08001548 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick++;
 8001548:	4a02      	ldr	r2, [pc, #8]	; (8001554 <HAL_IncTick+0xc>)
 800154a:	6813      	ldr	r3, [r2, #0]
 800154c:	3301      	adds	r3, #1
 800154e:	6013      	str	r3, [r2, #0]
 8001550:	4770      	bx	lr
 8001552:	bf00      	nop
 8001554:	20000574 	.word	0x20000574

08001558 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 8001558:	4b01      	ldr	r3, [pc, #4]	; (8001560 <HAL_GetTick+0x8>)
 800155a:	6818      	ldr	r0, [r3, #0]
}
 800155c:	4770      	bx	lr
 800155e:	bf00      	nop
 8001560:	20000574 	.word	0x20000574

08001564 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay: specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(__IO uint32_t Delay)
{
 8001564:	b513      	push	{r0, r1, r4, lr}
 8001566:	9001      	str	r0, [sp, #4]
  uint32_t tickstart = 0;
  tickstart = HAL_GetTick();
 8001568:	f7ff fff6 	bl	8001558 <HAL_GetTick>
 800156c:	4604      	mov	r4, r0
  while((HAL_GetTick() - tickstart) < Delay)
 800156e:	f7ff fff3 	bl	8001558 <HAL_GetTick>
 8001572:	9b01      	ldr	r3, [sp, #4]
 8001574:	1b00      	subs	r0, r0, r4
 8001576:	4298      	cmp	r0, r3
 8001578:	d3f9      	bcc.n	800156e <HAL_Delay+0xa>
  {
  }
}
 800157a:	b002      	add	sp, #8
 800157c:	bd10      	pop	{r4, pc}
	...

08001580 <HAL_SuspendTick>:
  * @retval None
  */
__weak void HAL_SuspendTick(void)
{
  /* Disable SysTick Interrupt */
  CLEAR_BIT(SysTick->CTRL,SysTick_CTRL_TICKINT_Msk);
 8001580:	4a02      	ldr	r2, [pc, #8]	; (800158c <HAL_SuspendTick+0xc>)
 8001582:	6813      	ldr	r3, [r2, #0]
 8001584:	f023 0302 	bic.w	r3, r3, #2
 8001588:	6013      	str	r3, [r2, #0]
 800158a:	4770      	bx	lr
 800158c:	e000e010 	.word	0xe000e010

08001590 <HAL_ResumeTick>:
  * @retval None
  */
__weak void HAL_ResumeTick(void)
{
  /* Enable SysTick Interrupt */
  SET_BIT(SysTick->CTRL,SysTick_CTRL_TICKINT_Msk);
 8001590:	4a02      	ldr	r2, [pc, #8]	; (800159c <HAL_ResumeTick+0xc>)
 8001592:	6813      	ldr	r3, [r2, #0]
 8001594:	f043 0302 	orr.w	r3, r3, #2
 8001598:	6013      	str	r3, [r2, #0]
 800159a:	4770      	bx	lr
 800159c:	e000e010 	.word	0xe000e010

080015a0 <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 80015a0:	4a07      	ldr	r2, [pc, #28]	; (80015c0 <HAL_NVIC_SetPriorityGrouping+0x20>)
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 80015a2:	f000 0007 	and.w	r0, r0, #7

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 80015a6:	68d3      	ldr	r3, [r2, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 80015a8:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 80015ac:	041b      	lsls	r3, r3, #16
 80015ae:	0c1b      	lsrs	r3, r3, #16
 80015b0:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 80015b4:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  reg_value  =  (reg_value                                   |
 80015b8:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 80015bc:	60d3      	str	r3, [r2, #12]
 80015be:	4770      	bx	lr
 80015c0:	e000ed00 	.word	0xe000ed00

080015c4 <HAL_NVIC_SetPriority>:
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 80015c4:	4b15      	ldr	r3, [pc, #84]	; (800161c <HAL_NVIC_SetPriority+0x58>)
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 80015c6:	b570      	push	{r4, r5, r6, lr}
 80015c8:	68db      	ldr	r3, [r3, #12]
 80015ca:	f3c3 2302 	ubfx	r3, r3, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 80015ce:	f1c3 0507 	rsb	r5, r3, #7
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80015d2:	1d1c      	adds	r4, r3, #4
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 80015d4:	2d04      	cmp	r5, #4
 80015d6:	bf28      	it	cs
 80015d8:	2504      	movcs	r5, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80015da:	2c06      	cmp	r4, #6
 80015dc:	bf8c      	ite	hi
 80015de:	3b03      	subhi	r3, #3
 80015e0:	2300      	movls	r3, #0

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 80015e2:	2401      	movs	r4, #1
 80015e4:	fa04 f603 	lsl.w	r6, r4, r3

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 80015e8:	40ac      	lsls	r4, r5
 80015ea:	3c01      	subs	r4, #1
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 80015ec:	3e01      	subs	r6, #1

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 80015ee:	4021      	ands	r1, r4
 80015f0:	4099      	lsls	r1, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 80015f2:	4032      	ands	r2, r6
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
 80015f4:	2800      	cmp	r0, #0
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
 80015f6:	ea42 0201 	orr.w	r2, r2, r1
 80015fa:	ea4f 1202 	mov.w	r2, r2, lsl #4
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
  else
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80015fe:	bfaf      	iteee	ge
 8001600:	f100 4060 	addge.w	r0, r0, #3758096384	; 0xe0000000
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8001604:	4b06      	ldrlt	r3, [pc, #24]	; (8001620 <HAL_NVIC_SetPriority+0x5c>)
 8001606:	f000 000f 	andlt.w	r0, r0, #15
 800160a:	b2d2      	uxtblt	r2, r2
  }
  else
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800160c:	bfa5      	ittet	ge
 800160e:	b2d2      	uxtbge	r2, r2
 8001610:	f500 4061 	addge.w	r0, r0, #57600	; 0xe100
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8001614:	541a      	strblt	r2, [r3, r0]
  }
  else
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8001616:	f880 2300 	strbge.w	r2, [r0, #768]	; 0x300
 800161a:	bd70      	pop	{r4, r5, r6, pc}
 800161c:	e000ed00 	.word	0xe000ed00
 8001620:	e000ed14 	.word	0xe000ed14

08001624 <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8001624:	3801      	subs	r0, #1
 8001626:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 800162a:	bf3f      	itttt	cc
 800162c:	4b06      	ldrcc	r3, [pc, #24]	; (8001648 <HAL_SYSTICK_Config+0x24>)
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800162e:	4a07      	ldrcc	r2, [pc, #28]	; (800164c <HAL_SYSTICK_Config+0x28>)
 8001630:	21f0      	movcc	r1, #240	; 0xf0
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8001632:	6058      	strcc	r0, [r3, #4]
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8001634:	bf3f      	itttt	cc
 8001636:	f882 1023 	strbcc.w	r1, [r2, #35]	; 0x23
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 800163a:	2000      	movcc	r0, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 800163c:	2207      	movcc	r2, #7
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 800163e:	6098      	strcc	r0, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8001640:	bf34      	ite	cc
 8001642:	601a      	strcc	r2, [r3, #0]
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
  {
    return (1UL);                                                   /* Reload value impossible */
 8001644:	2001      	movcs	r0, #1
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
   return SysTick_Config(TicksNumb);
}
 8001646:	4770      	bx	lr
 8001648:	e000e010 	.word	0xe000e010
 800164c:	e000ed00 	.word	0xe000ed00

08001650 <HAL_GPIO_Init>:
{
  uint32_t position;
  uint32_t ioposition = 0x00;
  uint32_t iocurrent = 0x00;
  uint32_t temp = 0x00;
  uint32_t config = 0x00;
 8001650:	2300      	movs	r3, #0
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8001652:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));

  /* Configure the port pins */
  for (position = 0; position < GPIO_NUMBER; position++)
 8001654:	461d      	mov	r5, r3
  {
    /* Get the IO position */
    ioposition = ((uint32_t)0x01) << position;
 8001656:	2201      	movs	r2, #1
    
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8001658:	680c      	ldr	r4, [r1, #0]

  /* Configure the port pins */
  for (position = 0; position < GPIO_NUMBER; position++)
  {
    /* Get the IO position */
    ioposition = ((uint32_t)0x01) << position;
 800165a:	40aa      	lsls	r2, r5
    
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 800165c:	4014      	ands	r4, r2

    if (iocurrent == ioposition)
 800165e:	4294      	cmp	r4, r2
 8001660:	f040 80ac 	bne.w	80017bc <HAL_GPIO_Init+0x16c>
    {
      /* Check the Alternate function parameters */
      assert_param(IS_GPIO_AF_INSTANCE(GPIOx));

      /* Based on the required mode, filling config variable with MODEy[1:0] and CNFy[3:2] corresponding bits */
      switch (GPIO_Init->Mode)
 8001664:	684a      	ldr	r2, [r1, #4]
 8001666:	2a12      	cmp	r2, #18
 8001668:	d02b      	beq.n	80016c2 <HAL_GPIO_Init+0x72>
 800166a:	d80e      	bhi.n	800168a <HAL_GPIO_Init+0x3a>
 800166c:	2a02      	cmp	r2, #2
 800166e:	d025      	beq.n	80016bc <HAL_GPIO_Init+0x6c>
 8001670:	d804      	bhi.n	800167c <HAL_GPIO_Init+0x2c>
 8001672:	b34a      	cbz	r2, 80016c8 <HAL_GPIO_Init+0x78>
 8001674:	2a01      	cmp	r2, #1
 8001676:	d130      	bne.n	80016da <HAL_GPIO_Init+0x8a>
      {
        /* If we are configuring the pin in OUTPUT push-pull mode */
        case GPIO_MODE_OUTPUT_PP:
          /* Check the GPIO speed parameter */
          assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
          config = GPIO_Init->Speed + GPIO_CR_CNF_GP_OUTPUT_PP;
 8001678:	68cb      	ldr	r3, [r1, #12]
          break;
 800167a:	e02e      	b.n	80016da <HAL_GPIO_Init+0x8a>
    {
      /* Check the Alternate function parameters */
      assert_param(IS_GPIO_AF_INSTANCE(GPIOx));

      /* Based on the required mode, filling config variable with MODEy[1:0] and CNFy[3:2] corresponding bits */
      switch (GPIO_Init->Mode)
 800167c:	2a03      	cmp	r2, #3
 800167e:	d01b      	beq.n	80016b8 <HAL_GPIO_Init+0x68>
 8001680:	2a11      	cmp	r2, #17
 8001682:	d12a      	bne.n	80016da <HAL_GPIO_Init+0x8a>
          
        /* If we are configuring the pin in OUTPUT open-drain mode */
        case GPIO_MODE_OUTPUT_OD:
          /* Check the GPIO speed parameter */
          assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
          config = GPIO_Init->Speed + GPIO_CR_CNF_GP_OUTPUT_OD;
 8001684:	68cb      	ldr	r3, [r1, #12]
 8001686:	3304      	adds	r3, #4
          break;
 8001688:	e027      	b.n	80016da <HAL_GPIO_Init+0x8a>
    {
      /* Check the Alternate function parameters */
      assert_param(IS_GPIO_AF_INSTANCE(GPIOx));

      /* Based on the required mode, filling config variable with MODEy[1:0] and CNFy[3:2] corresponding bits */
      switch (GPIO_Init->Mode)
 800168a:	4e4f      	ldr	r6, [pc, #316]	; (80017c8 <HAL_GPIO_Init+0x178>)
 800168c:	42b2      	cmp	r2, r6
 800168e:	d01b      	beq.n	80016c8 <HAL_GPIO_Init+0x78>
 8001690:	d806      	bhi.n	80016a0 <HAL_GPIO_Init+0x50>
 8001692:	f5a6 1680 	sub.w	r6, r6, #1048576	; 0x100000
 8001696:	42b2      	cmp	r2, r6
 8001698:	d016      	beq.n	80016c8 <HAL_GPIO_Init+0x78>
 800169a:	f506 3680 	add.w	r6, r6, #65536	; 0x10000
 800169e:	e008      	b.n	80016b2 <HAL_GPIO_Init+0x62>
 80016a0:	4e4a      	ldr	r6, [pc, #296]	; (80017cc <HAL_GPIO_Init+0x17c>)
 80016a2:	42b2      	cmp	r2, r6
 80016a4:	d010      	beq.n	80016c8 <HAL_GPIO_Init+0x78>
 80016a6:	f506 3680 	add.w	r6, r6, #65536	; 0x10000
 80016aa:	42b2      	cmp	r2, r6
 80016ac:	d00c      	beq.n	80016c8 <HAL_GPIO_Init+0x78>
 80016ae:	f5a6 1680 	sub.w	r6, r6, #1048576	; 0x100000
 80016b2:	42b2      	cmp	r2, r6
 80016b4:	d111      	bne.n	80016da <HAL_GPIO_Init+0x8a>
 80016b6:	e007      	b.n	80016c8 <HAL_GPIO_Init+0x78>
          }
          break; 
          
        /* If we are configuring the pin in INPUT analog mode */
        case GPIO_MODE_ANALOG:
            config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_ANALOG;
 80016b8:	2300      	movs	r3, #0
 80016ba:	e00e      	b.n	80016da <HAL_GPIO_Init+0x8a>
          
        /* If we are configuring the pin in ALTERNATE FUNCTION push-pull mode */
        case GPIO_MODE_AF_PP:
          /* Check the GPIO speed parameter */
          assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
          config = GPIO_Init->Speed + GPIO_CR_CNF_AF_OUTPUT_PP;
 80016bc:	68cb      	ldr	r3, [r1, #12]
 80016be:	3308      	adds	r3, #8
          break;
 80016c0:	e00b      	b.n	80016da <HAL_GPIO_Init+0x8a>
          
        /* If we are configuring the pin in ALTERNATE FUNCTION open-drain mode */
        case GPIO_MODE_AF_OD:
          /* Check the GPIO speed parameter */
          assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
          config = GPIO_Init->Speed + GPIO_CR_CNF_AF_OUTPUT_OD;
 80016c2:	68cb      	ldr	r3, [r1, #12]
 80016c4:	330c      	adds	r3, #12
          break;
 80016c6:	e008      	b.n	80016da <HAL_GPIO_Init+0x8a>
        case GPIO_MODE_EVT_RISING:
        case GPIO_MODE_EVT_FALLING:
        case GPIO_MODE_EVT_RISING_FALLING:
          /* Check the GPIO pull parameter */
          assert_param(IS_GPIO_PULL(GPIO_Init->Pull));
          if(GPIO_Init->Pull == GPIO_NOPULL)
 80016c8:	688b      	ldr	r3, [r1, #8]
 80016ca:	b12b      	cbz	r3, 80016d8 <HAL_GPIO_Init+0x88>
          {  
            config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_FLOATING;
          }
          else if(GPIO_Init->Pull == GPIO_PULLUP)
 80016cc:	2b01      	cmp	r3, #1
          {
            config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_PU_PD;
            
            /* Set the corresponding ODR bit */
            GPIOx->BSRR = ioposition;
 80016ce:	bf0c      	ite	eq
 80016d0:	6104      	streq	r4, [r0, #16]
          else /* GPIO_PULLDOWN */
          {
            config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_PU_PD;
            
            /* Reset the corresponding ODR bit */
            GPIOx->BRR = ioposition;
 80016d2:	6144      	strne	r4, [r0, #20]
            /* Set the corresponding ODR bit */
            GPIOx->BSRR = ioposition;
          }
          else /* GPIO_PULLDOWN */
          {
            config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_PU_PD;
 80016d4:	2308      	movs	r3, #8
 80016d6:	e000      	b.n	80016da <HAL_GPIO_Init+0x8a>
        case GPIO_MODE_EVT_RISING_FALLING:
          /* Check the GPIO pull parameter */
          assert_param(IS_GPIO_PULL(GPIO_Init->Pull));
          if(GPIO_Init->Pull == GPIO_NOPULL)
          {  
            config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_FLOATING;
 80016d8:	2304      	movs	r3, #4
          break;
      }
      
      /* Check if the current bit belongs to first half or last half of the pin count number
       in order to address CRH or CRL register*/
      configregister = (iocurrent < GPIO_PIN_8) ? &GPIOx->CRL     : &GPIOx->CRH;
 80016da:	2cff      	cmp	r4, #255	; 0xff
 80016dc:	bf97      	itett	ls
 80016de:	4686      	movls	lr, r0
 80016e0:	f1a5 0708 	subhi.w	r7, r5, #8
 80016e4:	6806      	ldrls	r6, [r0, #0]
      registeroffset = (iocurrent < GPIO_PIN_8) ? (position << 2) : ((position - 8) << 2);
 80016e6:	00af      	lslls	r7, r5, #2
          break;
      }
      
      /* Check if the current bit belongs to first half or last half of the pin count number
       in order to address CRH or CRL register*/
      configregister = (iocurrent < GPIO_PIN_8) ? &GPIOx->CRL     : &GPIOx->CRH;
 80016e8:	bf84      	itt	hi
 80016ea:	6846      	ldrhi	r6, [r0, #4]
      registeroffset = (iocurrent < GPIO_PIN_8) ? (position << 2) : ((position - 8) << 2);
 80016ec:	00bf      	lslhi	r7, r7, #2
      
      /* Apply the new configuration of the pin to the register */
      MODIFY_REG((*configregister), ((GPIO_CRL_MODE0 | GPIO_CRL_CNF0) << registeroffset ), (config << registeroffset));
 80016ee:	f04f 020f 	mov.w	r2, #15
 80016f2:	fa02 fc07 	lsl.w	ip, r2, r7
 80016f6:	ea26 060c 	bic.w	r6, r6, ip
 80016fa:	fa03 f707 	lsl.w	r7, r3, r7
 80016fe:	ea46 0607 	orr.w	r6, r6, r7
          break;
      }
      
      /* Check if the current bit belongs to first half or last half of the pin count number
       in order to address CRH or CRL register*/
      configregister = (iocurrent < GPIO_PIN_8) ? &GPIOx->CRL     : &GPIOx->CRH;
 8001702:	bf88      	it	hi
 8001704:	f100 0e04 	addhi.w	lr, r0, #4
      registeroffset = (iocurrent < GPIO_PIN_8) ? (position << 2) : ((position - 8) << 2);
      
      /* Apply the new configuration of the pin to the register */
      MODIFY_REG((*configregister), ((GPIO_CRL_MODE0 | GPIO_CRL_CNF0) << registeroffset ), (config << registeroffset));
 8001708:	f8ce 6000 	str.w	r6, [lr]
      
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE) 
 800170c:	684f      	ldr	r7, [r1, #4]
 800170e:	00fe      	lsls	r6, r7, #3
 8001710:	d554      	bpl.n	80017bc <HAL_GPIO_Init+0x16c>
      {
        /* Enable AFIO Clock */
        __HAL_RCC_AFIO_CLK_ENABLE();
 8001712:	4e2f      	ldr	r6, [pc, #188]	; (80017d0 <HAL_GPIO_Init+0x180>)
        temp = AFIO->EXTICR[position >> 2];
        CLEAR_BIT(temp, ((uint32_t)0x0F) << (4 * (position & 0x03)));
 8001714:	f005 0c03 	and.w	ip, r5, #3
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE) 
      {
        /* Enable AFIO Clock */
        __HAL_RCC_AFIO_CLK_ENABLE();
 8001718:	f8d6 e018 	ldr.w	lr, [r6, #24]
        temp = AFIO->EXTICR[position >> 2];
        CLEAR_BIT(temp, ((uint32_t)0x0F) << (4 * (position & 0x03)));
 800171c:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE) 
      {
        /* Enable AFIO Clock */
        __HAL_RCC_AFIO_CLK_ENABLE();
 8001720:	f04e 0e01 	orr.w	lr, lr, #1
 8001724:	f8c6 e018 	str.w	lr, [r6, #24]
 8001728:	69b6      	ldr	r6, [r6, #24]
        temp = AFIO->EXTICR[position >> 2];
        CLEAR_BIT(temp, ((uint32_t)0x0F) << (4 * (position & 0x03)));
 800172a:	fa02 f20c 	lsl.w	r2, r2, ip
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE) 
      {
        /* Enable AFIO Clock */
        __HAL_RCC_AFIO_CLK_ENABLE();
 800172e:	f006 0601 	and.w	r6, r6, #1
 8001732:	9601      	str	r6, [sp, #4]
 8001734:	9e01      	ldr	r6, [sp, #4]
 8001736:	f025 0603 	bic.w	r6, r5, #3
 800173a:	f106 4680 	add.w	r6, r6, #1073741824	; 0x40000000
 800173e:	f506 3680 	add.w	r6, r6, #65536	; 0x10000
        temp = AFIO->EXTICR[position >> 2];
 8001742:	f8d6 e008 	ldr.w	lr, [r6, #8]
        CLEAR_BIT(temp, ((uint32_t)0x0F) << (4 * (position & 0x03)));
 8001746:	ea2e 0e02 	bic.w	lr, lr, r2
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 800174a:	4a22      	ldr	r2, [pc, #136]	; (80017d4 <HAL_GPIO_Init+0x184>)
 800174c:	4290      	cmp	r0, r2
 800174e:	d00e      	beq.n	800176e <HAL_GPIO_Init+0x11e>
 8001750:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8001754:	4290      	cmp	r0, r2
 8001756:	d00c      	beq.n	8001772 <HAL_GPIO_Init+0x122>
 8001758:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800175c:	4290      	cmp	r0, r2
 800175e:	d00a      	beq.n	8001776 <HAL_GPIO_Init+0x126>
 8001760:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8001764:	4290      	cmp	r0, r2
 8001766:	bf0c      	ite	eq
 8001768:	2203      	moveq	r2, #3
 800176a:	2204      	movne	r2, #4
 800176c:	e004      	b.n	8001778 <HAL_GPIO_Init+0x128>
 800176e:	2200      	movs	r2, #0
 8001770:	e002      	b.n	8001778 <HAL_GPIO_Init+0x128>
 8001772:	2201      	movs	r2, #1
 8001774:	e000      	b.n	8001778 <HAL_GPIO_Init+0x128>
 8001776:	2202      	movs	r2, #2
 8001778:	fa02 f20c 	lsl.w	r2, r2, ip
 800177c:	ea42 020e 	orr.w	r2, r2, lr
        AFIO->EXTICR[position >> 2] = temp;
 8001780:	60b2      	str	r2, [r6, #8]
 8001782:	4a15      	ldr	r2, [pc, #84]	; (80017d8 <HAL_GPIO_Init+0x188>)
        

        /* Configure the interrupt mask */
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 8001784:	f417 3f80 	tst.w	r7, #65536	; 0x10000
        {
          SET_BIT(EXTI->IMR, iocurrent); 
 8001788:	6816      	ldr	r6, [r2, #0]
 800178a:	bf14      	ite	ne
 800178c:	4326      	orrne	r6, r4
        } 
        else
        {
          CLEAR_BIT(EXTI->IMR, iocurrent); 
 800178e:	43a6      	biceq	r6, r4
 8001790:	6016      	str	r6, [r2, #0]
        } 
        
        /* Configure the event mask */
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
        {
          SET_BIT(EXTI->EMR, iocurrent); 
 8001792:	6856      	ldr	r6, [r2, #4]
        {
          CLEAR_BIT(EXTI->IMR, iocurrent); 
        } 
        
        /* Configure the event mask */
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 8001794:	f417 3f00 	tst.w	r7, #131072	; 0x20000
        {
          SET_BIT(EXTI->EMR, iocurrent); 
 8001798:	bf14      	ite	ne
 800179a:	4326      	orrne	r6, r4
        } 
        else
        {
          CLEAR_BIT(EXTI->EMR, iocurrent); 
 800179c:	43a6      	biceq	r6, r4
 800179e:	6056      	str	r6, [r2, #4]
        }
        
        /* Enable or disable the rising trigger */
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
        {
          SET_BIT(EXTI->RTSR, iocurrent); 
 80017a0:	6896      	ldr	r6, [r2, #8]
        {
          CLEAR_BIT(EXTI->EMR, iocurrent); 
        }
        
        /* Enable or disable the rising trigger */
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 80017a2:	f417 1f80 	tst.w	r7, #1048576	; 0x100000
        {
          SET_BIT(EXTI->RTSR, iocurrent); 
 80017a6:	bf14      	ite	ne
 80017a8:	4326      	orrne	r6, r4
        } 
        else
        {
          CLEAR_BIT(EXTI->RTSR, iocurrent); 
 80017aa:	43a6      	biceq	r6, r4
 80017ac:	6096      	str	r6, [r2, #8]
        }
        
        /* Enable or disable the falling trigger */
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
        {
          SET_BIT(EXTI->FTSR, iocurrent); 
 80017ae:	68d6      	ldr	r6, [r2, #12]
        {
          CLEAR_BIT(EXTI->RTSR, iocurrent); 
        }
        
        /* Enable or disable the falling trigger */
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 80017b0:	02bf      	lsls	r7, r7, #10
        {
          SET_BIT(EXTI->FTSR, iocurrent); 
 80017b2:	bf4c      	ite	mi
 80017b4:	4334      	orrmi	r4, r6
        } 
        else
        {
          CLEAR_BIT(EXTI->FTSR, iocurrent); 
 80017b6:	ea26 0404 	bicpl.w	r4, r6, r4
 80017ba:	60d4      	str	r4, [r2, #12]
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));

  /* Configure the port pins */
  for (position = 0; position < GPIO_NUMBER; position++)
 80017bc:	3501      	adds	r5, #1
 80017be:	2d10      	cmp	r5, #16
 80017c0:	f47f af49 	bne.w	8001656 <HAL_GPIO_Init+0x6>
          CLEAR_BIT(EXTI->FTSR, iocurrent); 
        }
      }
    }
  }
}
 80017c4:	b003      	add	sp, #12
 80017c6:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80017c8:	10210000 	.word	0x10210000
 80017cc:	10310000 	.word	0x10310000
 80017d0:	40021000 	.word	0x40021000
 80017d4:	40010800 	.word	0x40010800
 80017d8:	40010400 	.word	0x40010400

080017dc <HAL_GPIO_DeInit>:
  * @param  GPIO_Pin: specifies the port bit to be written.
  *         This parameter can be one of GPIO_PIN_x where x can be (0..15).
  * @retval None
  */
void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
{ 
 80017dc:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t position = 0x00;
 80017de:	2500      	movs	r5, #0
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* Configure the port pins */
  while ((GPIO_Pin >> position) != 0)
 80017e0:	fa31 f305 	lsrs.w	r3, r1, r5
 80017e4:	d05d      	beq.n	80018a2 <HAL_GPIO_DeInit+0xc6>
  {
    /* Get current io position */
    iocurrent = (GPIO_Pin) & ((uint32_t)1 << position);
 80017e6:	2401      	movs	r4, #1
 80017e8:	40ac      	lsls	r4, r5

    if (iocurrent)
 80017ea:	400c      	ands	r4, r1
 80017ec:	d057      	beq.n	800189e <HAL_GPIO_DeInit+0xc2>
    {
      /*------------------------- GPIO Mode Configuration --------------------*/
      /* Check if the current bit belongs to first half or last half of the pin count number
       in order to address CRH or CRL register */
      configregister = (iocurrent < GPIO_PIN_8) ? &GPIOx->CRL     : &GPIOx->CRH;
 80017ee:	2cff      	cmp	r4, #255	; 0xff
 80017f0:	bf98      	it	ls
 80017f2:	4686      	movls	lr, r0
      
      /* CRL/CRH default value is floating input(0x04) shifted to correct position */
      MODIFY_REG(*configregister, ((GPIO_CRL_MODE0 | GPIO_CRL_CNF0) << registeroffset ), GPIO_CRL_CNF0_0 << registeroffset);
      
      /* ODR default value is 0 */
      CLEAR_BIT(GPIOx->ODR, iocurrent);
 80017f4:	ea6f 0404 	mvn.w	r4, r4
 80017f8:	bf8b      	itete	hi
 80017fa:	f1a5 0708 	subhi.w	r7, r5, #8
    if (iocurrent)
    {
      /*------------------------- GPIO Mode Configuration --------------------*/
      /* Check if the current bit belongs to first half or last half of the pin count number
       in order to address CRH or CRL register */
      configregister = (iocurrent < GPIO_PIN_8) ? &GPIOx->CRL     : &GPIOx->CRH;
 80017fe:	6803      	ldrls	r3, [r0, #0]
 8001800:	6843      	ldrhi	r3, [r0, #4]
      registeroffset = (iocurrent < GPIO_PIN_8) ? (position << 2) : ((position - 8) << 2);
 8001802:	00af      	lslls	r7, r5, #2
 8001804:	bf88      	it	hi
 8001806:	00bf      	lslhi	r7, r7, #2
      
      /* CRL/CRH default value is floating input(0x04) shifted to correct position */
      MODIFY_REG(*configregister, ((GPIO_CRL_MODE0 | GPIO_CRL_CNF0) << registeroffset ), GPIO_CRL_CNF0_0 << registeroffset);
 8001808:	f04f 060f 	mov.w	r6, #15
 800180c:	fa06 f207 	lsl.w	r2, r6, r7
 8001810:	ea23 0302 	bic.w	r3, r3, r2
 8001814:	f04f 0204 	mov.w	r2, #4
 8001818:	fa02 f207 	lsl.w	r2, r2, r7
    if (iocurrent)
    {
      /*------------------------- GPIO Mode Configuration --------------------*/
      /* Check if the current bit belongs to first half or last half of the pin count number
       in order to address CRH or CRL register */
      configregister = (iocurrent < GPIO_PIN_8) ? &GPIOx->CRL     : &GPIOx->CRH;
 800181c:	bf88      	it	hi
 800181e:	f100 0e04 	addhi.w	lr, r0, #4
      registeroffset = (iocurrent < GPIO_PIN_8) ? (position << 2) : ((position - 8) << 2);
      
      /* CRL/CRH default value is floating input(0x04) shifted to correct position */
      MODIFY_REG(*configregister, ((GPIO_CRL_MODE0 | GPIO_CRL_CNF0) << registeroffset ), GPIO_CRL_CNF0_0 << registeroffset);
 8001822:	4313      	orrs	r3, r2
 8001824:	f8ce 3000 	str.w	r3, [lr]
      
      /* ODR default value is 0 */
      CLEAR_BIT(GPIOx->ODR, iocurrent);
 8001828:	68c3      	ldr	r3, [r0, #12]
 800182a:	f025 0203 	bic.w	r2, r5, #3
 800182e:	4023      	ands	r3, r4
 8001830:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
 8001834:	60c3      	str	r3, [r0, #12]
 8001836:	f502 3280 	add.w	r2, r2, #65536	; 0x10000
      
      /*------------------------- EXTI Mode Configuration --------------------*/
      /* Clear the External Interrupt or Event for the current IO */
      
      tmp = AFIO->EXTICR[position >> 2];
      tmp &= (((uint32_t)0x0F) << (4 * (position & 0x03)));
 800183a:	f005 0703 	and.w	r7, r5, #3
      CLEAR_BIT(GPIOx->ODR, iocurrent);
      
      /*------------------------- EXTI Mode Configuration --------------------*/
      /* Clear the External Interrupt or Event for the current IO */
      
      tmp = AFIO->EXTICR[position >> 2];
 800183e:	6893      	ldr	r3, [r2, #8]
      tmp &= (((uint32_t)0x0F) << (4 * (position & 0x03)));
 8001840:	00bf      	lsls	r7, r7, #2
 8001842:	40be      	lsls	r6, r7
 8001844:	ea06 0e03 	and.w	lr, r6, r3
      if(tmp == (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03))))
 8001848:	4b16      	ldr	r3, [pc, #88]	; (80018a4 <HAL_GPIO_DeInit+0xc8>)
 800184a:	4298      	cmp	r0, r3
 800184c:	d00e      	beq.n	800186c <HAL_GPIO_DeInit+0x90>
 800184e:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8001852:	4298      	cmp	r0, r3
 8001854:	d00c      	beq.n	8001870 <HAL_GPIO_DeInit+0x94>
 8001856:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800185a:	4298      	cmp	r0, r3
 800185c:	d00a      	beq.n	8001874 <HAL_GPIO_DeInit+0x98>
 800185e:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8001862:	4298      	cmp	r0, r3
 8001864:	bf0c      	ite	eq
 8001866:	2303      	moveq	r3, #3
 8001868:	2304      	movne	r3, #4
 800186a:	e004      	b.n	8001876 <HAL_GPIO_DeInit+0x9a>
 800186c:	2300      	movs	r3, #0
 800186e:	e002      	b.n	8001876 <HAL_GPIO_DeInit+0x9a>
 8001870:	2301      	movs	r3, #1
 8001872:	e000      	b.n	8001876 <HAL_GPIO_DeInit+0x9a>
 8001874:	2302      	movs	r3, #2
 8001876:	40bb      	lsls	r3, r7
 8001878:	459e      	cmp	lr, r3
 800187a:	d110      	bne.n	800189e <HAL_GPIO_DeInit+0xc2>
      {
        tmp = ((uint32_t)0x0F) << (4 * (position & 0x03));
        CLEAR_BIT(AFIO->EXTICR[position >> 2], tmp);
 800187c:	6893      	ldr	r3, [r2, #8]
 800187e:	ea23 0606 	bic.w	r6, r3, r6
          
        /* Clear EXTI line configuration */
        CLEAR_BIT(EXTI->IMR, (uint32_t)iocurrent);
 8001882:	4b09      	ldr	r3, [pc, #36]	; (80018a8 <HAL_GPIO_DeInit+0xcc>)
      tmp = AFIO->EXTICR[position >> 2];
      tmp &= (((uint32_t)0x0F) << (4 * (position & 0x03)));
      if(tmp == (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03))))
      {
        tmp = ((uint32_t)0x0F) << (4 * (position & 0x03));
        CLEAR_BIT(AFIO->EXTICR[position >> 2], tmp);
 8001884:	6096      	str	r6, [r2, #8]
          
        /* Clear EXTI line configuration */
        CLEAR_BIT(EXTI->IMR, (uint32_t)iocurrent);
 8001886:	681a      	ldr	r2, [r3, #0]
 8001888:	4022      	ands	r2, r4
 800188a:	601a      	str	r2, [r3, #0]
        CLEAR_BIT(EXTI->EMR, (uint32_t)iocurrent);
 800188c:	685a      	ldr	r2, [r3, #4]
 800188e:	4022      	ands	r2, r4
 8001890:	605a      	str	r2, [r3, #4]
        
        /* Clear Rising Falling edge configuration */
        CLEAR_BIT(EXTI->RTSR, (uint32_t)iocurrent);
 8001892:	689a      	ldr	r2, [r3, #8]
 8001894:	4022      	ands	r2, r4
 8001896:	609a      	str	r2, [r3, #8]
        CLEAR_BIT(EXTI->FTSR, (uint32_t)iocurrent);
 8001898:	68da      	ldr	r2, [r3, #12]
 800189a:	4014      	ands	r4, r2
 800189c:	60dc      	str	r4, [r3, #12]
      }
    }
    
    position++;
 800189e:	3501      	adds	r5, #1
 80018a0:	e79e      	b.n	80017e0 <HAL_GPIO_DeInit+0x4>
  }
}
 80018a2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80018a4:	40010800 	.word	0x40010800
 80018a8:	40010400 	.word	0x40010400

080018ac <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 80018ac:	b902      	cbnz	r2, 80018b0 <HAL_GPIO_WritePin+0x4>
  {
    GPIOx->BSRR = GPIO_Pin;
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16;
 80018ae:	0409      	lsls	r1, r1, #16
 80018b0:	6101      	str	r1, [r0, #16]
 80018b2:	4770      	bx	lr

080018b4 <HAL_I2C_Init>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Init(I2C_HandleTypeDef *hi2c)
{
 80018b4:	b570      	push	{r4, r5, r6, lr}
  uint32_t freqrange = 0;
  uint32_t pclk1 = 0;

  /* Check the I2C handle allocation */
  if(hi2c == NULL)
 80018b6:	4604      	mov	r4, r0
 80018b8:	2800      	cmp	r0, #0
 80018ba:	d05f      	beq.n	800197c <HAL_I2C_Init+0xc8>
  assert_param(IS_I2C_DUAL_ADDRESS(hi2c->Init.DualAddressMode));
  assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
  assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
  assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));

  if(hi2c->State == HAL_I2C_STATE_RESET)
 80018bc:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
 80018c0:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 80018c4:	b91b      	cbnz	r3, 80018ce <HAL_I2C_Init+0x1a>
  {
    /* Allocate lock resource and initialize it */
    hi2c->Lock = HAL_UNLOCKED;
 80018c6:	f880 2034 	strb.w	r2, [r0, #52]	; 0x34
    
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    HAL_I2C_MspInit(hi2c);
 80018ca:	f7ff f8e3 	bl	8000a94 <HAL_I2C_MspInit>
  }

  hi2c->State = HAL_I2C_STATE_BUSY;

  /* Disable the selected I2C peripheral */
  __HAL_I2C_DISABLE(hi2c);
 80018ce:	6822      	ldr	r2, [r4, #0]
    
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    HAL_I2C_MspInit(hi2c);
  }

  hi2c->State = HAL_I2C_STATE_BUSY;
 80018d0:	2324      	movs	r3, #36	; 0x24
 80018d2:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35

  /* Disable the selected I2C peripheral */
  __HAL_I2C_DISABLE(hi2c);
 80018d6:	6813      	ldr	r3, [r2, #0]
  /* Configure I2Cx: Frequency range */
  hi2c->Instance->CR2 = freqrange;

  /*---------------------------- I2Cx TRISE Configuration --------------------*/
  /* Configure I2Cx: Rise Time */
  hi2c->Instance->TRISE = I2C_RISE_TIME(freqrange, hi2c->Init.ClockSpeed);
 80018d8:	4d29      	ldr	r5, [pc, #164]	; (8001980 <HAL_I2C_Init+0xcc>)
  }

  hi2c->State = HAL_I2C_STATE_BUSY;

  /* Disable the selected I2C peripheral */
  __HAL_I2C_DISABLE(hi2c);
 80018da:	f023 0301 	bic.w	r3, r3, #1
 80018de:	6013      	str	r3, [r2, #0]

  /* Get PCLK1 frequency */
  pclk1 = HAL_RCC_GetPCLK1Freq();
 80018e0:	f7ff fdf4 	bl	80014cc <HAL_RCC_GetPCLK1Freq>

  /* Calculate frequency range */
  freqrange = I2C_FREQ_RANGE(pclk1);
 80018e4:	4927      	ldr	r1, [pc, #156]	; (8001984 <HAL_I2C_Init+0xd0>)
  /* Configure I2Cx: Frequency range */
  hi2c->Instance->CR2 = freqrange;

  /*---------------------------- I2Cx TRISE Configuration --------------------*/
  /* Configure I2Cx: Rise Time */
  hi2c->Instance->TRISE = I2C_RISE_TIME(freqrange, hi2c->Init.ClockSpeed);
 80018e6:	6863      	ldr	r3, [r4, #4]

  /* Get PCLK1 frequency */
  pclk1 = HAL_RCC_GetPCLK1Freq();

  /* Calculate frequency range */
  freqrange = I2C_FREQ_RANGE(pclk1);
 80018e8:	fbb0 f1f1 	udiv	r1, r0, r1
  /* Configure I2Cx: Frequency range */
  hi2c->Instance->CR2 = freqrange;

  /*---------------------------- I2Cx TRISE Configuration --------------------*/
  /* Configure I2Cx: Rise Time */
  hi2c->Instance->TRISE = I2C_RISE_TIME(freqrange, hi2c->Init.ClockSpeed);
 80018ec:	42ab      	cmp	r3, r5
  /* Calculate frequency range */
  freqrange = I2C_FREQ_RANGE(pclk1);

  /*---------------------------- I2Cx CR2 Configuration ----------------------*/
  /* Configure I2Cx: Frequency range */
  hi2c->Instance->CR2 = freqrange;
 80018ee:	6822      	ldr	r2, [r4, #0]
 80018f0:	462e      	mov	r6, r5

  /*---------------------------- I2Cx TRISE Configuration --------------------*/
  /* Configure I2Cx: Rise Time */
  hi2c->Instance->TRISE = I2C_RISE_TIME(freqrange, hi2c->Init.ClockSpeed);
 80018f2:	bf88      	it	hi
 80018f4:	f44f 7596 	movhi.w	r5, #300	; 0x12c
  /* Calculate frequency range */
  freqrange = I2C_FREQ_RANGE(pclk1);

  /*---------------------------- I2Cx CR2 Configuration ----------------------*/
  /* Configure I2Cx: Frequency range */
  hi2c->Instance->CR2 = freqrange;
 80018f8:	6051      	str	r1, [r2, #4]

  /*---------------------------- I2Cx TRISE Configuration --------------------*/
  /* Configure I2Cx: Rise Time */
  hi2c->Instance->TRISE = I2C_RISE_TIME(freqrange, hi2c->Init.ClockSpeed);
 80018fa:	bf82      	ittt	hi
 80018fc:	4369      	mulhi	r1, r5
 80018fe:	f44f 757a 	movhi.w	r5, #1000	; 0x3e8
 8001902:	fbb1 f1f5 	udivhi	r1, r1, r5
static uint32_t I2C_Configure_Speed(I2C_HandleTypeDef *hi2c, uint32_t I2CClkSrcFreq)
{
  uint32_t tmp1 = 0;
  
  /* Clock Standard Mode */
  if(hi2c->Init.ClockSpeed <= I2C_STANDARD_MODE_MAX_CLK)
 8001906:	42b3      	cmp	r3, r6
  /* Configure I2Cx: Frequency range */
  hi2c->Instance->CR2 = freqrange;

  /*---------------------------- I2Cx TRISE Configuration --------------------*/
  /* Configure I2Cx: Rise Time */
  hi2c->Instance->TRISE = I2C_RISE_TIME(freqrange, hi2c->Init.ClockSpeed);
 8001908:	f101 0101 	add.w	r1, r1, #1
 800190c:	6211      	str	r1, [r2, #32]
static uint32_t I2C_Configure_Speed(I2C_HandleTypeDef *hi2c, uint32_t I2CClkSrcFreq)
{
  uint32_t tmp1 = 0;
  
  /* Clock Standard Mode */
  if(hi2c->Init.ClockSpeed <= I2C_STANDARD_MODE_MAX_CLK)
 800190e:	d808      	bhi.n	8001922 <HAL_I2C_Init+0x6e>
  {
    /* Calculate Value to be set in CCR register */
    tmp1 = (I2CClkSrcFreq/(hi2c->Init.ClockSpeed << 1));
 8001910:	005b      	lsls	r3, r3, #1
 8001912:	fbb0 f0f3 	udiv	r0, r0, r3
    
    /* The minimum allowed value set in CCR register is 0x04 for Standard Mode */
    if( (tmp1 & I2C_CCR_CCR) < 4 )
 8001916:	f3c0 030b 	ubfx	r3, r0, #0, #12
 800191a:	2b04      	cmp	r3, #4
 800191c:	bf38      	it	cc
 800191e:	2004      	movcc	r0, #4
 8001920:	e013      	b.n	800194a <HAL_I2C_Init+0x96>
  {
    /* Clock Fast Mode */
    tmp1 = I2C_CCR_FS;
    
    /* Duty Cylce tLow/tHigh = 2 */
    if(hi2c->Init.DutyCycle == I2C_DUTYCYCLE_2)
 8001922:	68a1      	ldr	r1, [r4, #8]
 8001924:	b931      	cbnz	r1, 8001934 <HAL_I2C_Init+0x80>
    {
      tmp1 |= (I2CClkSrcFreq/(hi2c->Init.ClockSpeed * 3)) | I2C_DUTYCYCLE_2; 
 8001926:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 800192a:	fbb0 f0f3 	udiv	r0, r0, r3
 800192e:	f440 4000 	orr.w	r0, r0, #32768	; 0x8000
 8001932:	e005      	b.n	8001940 <HAL_I2C_Init+0x8c>
    }
    else /* Duty Cylce tLow/tHigh = 16/9 */
    {
      tmp1 |= (I2CClkSrcFreq/(hi2c->Init.ClockSpeed * 25)) | I2C_DUTYCYCLE_16_9;
 8001934:	2119      	movs	r1, #25
 8001936:	434b      	muls	r3, r1
 8001938:	fbb0 f0f3 	udiv	r0, r0, r3
 800193c:	f440 4040 	orr.w	r0, r0, #49152	; 0xc000
    }

    /* The minimum allowed value set in CCR register is 0x01 for Fast Mode */
    if( (tmp1 & I2C_CCR_CCR) < 1 )
 8001940:	f3c0 030b 	ubfx	r3, r0, #0, #12
 8001944:	2b00      	cmp	r3, #0
 8001946:	bf08      	it	eq
 8001948:	2001      	moveq	r0, #1
  /* Configure I2Cx: Speed */
  hi2c->Instance->CCR = I2C_Configure_Speed(hi2c, pclk1);

  /*---------------------------- I2Cx CR1 Configuration ----------------------*/
  /* Configure I2Cx: Generalcall and NoStretch mode */
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
 800194a:	6a21      	ldr	r1, [r4, #32]
 800194c:	69e3      	ldr	r3, [r4, #28]
  /* Configure I2Cx: Rise Time */
  hi2c->Instance->TRISE = I2C_RISE_TIME(freqrange, hi2c->Init.ClockSpeed);

  /*---------------------------- I2Cx CCR Configuration ----------------------*/
  /* Configure I2Cx: Speed */
  hi2c->Instance->CCR = I2C_Configure_Speed(hi2c, pclk1);
 800194e:	61d0      	str	r0, [r2, #28]

  /*---------------------------- I2Cx CR1 Configuration ----------------------*/
  /* Configure I2Cx: Generalcall and NoStretch mode */
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
 8001950:	430b      	orrs	r3, r1
 8001952:	6013      	str	r3, [r2, #0]

  /*---------------------------- I2Cx OAR1 Configuration ---------------------*/
  /* Configure I2Cx: Own Address1 and addressing mode */
  hi2c->Instance->OAR1 = (hi2c->Init.AddressingMode | hi2c->Init.OwnAddress1);
 8001954:	68e1      	ldr	r1, [r4, #12]
 8001956:	6923      	ldr	r3, [r4, #16]
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2);

  /* Enable the selected I2C peripheral */
  __HAL_I2C_ENABLE(hi2c);

  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8001958:	2000      	movs	r0, #0
  /* Configure I2Cx: Generalcall and NoStretch mode */
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);

  /*---------------------------- I2Cx OAR1 Configuration ---------------------*/
  /* Configure I2Cx: Own Address1 and addressing mode */
  hi2c->Instance->OAR1 = (hi2c->Init.AddressingMode | hi2c->Init.OwnAddress1);
 800195a:	430b      	orrs	r3, r1
 800195c:	6093      	str	r3, [r2, #8]

  /*---------------------------- I2Cx OAR2 Configuration ---------------------*/
  /* Configure I2Cx: Dual mode and Own Address2 */
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2);
 800195e:	69a1      	ldr	r1, [r4, #24]
 8001960:	6963      	ldr	r3, [r4, #20]
 8001962:	430b      	orrs	r3, r1
 8001964:	60d3      	str	r3, [r2, #12]

  /* Enable the selected I2C peripheral */
  __HAL_I2C_ENABLE(hi2c);
 8001966:	6813      	ldr	r3, [r2, #0]
 8001968:	f043 0301 	orr.w	r3, r3, #1
 800196c:	6013      	str	r3, [r2, #0]

  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
  hi2c->State = HAL_I2C_STATE_READY;
 800196e:	2320      	movs	r3, #32
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2);

  /* Enable the selected I2C peripheral */
  __HAL_I2C_ENABLE(hi2c);

  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8001970:	63a0      	str	r0, [r4, #56]	; 0x38
  hi2c->State = HAL_I2C_STATE_READY;
 8001972:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
  hi2c->Mode = HAL_I2C_MODE_NONE;
 8001976:	f884 0036 	strb.w	r0, [r4, #54]	; 0x36

  return HAL_OK;
 800197a:	bd70      	pop	{r4, r5, r6, pc}
  uint32_t pclk1 = 0;

  /* Check the I2C handle allocation */
  if(hi2c == NULL)
  {
    return HAL_ERROR;
 800197c:	2001      	movs	r0, #1
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
  hi2c->State = HAL_I2C_STATE_READY;
  hi2c->Mode = HAL_I2C_MODE_NONE;

  return HAL_OK;
}
 800197e:	bd70      	pop	{r4, r5, r6, pc}
 8001980:	000186a0 	.word	0x000186a0
 8001984:	000f4240 	.word	0x000f4240

08001988 <HAL_I2C_DeInit>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_DeInit(I2C_HandleTypeDef *hi2c)
{
 8001988:	b510      	push	{r4, lr}
  /* Check the I2C handle allocation */
  if(hi2c == NULL)
 800198a:	4604      	mov	r4, r0
 800198c:	b190      	cbz	r0, 80019b4 <HAL_I2C_DeInit+0x2c>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));

  hi2c->State = HAL_I2C_STATE_BUSY;

  /* Disable the I2C Peripheral Clock */
  __HAL_I2C_DISABLE(hi2c);
 800198e:	6802      	ldr	r2, [r0, #0]
  }

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));

  hi2c->State = HAL_I2C_STATE_BUSY;
 8001990:	2324      	movs	r3, #36	; 0x24
 8001992:	f880 3035 	strb.w	r3, [r0, #53]	; 0x35

  /* Disable the I2C Peripheral Clock */
  __HAL_I2C_DISABLE(hi2c);
 8001996:	6813      	ldr	r3, [r2, #0]
 8001998:	f023 0301 	bic.w	r3, r3, #1
 800199c:	6013      	str	r3, [r2, #0]

  /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
  HAL_I2C_MspDeInit(hi2c);
 800199e:	f7ff f8b3 	bl	8000b08 <HAL_I2C_MspDeInit>

  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 80019a2:	2000      	movs	r0, #0
 80019a4:	63a0      	str	r0, [r4, #56]	; 0x38
  hi2c->State = HAL_I2C_STATE_RESET;
  hi2c->Mode = HAL_I2C_MODE_NONE;

  /* Release Lock */
  __HAL_UNLOCK(hi2c);
 80019a6:	f884 0034 	strb.w	r0, [r4, #52]	; 0x34

  /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
  HAL_I2C_MspDeInit(hi2c);

  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
  hi2c->State = HAL_I2C_STATE_RESET;
 80019aa:	f884 0035 	strb.w	r0, [r4, #53]	; 0x35
  hi2c->Mode = HAL_I2C_MODE_NONE;
 80019ae:	f884 0036 	strb.w	r0, [r4, #54]	; 0x36

  /* Release Lock */
  __HAL_UNLOCK(hi2c);

  return HAL_OK;
 80019b2:	bd10      	pop	{r4, pc}
HAL_StatusTypeDef HAL_I2C_DeInit(I2C_HandleTypeDef *hi2c)
{
  /* Check the I2C handle allocation */
  if(hi2c == NULL)
  {
    return HAL_ERROR;
 80019b4:	2001      	movs	r0, #1

  /* Release Lock */
  __HAL_UNLOCK(hi2c);

  return HAL_OK;
}
 80019b6:	bd10      	pop	{r4, pc}

080019b8 <BSP_LED_Init>:
  *          This parameter can be one of the following values:
  *     @arg LED2
  * @retval None
  */
void BSP_LED_Init(Led_TypeDef Led)
{
 80019b8:	b5f0      	push	{r4, r5, r6, r7, lr}
  GPIO_InitTypeDef  gpioinitstruct;
  
  /* Enable the GPIO_LED Clock */
  LEDx_GPIO_CLK_ENABLE(Led);
 80019ba:	4604      	mov	r4, r0
  *          This parameter can be one of the following values:
  *     @arg LED2
  * @retval None
  */
void BSP_LED_Init(Led_TypeDef Led)
{
 80019bc:	b087      	sub	sp, #28
  GPIO_InitTypeDef  gpioinitstruct;
  
  /* Enable the GPIO_LED Clock */
  LEDx_GPIO_CLK_ENABLE(Led);
 80019be:	b948      	cbnz	r0, 80019d4 <BSP_LED_Init+0x1c>
 80019c0:	4b0f      	ldr	r3, [pc, #60]	; (8001a00 <BSP_LED_Init+0x48>)
 80019c2:	699a      	ldr	r2, [r3, #24]
 80019c4:	f042 0204 	orr.w	r2, r2, #4
 80019c8:	619a      	str	r2, [r3, #24]
 80019ca:	699b      	ldr	r3, [r3, #24]
 80019cc:	f003 0304 	and.w	r3, r3, #4
 80019d0:	9301      	str	r3, [sp, #4]
 80019d2:	9b01      	ldr	r3, [sp, #4]
  gpioinitstruct.Pin    = LED_PIN[Led];
  gpioinitstruct.Mode   = GPIO_MODE_OUTPUT_PP;
  gpioinitstruct.Pull   = GPIO_NOPULL;
  gpioinitstruct.Speed  = GPIO_SPEED_FREQ_HIGH;
  
  HAL_GPIO_Init(LED_PORT[Led], &gpioinitstruct);
 80019d4:	4f0b      	ldr	r7, [pc, #44]	; (8001a04 <BSP_LED_Init+0x4c>)
  /* Enable the GPIO_LED Clock */
  LEDx_GPIO_CLK_ENABLE(Led);

  /* Configure the GPIO_LED pin */
  gpioinitstruct.Pin    = LED_PIN[Led];
  gpioinitstruct.Mode   = GPIO_MODE_OUTPUT_PP;
 80019d6:	2301      	movs	r3, #1
  
  /* Enable the GPIO_LED Clock */
  LEDx_GPIO_CLK_ENABLE(Led);

  /* Configure the GPIO_LED pin */
  gpioinitstruct.Pin    = LED_PIN[Led];
 80019d8:	2620      	movs	r6, #32
  gpioinitstruct.Mode   = GPIO_MODE_OUTPUT_PP;
 80019da:	9303      	str	r3, [sp, #12]
  gpioinitstruct.Pull   = GPIO_NOPULL;
 80019dc:	2500      	movs	r5, #0
  gpioinitstruct.Speed  = GPIO_SPEED_FREQ_HIGH;
 80019de:	2303      	movs	r3, #3
  
  HAL_GPIO_Init(LED_PORT[Led], &gpioinitstruct);
 80019e0:	f857 0024 	ldr.w	r0, [r7, r4, lsl #2]
 80019e4:	a902      	add	r1, sp, #8

  /* Configure the GPIO_LED pin */
  gpioinitstruct.Pin    = LED_PIN[Led];
  gpioinitstruct.Mode   = GPIO_MODE_OUTPUT_PP;
  gpioinitstruct.Pull   = GPIO_NOPULL;
  gpioinitstruct.Speed  = GPIO_SPEED_FREQ_HIGH;
 80019e6:	9305      	str	r3, [sp, #20]
  
  /* Enable the GPIO_LED Clock */
  LEDx_GPIO_CLK_ENABLE(Led);

  /* Configure the GPIO_LED pin */
  gpioinitstruct.Pin    = LED_PIN[Led];
 80019e8:	9602      	str	r6, [sp, #8]
  gpioinitstruct.Mode   = GPIO_MODE_OUTPUT_PP;
  gpioinitstruct.Pull   = GPIO_NOPULL;
 80019ea:	9504      	str	r5, [sp, #16]
  gpioinitstruct.Speed  = GPIO_SPEED_FREQ_HIGH;
  
  HAL_GPIO_Init(LED_PORT[Led], &gpioinitstruct);
 80019ec:	f7ff fe30 	bl	8001650 <HAL_GPIO_Init>

  /* Reset PIN to switch off the LED */
  HAL_GPIO_WritePin(LED_PORT[Led],LED_PIN[Led], GPIO_PIN_RESET);
 80019f0:	f857 0024 	ldr.w	r0, [r7, r4, lsl #2]
 80019f4:	4631      	mov	r1, r6
 80019f6:	462a      	mov	r2, r5
 80019f8:	f7ff ff58 	bl	80018ac <HAL_GPIO_WritePin>
}
 80019fc:	b007      	add	sp, #28
 80019fe:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001a00:	40021000 	.word	0x40021000
 8001a04:	20000434 	.word	0x20000434

08001a08 <FLASH_SetErrorCode>:
static void FLASH_SetErrorCode(void)
{ 
#if defined(FLASH_BANK2_END)
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR) || __HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR_BANK2))
#else
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR))
 8001a08:	4b10      	ldr	r3, [pc, #64]	; (8001a4c <FLASH_SetErrorCode+0x44>)
 8001a0a:	68da      	ldr	r2, [r3, #12]
 8001a0c:	06d0      	lsls	r0, r2, #27
#endif /* FLASH_BANK2_END */
  {
    pFlash.ErrorCode |= HAL_FLASH_ERROR_WRP;
 8001a0e:	bf41      	itttt	mi
 8001a10:	490f      	ldrmi	r1, [pc, #60]	; (8001a50 <FLASH_SetErrorCode+0x48>)
 8001a12:	69ca      	ldrmi	r2, [r1, #28]
 8001a14:	f042 0202 	orrmi.w	r2, r2, #2
 8001a18:	61ca      	strmi	r2, [r1, #28]
  }
#if defined(FLASH_BANK2_END)
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGERR) || __HAL_FLASH_GET_FLAG(FLASH_FLAG_PGERR_BANK2))
#else
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGERR))
 8001a1a:	68db      	ldr	r3, [r3, #12]
 8001a1c:	0759      	lsls	r1, r3, #29
#endif /* FLASH_BANK2_END */
  {
     pFlash.ErrorCode |= HAL_FLASH_ERROR_PROG;
 8001a1e:	bf41      	itttt	mi
 8001a20:	4a0b      	ldrmi	r2, [pc, #44]	; (8001a50 <FLASH_SetErrorCode+0x48>)
 8001a22:	69d3      	ldrmi	r3, [r2, #28]
 8001a24:	f043 0301 	orrmi.w	r3, r3, #1
 8001a28:	61d3      	strmi	r3, [r2, #28]
  }

  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_OPTVERR))
 8001a2a:	4b08      	ldr	r3, [pc, #32]	; (8001a4c <FLASH_SetErrorCode+0x44>)
 8001a2c:	69da      	ldr	r2, [r3, #28]
 8001a2e:	07d2      	lsls	r2, r2, #31
 8001a30:	d508      	bpl.n	8001a44 <FLASH_SetErrorCode+0x3c>
  {
     pFlash.ErrorCode |= HAL_FLASH_ERROR_OPTV;
 8001a32:	4907      	ldr	r1, [pc, #28]	; (8001a50 <FLASH_SetErrorCode+0x48>)
 8001a34:	69ca      	ldr	r2, [r1, #28]
 8001a36:	f042 0204 	orr.w	r2, r2, #4
 8001a3a:	61ca      	str	r2, [r1, #28]
     __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_OPTVERR);
 8001a3c:	69da      	ldr	r2, [r3, #28]
 8001a3e:	f022 0201 	bic.w	r2, r2, #1
 8001a42:	61da      	str	r2, [r3, #28]

  /* Clear FLASH error pending bits */
#if defined(FLASH_BANK2_END)
  __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_WRPERR | FLASH_FLAG_WRPERR_BANK2 | FLASH_FLAG_PGERR | FLASH_FLAG_PGERR_BANK2);
#else
  __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_WRPERR | FLASH_FLAG_PGERR);
 8001a44:	2214      	movs	r2, #20
 8001a46:	60da      	str	r2, [r3, #12]
 8001a48:	4770      	bx	lr
 8001a4a:	bf00      	nop
 8001a4c:	40022000 	.word	0x40022000
 8001a50:	20000ab0 	.word	0x20000ab0

08001a54 <HAL_FLASH_Unlock>:
  * @brief  Unlock the FLASH control register access
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Unlock(void)
{
  if (HAL_IS_BIT_SET(FLASH->CR, FLASH_CR_LOCK))
 8001a54:	4b06      	ldr	r3, [pc, #24]	; (8001a70 <HAL_FLASH_Unlock+0x1c>)
 8001a56:	691a      	ldr	r2, [r3, #16]
 8001a58:	0612      	lsls	r2, r2, #24
  {
    /* Authorize the FLASH Registers access */
    WRITE_REG(FLASH->KEYR, FLASH_KEY1);
 8001a5a:	bf41      	itttt	mi
 8001a5c:	4a05      	ldrmi	r2, [pc, #20]	; (8001a74 <HAL_FLASH_Unlock+0x20>)
  {
    return HAL_ERROR;
  }
  
#endif /* FLASH_BANK2_END */
  return HAL_OK; 
 8001a5e:	2000      	movmi	r0, #0
HAL_StatusTypeDef HAL_FLASH_Unlock(void)
{
  if (HAL_IS_BIT_SET(FLASH->CR, FLASH_CR_LOCK))
  {
    /* Authorize the FLASH Registers access */
    WRITE_REG(FLASH->KEYR, FLASH_KEY1);
 8001a60:	605a      	strmi	r2, [r3, #4]
    WRITE_REG(FLASH->KEYR, FLASH_KEY2);
 8001a62:	f102 3288 	addmi.w	r2, r2, #2290649224	; 0x88888888
 8001a66:	bf4c      	ite	mi
 8001a68:	605a      	strmi	r2, [r3, #4]
  }
  else
  {
    return HAL_ERROR;
 8001a6a:	2001      	movpl	r0, #1
    return HAL_ERROR;
  }
  
#endif /* FLASH_BANK2_END */
  return HAL_OK; 
}
 8001a6c:	4770      	bx	lr
 8001a6e:	bf00      	nop
 8001a70:	40022000 	.word	0x40022000
 8001a74:	45670123 	.word	0x45670123

08001a78 <HAL_FLASH_Lock>:
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Lock(void)
{
  /* Set the LOCK Bit to lock the FLASH Registers access */
  SET_BIT(FLASH->CR, FLASH_CR_LOCK);
 8001a78:	4a03      	ldr	r2, [pc, #12]	; (8001a88 <HAL_FLASH_Lock+0x10>)
  /* Set the LOCK Bit to lock the FLASH BANK2 Registers access */
  SET_BIT(FLASH->CR2, FLASH_CR2_LOCK);
#endif /* FLASH_BANK2_END */

  return HAL_OK;  
}
 8001a7a:	2000      	movs	r0, #0
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Lock(void)
{
  /* Set the LOCK Bit to lock the FLASH Registers access */
  SET_BIT(FLASH->CR, FLASH_CR_LOCK);
 8001a7c:	6913      	ldr	r3, [r2, #16]
 8001a7e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8001a82:	6113      	str	r3, [r2, #16]
  /* Set the LOCK Bit to lock the FLASH BANK2 Registers access */
  SET_BIT(FLASH->CR2, FLASH_CR2_LOCK);
#endif /* FLASH_BANK2_END */

  return HAL_OK;  
}
 8001a84:	4770      	bx	lr
 8001a86:	bf00      	nop
 8001a88:	40022000 	.word	0x40022000

08001a8c <FLASH_WaitForLastOperation>:
  * @brief  Wait for a FLASH operation to complete.
  * @param  Timeout: maximum flash operation timeout
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef FLASH_WaitForLastOperation(uint32_t Timeout)
{
 8001a8c:	b538      	push	{r3, r4, r5, lr}
 8001a8e:	4604      	mov	r4, r0
  /* Wait for the FLASH operation to complete by polling on BUSY flag to be reset.
     Even if the FLASH operation fails, the BUSY flag will be reset and an error
     flag will be set */
     
  uint32_t tickstart = HAL_GetTick();
 8001a90:	f7ff fd62 	bl	8001558 <HAL_GetTick>
 8001a94:	4605      	mov	r5, r0
     
  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY)) 
 8001a96:	4b11      	ldr	r3, [pc, #68]	; (8001adc <FLASH_WaitForLastOperation+0x50>)
 8001a98:	68da      	ldr	r2, [r3, #12]
 8001a9a:	07d2      	lsls	r2, r2, #31
 8001a9c:	d50a      	bpl.n	8001ab4 <FLASH_WaitForLastOperation+0x28>
  { 
    if (Timeout != HAL_MAX_DELAY)
 8001a9e:	1c61      	adds	r1, r4, #1
 8001aa0:	d0f9      	beq.n	8001a96 <FLASH_WaitForLastOperation+0xa>
    {
      if((Timeout == 0) || ((HAL_GetTick()-tickstart) > Timeout))
 8001aa2:	b90c      	cbnz	r4, 8001aa8 <FLASH_WaitForLastOperation+0x1c>
      {
        return HAL_TIMEOUT;
 8001aa4:	2003      	movs	r0, #3
 8001aa6:	bd38      	pop	{r3, r4, r5, pc}
     
  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY)) 
  { 
    if (Timeout != HAL_MAX_DELAY)
    {
      if((Timeout == 0) || ((HAL_GetTick()-tickstart) > Timeout))
 8001aa8:	f7ff fd56 	bl	8001558 <HAL_GetTick>
 8001aac:	1b40      	subs	r0, r0, r5
 8001aae:	42a0      	cmp	r0, r4
 8001ab0:	d9f1      	bls.n	8001a96 <FLASH_WaitForLastOperation+0xa>
 8001ab2:	e7f7      	b.n	8001aa4 <FLASH_WaitForLastOperation+0x18>
      }
    }
  }
  
  /* Check FLASH End of Operation flag  */
  if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP))
 8001ab4:	68da      	ldr	r2, [r3, #12]
 8001ab6:	0690      	lsls	r0, r2, #26
  {
    /* Clear FLASH End of Operation pending bit */
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
 8001ab8:	bf44      	itt	mi
 8001aba:	2220      	movmi	r2, #32
 8001abc:	60da      	strmi	r2, [r3, #12]
  }
  
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR)  || 
 8001abe:	68db      	ldr	r3, [r3, #12]
 8001ac0:	4a06      	ldr	r2, [pc, #24]	; (8001adc <FLASH_WaitForLastOperation+0x50>)
 8001ac2:	06d9      	lsls	r1, r3, #27
 8001ac4:	d406      	bmi.n	8001ad4 <FLASH_WaitForLastOperation+0x48>
     __HAL_FLASH_GET_FLAG(FLASH_FLAG_OPTVERR) || 
 8001ac6:	69d3      	ldr	r3, [r2, #28]
  {
    /* Clear FLASH End of Operation pending bit */
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
  }
  
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR)  || 
 8001ac8:	07db      	lsls	r3, r3, #31
 8001aca:	d403      	bmi.n	8001ad4 <FLASH_WaitForLastOperation+0x48>
     __HAL_FLASH_GET_FLAG(FLASH_FLAG_OPTVERR) || 
     __HAL_FLASH_GET_FLAG(FLASH_FLAG_PGERR))
 8001acc:	68d0      	ldr	r0, [r2, #12]
    /* Clear FLASH End of Operation pending bit */
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
  }
  
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR)  || 
     __HAL_FLASH_GET_FLAG(FLASH_FLAG_OPTVERR) || 
 8001ace:	f010 0004 	ands.w	r0, r0, #4
 8001ad2:	d002      	beq.n	8001ada <FLASH_WaitForLastOperation+0x4e>
     __HAL_FLASH_GET_FLAG(FLASH_FLAG_PGERR))
  {
    /*Save the error code*/
    FLASH_SetErrorCode();
 8001ad4:	f7ff ff98 	bl	8001a08 <FLASH_SetErrorCode>
    return HAL_ERROR;
 8001ad8:	2001      	movs	r0, #1
  }

  /* If there is no error flag set */
  return HAL_OK;
}
 8001ada:	bd38      	pop	{r3, r4, r5, pc}
 8001adc:	40022000 	.word	0x40022000

08001ae0 <HAL_FLASH_Program>:
  * @param  Data:         Specifies the data to be programmed
  * 
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Program(uint32_t TypeProgram, uint32_t Address, uint64_t Data)
{
 8001ae0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  HAL_StatusTypeDef status = HAL_ERROR;
  uint8_t index = 0;
  uint8_t nbiterations = 0;
  
  /* Process Locked */
  __HAL_LOCK(&pFlash);
 8001ae4:	4d20      	ldr	r5, [pc, #128]	; (8001b68 <HAL_FLASH_Program+0x88>)
  * @param  Data:         Specifies the data to be programmed
  * 
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Program(uint32_t TypeProgram, uint32_t Address, uint64_t Data)
{
 8001ae6:	4699      	mov	r9, r3
  HAL_StatusTypeDef status = HAL_ERROR;
  uint8_t index = 0;
  uint8_t nbiterations = 0;
  
  /* Process Locked */
  __HAL_LOCK(&pFlash);
 8001ae8:	7e2b      	ldrb	r3, [r5, #24]
  * @param  Data:         Specifies the data to be programmed
  * 
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Program(uint32_t TypeProgram, uint32_t Address, uint64_t Data)
{
 8001aea:	4606      	mov	r6, r0
  HAL_StatusTypeDef status = HAL_ERROR;
  uint8_t index = 0;
  uint8_t nbiterations = 0;
  
  /* Process Locked */
  __HAL_LOCK(&pFlash);
 8001aec:	2b01      	cmp	r3, #1
  * @param  Data:         Specifies the data to be programmed
  * 
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Program(uint32_t TypeProgram, uint32_t Address, uint64_t Data)
{
 8001aee:	468b      	mov	fp, r1
 8001af0:	4690      	mov	r8, r2
  HAL_StatusTypeDef status = HAL_ERROR;
  uint8_t index = 0;
  uint8_t nbiterations = 0;
  
  /* Process Locked */
  __HAL_LOCK(&pFlash);
 8001af2:	d036      	beq.n	8001b62 <HAL_FLASH_Program+0x82>
 8001af4:	2301      	movs	r3, #1
#if defined(FLASH_BANK2_END)
  if(Address <= FLASH_BANK1_END)
  {
#endif /* FLASH_BANK2_END */
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8001af6:	f24c 3050 	movw	r0, #50000	; 0xc350
  HAL_StatusTypeDef status = HAL_ERROR;
  uint8_t index = 0;
  uint8_t nbiterations = 0;
  
  /* Process Locked */
  __HAL_LOCK(&pFlash);
 8001afa:	762b      	strb	r3, [r5, #24]
#if defined(FLASH_BANK2_END)
  if(Address <= FLASH_BANK1_END)
  {
#endif /* FLASH_BANK2_END */
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8001afc:	f7ff ffc6 	bl	8001a8c <FLASH_WaitForLastOperation>
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperationBank2((uint32_t)FLASH_TIMEOUT_VALUE);
  }
#endif /* FLASH_BANK2_END */
  
  if(status == HAL_OK)
 8001b00:	4604      	mov	r4, r0
 8001b02:	bb48      	cbnz	r0, 8001b58 <HAL_FLASH_Program+0x78>
  {
    if(TypeProgram == FLASH_TYPEPROGRAM_HALFWORD)
 8001b04:	2e01      	cmp	r6, #1
 8001b06:	d003      	beq.n	8001b10 <HAL_FLASH_Program+0x30>
      nbiterations = 2;
    }
    else
    {
      /* Program double word (64-bit = 4*16-bit) at a specified address. */
      nbiterations = 4;
 8001b08:	2e02      	cmp	r6, #2
 8001b0a:	bf0c      	ite	eq
 8001b0c:	2602      	moveq	r6, #2
 8001b0e:	2604      	movne	r6, #4
    }

    for (index = 0; index < nbiterations; index++)
 8001b10:	2700      	movs	r7, #0
 8001b12:	b2fb      	uxtb	r3, r7
 8001b14:	42b3      	cmp	r3, r6
 8001b16:	d21f      	bcs.n	8001b58 <HAL_FLASH_Program+0x78>
    {
      FLASH_Program_HalfWord((Address + (2*index)), (uint16_t)(Data >> (16*index)));
 8001b18:	013a      	lsls	r2, r7, #4
 8001b1a:	4640      	mov	r0, r8
 8001b1c:	4649      	mov	r1, r9
 8001b1e:	f7fe fb47 	bl	80001b0 <__aeabi_llsr>
#if defined(FLASH_BANK2_END)
  if(Address <= FLASH_BANK1_END)
  {
#endif /* FLASH_BANK2_END */
    /* Proceed to program the new data */
    SET_BIT(FLASH->CR, FLASH_CR_PG);
 8001b22:	f8df a048 	ldr.w	sl, [pc, #72]	; 8001b6c <HAL_FLASH_Program+0x8c>
  * @retval None
  */
static void FLASH_Program_HalfWord(uint32_t Address, uint16_t Data)
{
  /* Clean the error context */
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 8001b26:	2300      	movs	r3, #0
 8001b28:	61eb      	str	r3, [r5, #28]
#if defined(FLASH_BANK2_END)
  if(Address <= FLASH_BANK1_END)
  {
#endif /* FLASH_BANK2_END */
    /* Proceed to program the new data */
    SET_BIT(FLASH->CR, FLASH_CR_PG);
 8001b2a:	f8da 3010 	ldr.w	r3, [sl, #16]
      nbiterations = 4;
    }

    for (index = 0; index < nbiterations; index++)
    {
      FLASH_Program_HalfWord((Address + (2*index)), (uint16_t)(Data >> (16*index)));
 8001b2e:	b280      	uxth	r0, r0
#if defined(FLASH_BANK2_END)
  if(Address <= FLASH_BANK1_END)
  {
#endif /* FLASH_BANK2_END */
    /* Proceed to program the new data */
    SET_BIT(FLASH->CR, FLASH_CR_PG);
 8001b30:	f043 0301 	orr.w	r3, r3, #1
 8001b34:	f8ca 3010 	str.w	r3, [sl, #16]
    SET_BIT(FLASH->CR2, FLASH_CR2_PG);
  }
#endif /* FLASH_BANK2_END */

  /* Write data in the address */
  *(__IO uint16_t*)Address = Data;
 8001b38:	f82b 0017 	strh.w	r0, [fp, r7, lsl #1]
#if defined(FLASH_BANK2_END)
      if(Address <= FLASH_BANK1_END)
      {
#endif /* FLASH_BANK2_END */
        /* Wait for last operation to be completed */
        status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8001b3c:	f24c 3050 	movw	r0, #50000	; 0xc350
 8001b40:	f7ff ffa4 	bl	8001a8c <FLASH_WaitForLastOperation>
    
        /* If the program operation is completed, disable the PG Bit */
        CLEAR_BIT(FLASH->CR, FLASH_CR_PG);
 8001b44:	f8da 3010 	ldr.w	r3, [sl, #16]
 8001b48:	3701      	adds	r7, #1
 8001b4a:	f023 0301 	bic.w	r3, r3, #1
 8001b4e:	f8ca 3010 	str.w	r3, [sl, #16]
        /* If the program operation is completed, disable the PG Bit */
        CLEAR_BIT(FLASH->CR2, FLASH_CR2_PG);
      }
#endif /* FLASH_BANK2_END */
      /* In case of error, stop programation procedure */
      if (status != HAL_OK)
 8001b52:	2800      	cmp	r0, #0
 8001b54:	d0dd      	beq.n	8001b12 <HAL_FLASH_Program+0x32>
 8001b56:	4604      	mov	r4, r0
      }
    }
  }

  /* Process Unlocked */
  __HAL_UNLOCK(&pFlash);
 8001b58:	2300      	movs	r3, #0
 8001b5a:	762b      	strb	r3, [r5, #24]

  return status;
 8001b5c:	4620      	mov	r0, r4
 8001b5e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  HAL_StatusTypeDef status = HAL_ERROR;
  uint8_t index = 0;
  uint8_t nbiterations = 0;
  
  /* Process Locked */
  __HAL_LOCK(&pFlash);
 8001b62:	2002      	movs	r0, #2

  /* Process Unlocked */
  __HAL_UNLOCK(&pFlash);

  return status;
}
 8001b64:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8001b68:	20000ab0 	.word	0x20000ab0
 8001b6c:	40022000 	.word	0x40022000

08001b70 <FLASH_MassErase.isra.0>:
{
  /* Check the parameters */
  assert_param(IS_FLASH_BANK(Banks));

  /* Clean the error context */
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 8001b70:	4b06      	ldr	r3, [pc, #24]	; (8001b8c <FLASH_MassErase.isra.0+0x1c>)
 8001b72:	2200      	movs	r2, #0
 8001b74:	61da      	str	r2, [r3, #28]
  }
  else
  {
#endif /* FLASH_BANK2_END */
    /* Only bank1 will be erased*/
    SET_BIT(FLASH->CR, FLASH_CR_MER);
 8001b76:	4b06      	ldr	r3, [pc, #24]	; (8001b90 <FLASH_MassErase.isra.0+0x20>)
 8001b78:	691a      	ldr	r2, [r3, #16]
 8001b7a:	f042 0204 	orr.w	r2, r2, #4
 8001b7e:	611a      	str	r2, [r3, #16]
    SET_BIT(FLASH->CR, FLASH_CR_STRT);
 8001b80:	691a      	ldr	r2, [r3, #16]
 8001b82:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8001b86:	611a      	str	r2, [r3, #16]
 8001b88:	4770      	bx	lr
 8001b8a:	bf00      	nop
 8001b8c:	20000ab0 	.word	0x20000ab0
 8001b90:	40022000 	.word	0x40022000

08001b94 <FLASH_PageErase>:
  * @retval None
  */
void FLASH_PageErase(uint32_t PageAddress)
{
  /* Clean the error context */
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 8001b94:	4b06      	ldr	r3, [pc, #24]	; (8001bb0 <FLASH_PageErase+0x1c>)
 8001b96:	2200      	movs	r2, #0
 8001b98:	61da      	str	r2, [r3, #28]
  }
  else
  {
#endif /* FLASH_BANK2_END */
    /* Proceed to erase the page */
    SET_BIT(FLASH->CR, FLASH_CR_PER);
 8001b9a:	4b06      	ldr	r3, [pc, #24]	; (8001bb4 <FLASH_PageErase+0x20>)
 8001b9c:	691a      	ldr	r2, [r3, #16]
 8001b9e:	f042 0202 	orr.w	r2, r2, #2
 8001ba2:	611a      	str	r2, [r3, #16]
    WRITE_REG(FLASH->AR, PageAddress);
 8001ba4:	6158      	str	r0, [r3, #20]
    SET_BIT(FLASH->CR, FLASH_CR_STRT);
 8001ba6:	691a      	ldr	r2, [r3, #16]
 8001ba8:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8001bac:	611a      	str	r2, [r3, #16]
 8001bae:	4770      	bx	lr
 8001bb0:	20000ab0 	.word	0x20000ab0
 8001bb4:	40022000 	.word	0x40022000

08001bb8 <HAL_FLASHEx_Erase>:
  *         (0xFFFFFFFF means that all the pages have been correctly erased)
  *
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef HAL_FLASHEx_Erase(FLASH_EraseInitTypeDef *pEraseInit, uint32_t *PageError)
{
 8001bb8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  HAL_StatusTypeDef status = HAL_ERROR;
  uint32_t address = 0;

  /* Process Locked */
  __HAL_LOCK(&pFlash);
 8001bbc:	4d23      	ldr	r5, [pc, #140]	; (8001c4c <HAL_FLASHEx_Erase+0x94>)
  *         (0xFFFFFFFF means that all the pages have been correctly erased)
  *
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef HAL_FLASHEx_Erase(FLASH_EraseInitTypeDef *pEraseInit, uint32_t *PageError)
{
 8001bbe:	4607      	mov	r7, r0
  HAL_StatusTypeDef status = HAL_ERROR;
  uint32_t address = 0;

  /* Process Locked */
  __HAL_LOCK(&pFlash);
 8001bc0:	7e2b      	ldrb	r3, [r5, #24]
  *         (0xFFFFFFFF means that all the pages have been correctly erased)
  *
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef HAL_FLASHEx_Erase(FLASH_EraseInitTypeDef *pEraseInit, uint32_t *PageError)
{
 8001bc2:	4688      	mov	r8, r1
  HAL_StatusTypeDef status = HAL_ERROR;
  uint32_t address = 0;

  /* Process Locked */
  __HAL_LOCK(&pFlash);
 8001bc4:	2b01      	cmp	r3, #1
 8001bc6:	d03e      	beq.n	8001c46 <HAL_FLASHEx_Erase+0x8e>

  /* Check the parameters */
  assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));

  if (pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
 8001bc8:	6803      	ldr	r3, [r0, #0]
{
  HAL_StatusTypeDef status = HAL_ERROR;
  uint32_t address = 0;

  /* Process Locked */
  __HAL_LOCK(&pFlash);
 8001bca:	2401      	movs	r4, #1

  /* Check the parameters */
  assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));

  if (pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
 8001bcc:	2b02      	cmp	r3, #2
{
  HAL_StatusTypeDef status = HAL_ERROR;
  uint32_t address = 0;

  /* Process Locked */
  __HAL_LOCK(&pFlash);
 8001bce:	762c      	strb	r4, [r5, #24]
    else 
#endif /* FLASH_BANK2_END */
    {
      /* Mass Erase requested for Bank1 */
      /* Wait for last operation to be completed */
      if (FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE) == HAL_OK)
 8001bd0:	f24c 3050 	movw	r0, #50000	; 0xc350
  __HAL_LOCK(&pFlash);

  /* Check the parameters */
  assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));

  if (pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
 8001bd4:	d110      	bne.n	8001bf8 <HAL_FLASHEx_Erase+0x40>
    else 
#endif /* FLASH_BANK2_END */
    {
      /* Mass Erase requested for Bank1 */
      /* Wait for last operation to be completed */
      if (FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE) == HAL_OK)
 8001bd6:	f7ff ff59 	bl	8001a8c <FLASH_WaitForLastOperation>
 8001bda:	b108      	cbz	r0, 8001be0 <HAL_FLASHEx_Erase+0x28>
  *
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef HAL_FLASHEx_Erase(FLASH_EraseInitTypeDef *pEraseInit, uint32_t *PageError)
{
  HAL_StatusTypeDef status = HAL_ERROR;
 8001bdc:	2001      	movs	r0, #1
 8001bde:	e02e      	b.n	8001c3e <HAL_FLASHEx_Erase+0x86>
      /* Mass Erase requested for Bank1 */
      /* Wait for last operation to be completed */
      if (FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE) == HAL_OK)
      {
        /*Mass erase to be done*/
        FLASH_MassErase(FLASH_BANK_1);
 8001be0:	f7ff ffc6 	bl	8001b70 <FLASH_MassErase.isra.0>
        
        /* Wait for last operation to be completed */
        status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8001be4:	f24c 3050 	movw	r0, #50000	; 0xc350
 8001be8:	f7ff ff50 	bl	8001a8c <FLASH_WaitForLastOperation>
        
        /* If the erase operation is completed, disable the MER Bit */
        CLEAR_BIT(FLASH->CR, FLASH_CR_MER);
 8001bec:	4a18      	ldr	r2, [pc, #96]	; (8001c50 <HAL_FLASHEx_Erase+0x98>)
 8001bee:	6913      	ldr	r3, [r2, #16]
 8001bf0:	f023 0304 	bic.w	r3, r3, #4
 8001bf4:	6113      	str	r3, [r2, #16]
 8001bf6:	e022      	b.n	8001c3e <HAL_FLASHEx_Erase+0x86>
    else
#endif /* FLASH_BANK2_END */
   {
      /* Page Erase requested on address located on bank1 */
      /* Wait for last operation to be completed */
      if (FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE) == HAL_OK)
 8001bf8:	f7ff ff48 	bl	8001a8c <FLASH_WaitForLastOperation>
 8001bfc:	2800      	cmp	r0, #0
 8001bfe:	d1ed      	bne.n	8001bdc <HAL_FLASHEx_Erase+0x24>
  *
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef HAL_FLASHEx_Erase(FLASH_EraseInitTypeDef *pEraseInit, uint32_t *PageError)
{
  HAL_StatusTypeDef status = HAL_ERROR;
 8001c00:	4620      	mov	r0, r4
      /* Page Erase requested on address located on bank1 */
      /* Wait for last operation to be completed */
      if (FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE) == HAL_OK)
      {
        /*Initialization of PageError variable*/
        *PageError = 0xFFFFFFFF;
 8001c02:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8001c06:	f8c8 3000 	str.w	r3, [r8]
        
        /* Erase page by page to be done*/
        for(address = pEraseInit->PageAddress;
 8001c0a:	68be      	ldr	r6, [r7, #8]
            address < ((pEraseInit->NbPages * FLASH_PAGE_SIZE) + pEraseInit->PageAddress);
 8001c0c:	68fa      	ldr	r2, [r7, #12]
 8001c0e:	68bb      	ldr	r3, [r7, #8]
 8001c10:	eb03 2382 	add.w	r3, r3, r2, lsl #10
      {
        /*Initialization of PageError variable*/
        *PageError = 0xFFFFFFFF;
        
        /* Erase page by page to be done*/
        for(address = pEraseInit->PageAddress;
 8001c14:	429e      	cmp	r6, r3
 8001c16:	d212      	bcs.n	8001c3e <HAL_FLASHEx_Erase+0x86>
            address < ((pEraseInit->NbPages * FLASH_PAGE_SIZE) + pEraseInit->PageAddress);
            address += FLASH_PAGE_SIZE)
        {
          FLASH_PageErase(address);
 8001c18:	4630      	mov	r0, r6
 8001c1a:	f7ff ffbb 	bl	8001b94 <FLASH_PageErase>
          
          /* Wait for last operation to be completed */
          status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8001c1e:	f24c 3050 	movw	r0, #50000	; 0xc350
 8001c22:	f7ff ff33 	bl	8001a8c <FLASH_WaitForLastOperation>
          
          /* If the erase operation is completed, disable the PER Bit */
          CLEAR_BIT(FLASH->CR, FLASH_CR_PER);
 8001c26:	4a0a      	ldr	r2, [pc, #40]	; (8001c50 <HAL_FLASHEx_Erase+0x98>)
 8001c28:	6913      	ldr	r3, [r2, #16]
 8001c2a:	f023 0302 	bic.w	r3, r3, #2
 8001c2e:	6113      	str	r3, [r2, #16]
          
          if (status != HAL_OK)
 8001c30:	b110      	cbz	r0, 8001c38 <HAL_FLASHEx_Erase+0x80>
          {
            /* In case of error, stop erase procedure and return the faulty address */
            *PageError = address;
 8001c32:	f8c8 6000 	str.w	r6, [r8]
            break;
 8001c36:	e002      	b.n	8001c3e <HAL_FLASHEx_Erase+0x86>
        *PageError = 0xFFFFFFFF;
        
        /* Erase page by page to be done*/
        for(address = pEraseInit->PageAddress;
            address < ((pEraseInit->NbPages * FLASH_PAGE_SIZE) + pEraseInit->PageAddress);
            address += FLASH_PAGE_SIZE)
 8001c38:	f506 6680 	add.w	r6, r6, #1024	; 0x400
 8001c3c:	e7e6      	b.n	8001c0c <HAL_FLASHEx_Erase+0x54>
      }
    }
  }

  /* Process Unlocked */
  __HAL_UNLOCK(&pFlash);
 8001c3e:	2300      	movs	r3, #0
 8001c40:	762b      	strb	r3, [r5, #24]

  return status;
 8001c42:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
{
  HAL_StatusTypeDef status = HAL_ERROR;
  uint32_t address = 0;

  /* Process Locked */
  __HAL_LOCK(&pFlash);
 8001c46:	2002      	movs	r0, #2

  /* Process Unlocked */
  __HAL_UNLOCK(&pFlash);

  return status;
}
 8001c48:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8001c4c:	20000ab0 	.word	0x20000ab0
 8001c50:	40022000 	.word	0x40022000

08001c54 <strlen>:
 8001c54:	f020 0103 	bic.w	r1, r0, #3
 8001c58:	f010 0003 	ands.w	r0, r0, #3
 8001c5c:	f1c0 0000 	rsb	r0, r0, #0
 8001c60:	f851 3b04 	ldr.w	r3, [r1], #4
 8001c64:	f100 0c04 	add.w	ip, r0, #4
 8001c68:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 8001c6c:	f06f 0200 	mvn.w	r2, #0
 8001c70:	bf1c      	itt	ne
 8001c72:	fa22 f20c 	lsrne.w	r2, r2, ip
 8001c76:	4313      	orrne	r3, r2
 8001c78:	f04f 0c01 	mov.w	ip, #1
 8001c7c:	ea4c 2c0c 	orr.w	ip, ip, ip, lsl #8
 8001c80:	ea4c 4c0c 	orr.w	ip, ip, ip, lsl #16
 8001c84:	eba3 020c 	sub.w	r2, r3, ip
 8001c88:	ea22 0203 	bic.w	r2, r2, r3
 8001c8c:	ea12 12cc 	ands.w	r2, r2, ip, lsl #7
 8001c90:	bf04      	itt	eq
 8001c92:	f851 3b04 	ldreq.w	r3, [r1], #4
 8001c96:	3004      	addeq	r0, #4
 8001c98:	d0f4      	beq.n	8001c84 <strlen+0x30>
 8001c9a:	f1c2 0100 	rsb	r1, r2, #0
 8001c9e:	ea02 0201 	and.w	r2, r2, r1
 8001ca2:	fab2 f282 	clz	r2, r2
 8001ca6:	f1c2 021f 	rsb	r2, r2, #31
 8001caa:	eb00 00d2 	add.w	r0, r0, r2, lsr #3
 8001cae:	4770      	bx	lr

08001cb0 <strncmp>:
 8001cb0:	2a00      	cmp	r2, #0
 8001cb2:	d03c      	beq.n	8001d2e <strncmp+0x7e>
 8001cb4:	ea40 0301 	orr.w	r3, r0, r1
 8001cb8:	f013 0303 	ands.w	r3, r3, #3
 8001cbc:	b4f0      	push	{r4, r5, r6, r7}
 8001cbe:	d125      	bne.n	8001d0c <strncmp+0x5c>
 8001cc0:	2a03      	cmp	r2, #3
 8001cc2:	d923      	bls.n	8001d0c <strncmp+0x5c>
 8001cc4:	6804      	ldr	r4, [r0, #0]
 8001cc6:	680d      	ldr	r5, [r1, #0]
 8001cc8:	42ac      	cmp	r4, r5
 8001cca:	d11f      	bne.n	8001d0c <strncmp+0x5c>
 8001ccc:	3a04      	subs	r2, #4
 8001cce:	d030      	beq.n	8001d32 <strncmp+0x82>
 8001cd0:	f1a4 3501 	sub.w	r5, r4, #16843009	; 0x1010101
 8001cd4:	ea25 0404 	bic.w	r4, r5, r4
 8001cd8:	f014 3f80 	tst.w	r4, #2155905152	; 0x80808080
 8001cdc:	d12c      	bne.n	8001d38 <strncmp+0x88>
 8001cde:	1d07      	adds	r7, r0, #4
 8001ce0:	1d0d      	adds	r5, r1, #4
 8001ce2:	e00d      	b.n	8001d00 <strncmp+0x50>
 8001ce4:	f857 3b04 	ldr.w	r3, [r7], #4
 8001ce8:	680e      	ldr	r6, [r1, #0]
 8001cea:	f1a3 3401 	sub.w	r4, r3, #16843009	; 0x1010101
 8001cee:	42b3      	cmp	r3, r6
 8001cf0:	ea24 0403 	bic.w	r4, r4, r3
 8001cf4:	d10a      	bne.n	8001d0c <strncmp+0x5c>
 8001cf6:	3a04      	subs	r2, #4
 8001cf8:	d01b      	beq.n	8001d32 <strncmp+0x82>
 8001cfa:	f014 3f80 	tst.w	r4, #2155905152	; 0x80808080
 8001cfe:	d11e      	bne.n	8001d3e <strncmp+0x8e>
 8001d00:	2a03      	cmp	r2, #3
 8001d02:	4629      	mov	r1, r5
 8001d04:	4638      	mov	r0, r7
 8001d06:	f105 0504 	add.w	r5, r5, #4
 8001d0a:	d8eb      	bhi.n	8001ce4 <strncmp+0x34>
 8001d0c:	7803      	ldrb	r3, [r0, #0]
 8001d0e:	780c      	ldrb	r4, [r1, #0]
 8001d10:	3a01      	subs	r2, #1
 8001d12:	42a3      	cmp	r3, r4
 8001d14:	d108      	bne.n	8001d28 <strncmp+0x78>
 8001d16:	b162      	cbz	r2, 8001d32 <strncmp+0x82>
 8001d18:	b173      	cbz	r3, 8001d38 <strncmp+0x88>
 8001d1a:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 8001d1e:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 8001d22:	3a01      	subs	r2, #1
 8001d24:	42a3      	cmp	r3, r4
 8001d26:	d0f6      	beq.n	8001d16 <strncmp+0x66>
 8001d28:	1b18      	subs	r0, r3, r4
 8001d2a:	bcf0      	pop	{r4, r5, r6, r7}
 8001d2c:	4770      	bx	lr
 8001d2e:	4610      	mov	r0, r2
 8001d30:	4770      	bx	lr
 8001d32:	4610      	mov	r0, r2
 8001d34:	bcf0      	pop	{r4, r5, r6, r7}
 8001d36:	4770      	bx	lr
 8001d38:	4618      	mov	r0, r3
 8001d3a:	bcf0      	pop	{r4, r5, r6, r7}
 8001d3c:	4770      	bx	lr
 8001d3e:	2000      	movs	r0, #0
 8001d40:	e7f3      	b.n	8001d2a <strncmp+0x7a>
 8001d42:	bf00      	nop

08001d44 <_init>:
 8001d44:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001d46:	bf00      	nop
 8001d48:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8001d4a:	bc08      	pop	{r3}
 8001d4c:	469e      	mov	lr, r3
 8001d4e:	4770      	bx	lr

08001d50 <_fini>:
 8001d50:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001d52:	bf00      	nop
 8001d54:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8001d56:	bc08      	pop	{r3}
 8001d58:	469e      	mov	lr, r3
 8001d5a:	4770      	bx	lr
